<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="数据结构,哈希表,leetcode,栈,队列,二叉树,数组,链表," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1" />






<meta name="description" content="对常用数据结构及 Leetcode 相关练习进行总结，包括栈与队列、哈希表、二叉树、数组、链表五个部分。">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode 数据结构">
<meta property="og:url" content="https:&#x2F;&#x2F;xieyiyu.github.io&#x2F;2019&#x2F;01&#x2F;20&#x2F;%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;index.html">
<meta property="og:site_name" content="Cactus Blog">
<meta property="og:description" content="对常用数据结构及 Leetcode 相关练习进行总结，包括栈与队列、哈希表、二叉树、数组、链表五个部分。">
<meta property="og:image" content="https:&#x2F;&#x2F;res.cloudinary.com&#x2F;dty6stpv6&#x2F;image&#x2F;upload&#x2F;v1552209599&#x2F;trie.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;res.cloudinary.com&#x2F;dty6stpv6&#x2F;image&#x2F;upload&#x2F;v1552209599&#x2F;138.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;res.cloudinary.com&#x2F;dty6stpv6&#x2F;image&#x2F;upload&#x2F;v1552209599&#x2F;142.png">
<meta property="article:published_time" content="2019-01-20T08:12:08.000Z">
<meta property="article:modified_time" content="2019-07-28T05:32:00.000Z">
<meta property="article:author" content="Cactus">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="哈希表">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="栈">
<meta property="article:tag" content="队列">
<meta property="article:tag" content="二叉树">
<meta property="article:tag" content="数组">
<meta property="article:tag" content="链表">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;res.cloudinary.com&#x2F;dty6stpv6&#x2F;image&#x2F;upload&#x2F;v1552209599&#x2F;trie.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xieyiyu.github.io/2019/01/20/算法-数据结构/"/>





  <title>leetcode 数据结构 | Cactus Blog</title>
  














<meta name="generator" content="Hexo 4.1.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Cactus Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://xieyiyu.github.io/2019/01/20/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Cactus">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cactus Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">leetcode 数据结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-20T16:12:08+08:00">
                2019-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>对常用数据结构及 Leetcode 相关练习进行总结，包括栈与队列、哈希表、二叉树、数组、链表五个部分。</p>
<a id="more"></a>

<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>栈是一个只能从同一端插入或删除的线性表，是先进后出。插入删除端为栈顶，另一端为栈底。<br>对于栈 [1, 2, 3, 4], 1 是栈底，4 是栈顶。</p>
<p>队列是一个从一端插入，从另一端删除的线性表，是先进先出。插入端为队尾，删除端队头。<br>对于队列 [4, 3, 2, 1], 1 是队尾，4 是队头。</p>
<h3 id="用栈实现括号匹配"><a href="#用栈实现括号匹配" class="headerlink" title="用栈实现括号匹配"></a>用栈实现括号匹配</h3><p><a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">Leetcode : 20. Valid Parentheses (Easy)</a></p>
<p>思路：栈最典型的应用即验证配对情况，对一个有效的括号对，左括号必定在右括号前面，因此可以将所有的左括号入栈，遇到匹配的右括号就将栈顶的括号消除，必定会有至少一对括号在 s 中是相邻的，因此一直消除栈顶，如果遇到不匹配的括号，直接返回 False，但栈为空时，即没有左括号，此时仍有右括号，则返回 False，最后所有字符都遍历完成后，栈为空则返回 True， 栈非空返回 Flase。  </p>
<p>可以利用 dict 来存储括号对，从而提高代码效率。  </p>
<p>时间复杂度为 o(n), 空间复杂度为 o(n)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(s)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    dict = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> dict:</span><br><span class="line">            stack.append(c)</span><br><span class="line">        <span class="keyword">elif</span> len(stack) == <span class="number">0</span> <span class="keyword">or</span> dict[stack.pop()] != c:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>

<h3 id="Evaluate-Reverse-Polish-Notation"><a href="#Evaluate-Reverse-Polish-Notation" class="headerlink" title="Evaluate Reverse Polish Notation"></a>Evaluate Reverse Polish Notation</h3><p><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/" target="_blank" rel="noopener">Leetcode : 150. Evaluate Reverse Polish Notation (Medium)</a></p>
<p><a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank" rel="noopener">逆波兰式</a></p>
<p>除法的时候需要注意：python中的 ‘//‘ 除法和 C语言 不太一样。在 python 中，(-1)//2=-1，而在 C语言中，(-1)/2=0。<br>这道题的 oj 是默认的 C语言 中的语法，所以需要在遇到 ‘/‘ 的时候注意一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="keyword">if</span> char != <span class="string">'+'</span> <span class="keyword">and</span> char != <span class="string">'-'</span> <span class="keyword">and</span> char != <span class="string">'*'</span> <span class="keyword">and</span> char != <span class="string">'/'</span>: <span class="comment"># 如果是负数，用 isdigit() 无效</span></span><br><span class="line">            stack.append(int(char))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = stack.pop()</span><br><span class="line">            b = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">'+'</span>:</span><br><span class="line">                stack.append(a+b)</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">'-'</span>:</span><br><span class="line">                stack.append(b-a)</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">'*'</span>:</span><br><span class="line">                stack.append(a*b)</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">'/'</span>:</span><br><span class="line">                <span class="keyword">if</span> a*b &lt; <span class="number">0</span>:</span><br><span class="line">                    stack.append(-((-b)//a))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(b//a)</span><br><span class="line">    <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>

<p>判断是否为整数，若为负数时，可以用 if char.lstrip(‘-‘).isdigit()</p>
<h3 id="最小值栈"><a href="#最小值栈" class="headerlink" title="最小值栈"></a>最小值栈</h3><p><a href="https://leetcode.com/problems/min-stack/description/" target="_blank" rel="noopener">Leetcode : 155. Min Stack (Easy)</a></p>
<p>问题描述：题目要求得到最小值的时间复杂度为 o(1)，因此需要以空间换时间，可以使用两个栈来实现，一个栈存储原始数据，另一个栈存储最小值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack, self.minstack = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minstack <span class="keyword">or</span> x &lt;= self.minstack[<span class="number">-1</span>]:  <span class="comment">#1</span></span><br><span class="line">            self.minstack.append(x)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.minstack <span class="keyword">and</span> self.minstack[<span class="number">-1</span>] == self.top():</span><br><span class="line">            self.minstack.pop()</span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.minstack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>备注： 1. 必须要是 x &lt;= self.minstack[-1]，重复元素也应该加到 minstack 中，否则在删除时会删除唯一的 min 值。</p>
<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/" target="_blank" rel="noopener">Leetcode : 232. Implement Queue using Stacks (Easy)</a></p>
<p>问题描述：用栈来实现队列，假设队列 q = [1, 2, 3, 4]，那么其在栈里面的顺序是 s = [4, 3, 2, 1]。push() 要在队列 q 的队尾增加一个元素， 则在栈 s 中应该在栈顶增加一个元素，变为 s = [x, 4, 3, 2, 1]，可以使用两个栈来实现，一个只进行入栈 push 操作，一个只进行出栈 pop 操作，因此只需要在 instack 中追加元素 x 即可实现；pop() 删除队头元素 1，而在栈 s 中 1 是先进后出，因此可以将其全部 push 到 outstack 中，再取出栈顶元素即可。  </p>
<p>push() 时间复杂度 o(1)<br>pop(), peek() 时间复杂度 o(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.instack, self.outstack = [],[]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.instack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.in2out()</span><br><span class="line">        self.outstack.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.in2out()</span><br><span class="line">        <span class="keyword">return</span> self.outstack[<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.instack <span class="keyword">and</span> <span class="keyword">not</span> self.outstack</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in2out</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.outstack:</span><br><span class="line">            <span class="keyword">while</span> self.instack:</span><br><span class="line">                self.outstack.append(self.instack.pop())</span><br></pre></td></tr></table></figure>

<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p><a href="https://leetcode.com/problems/implement-stack-using-queues/description/" target="_blank" rel="noopener">Leetcode : 225. Implement Stack using Queues (Easy)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue = [] </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.queue.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.queue) - <span class="number">1</span>):</span><br><span class="line">            self.queue.append(self.queue.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> self.queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.queue) - <span class="number">1</span>):</span><br><span class="line">            self.queue.append(self.queue.pop(<span class="number">0</span>))</span><br><span class="line">        result = self.queue[<span class="number">0</span>]</span><br><span class="line">        self.queue.append(self.queue.pop(<span class="number">0</span>)) <span class="comment"># 恢复原样</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>python 的内建数据类型字典是用哈希表来实现的，使用哈希表可以快速查找一个元素是否存在，但需要一定的存储空间。因此在优先考虑时间复杂度的情况下，可以使用哈希表来以空间换时间。  </p>
<blockquote>
<p><strong>字典 dict 的遍历</strong><br>遍历 key 值：for key in dict<br>遍历 value 值：for value in dict.values()<br>遍历字典项：for kv in dict.items()<br>遍历 key 和 value 值 : for key, value in dict.items()  </p>
<p>dict.get(key) : 返回指定键的值，不存在则返回 None<br>dict.has_key(key) : 键在字典中返回 true，否则 false<br>dict.pop(key) ：删除该 key 和 value</p>
</blockquote>
<h3 id="两数之和-Two-Sum"><a href="#两数之和-Two-Sum" class="headerlink" title="两数之和 Two Sum"></a>两数之和 Two Sum</h3><p><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">Leetcode : 1. Two Sum (Easy)</a></p>
<p>思路：使用字典来存储数组元素和索引的映射，将 nums[i] 和 i 存储到 dict 中，遍历一遍数组，若 target - nums[i] 在 dict 中，则直接返回两个数的下标。  </p>
<p>时间复杂度为 o(n)，空间复杂度为 o(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> false</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        tmp = target - nums[i]</span><br><span class="line">        <span class="keyword">if</span> tmp <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">return</span> [dic[tmp], i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dic[nums[i]] = i</span><br></pre></td></tr></table></figure>

<h3 id="无重复字符的最长子串-Longest-Substring-Without-Repeating-Characters"><a href="#无重复字符的最长子串-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="无重复字符的最长子串 Longest Substring Without Repeating Characters"></a>无重复字符的最长子串 Longest Substring Without Repeating Characters</h3><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">Leetcode : 3. Longest Substring Without Repeating Characters(Medium)</a></p>
<p>思路：使用哈希表来记录字符及其位置，当遇到重复字符时，应该从该字符的下一个字符开始重新计数，并且更新该字符在哈希表中的位置值。记录计数的起始位置为 start，当前字符位置为 i，则子串的长度为 i-start+1，不断更新最大长度得到最终结果。  </p>
<p>注意：start &lt;= dict[s[i]] 也就是要小于等于重复字符的上一个位置市才重新开始计数，否则就加上该字符。  </p>
<p>时间复杂度为 o(n), 空间复杂度为 o(1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        maxlength = start = <span class="number">0</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> dict <span class="keyword">and</span> start &lt;= dict[s[i]]:</span><br><span class="line">                start = dict[s[i]] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxlength = max(maxlength, i-start+<span class="number">1</span>)</span><br><span class="line">            dict[s[i]] = i</span><br><span class="line">        <span class="keyword">return</span> maxlength</span><br></pre></td></tr></table></figure>

<h3 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h3><p><a href="https://leetcode.com/problems/single-number/description/" target="_blank" rel="noopener">Leetocde : 136. 137. Single Number(Easy)</a></p>
<p>思路：用哈希表来记录数字及其出现的次数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(nums)</span>:</span></span><br><span class="line">    cnt = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> cnt:</span><br><span class="line">            cnt[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cnt[num] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> num, count <span class="keyword">in</span> cnt.items():</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>

<h3 id="Repeated-DNA-Sequences"><a href="#Repeated-DNA-Sequences" class="headerlink" title="Repeated DNA Sequences"></a>Repeated DNA Sequences</h3><p><a href="https://leetcode.com/problems/repeated-dna-sequences/description/" target="_blank" rel="noopener">Leetocde : 187. Repeated DNA Sequences (Medium)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRepeatedDnaSequences</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-9</span>):</span><br><span class="line">        key = s[i:i+<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">            dic[key] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                res.append(key)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="同构字符串-Isomorphic-Strings"><a href="#同构字符串-Isomorphic-Strings" class="headerlink" title="同构字符串 Isomorphic Strings"></a>同构字符串 Isomorphic Strings</h3><p><a href="https://leetcode.com/problems/isomorphic-strings/description/" target="_blank" rel="noopener">Leetcode : 205. Isomorphic Strings (Easy)</a></p>
<p>问题描述：判断两个字符串是否是同构字符串，如果一个字符串 s 中的字符可以替换成别的字符，从而得到另一个字符串 t，则 s 和 t 是同构字符串。并且 s 中的所有相同字符都要被替换，保持原来的顺序，两个不同的字符不可以替换成相同的字符，字符也可以不替换。  </p>
<p>思路：用字典来存储 s[i] 和 t[i]，将第一个字符串 s 的字符作为 key，第二个字符串 t 的字符作为 value，遍历一遍数组，有两种情况：  </p>
<ol>
<li>当 s[i] 在 dic 中时，s[i] 的 value 不等于 t[i] 时，则直接返回 False，相等则继续遍历。  </li>
<li>当 s[i] 不在 dic 中时，若此时对应的 t[i] 却在 dic 的 values 中，则表明已经有一个 key 对应了这个 t[i]，现在 s[i] 对应的字符也是 t[i]，由于不能有两个不同的字符对应同一个字符，因此返回 False；否则将这一对 s[i] 作为 key，t[i] 作为 value 存入 dic 中。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">if</span> t[i] != dic[s[i]]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> t[i] <span class="keyword">in</span> dic.values():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dic[s[i]] = t[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="最长和谐序列-Longest-Harmonious-Subsequence"><a href="#最长和谐序列-Longest-Harmonious-Subsequence" class="headerlink" title="最长和谐序列 Longest Harmonious Subsequence"></a>最长和谐序列 Longest Harmonious Subsequence</h3><p><a href="https://leetcode.com/problems/longest-harmonious-subsequence/description/" target="_blank" rel="noopener">Leetcode : 594. Longest Harmonious Subsequence (Easy)</a></p>
<p>问题描述：找出数组中的最长和谐序列，其最大数和最小数之间只相差 1。  </p>
<p>思路：在最长和谐序列中，只可能出现两种数字，这两个数字之间相差 1，因此可以先对 nums 进行计数，得到 nums[i]：count[i] 的一个字典，遍历该字典，对每个 key 判断 key+1 是否在其中，并返回次数和的最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_LHS</span><span class="params">(nums)</span>:</span></span><br><span class="line">    dict = collections.Counter(nums)</span><br><span class="line">    output = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> dict:</span><br><span class="line">        <span class="keyword">if</span> key + <span class="number">1</span> <span class="keyword">in</span> dict:</span><br><span class="line">           output = max(output, dict[key] + dict[key+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：python 标准库 collections 模块中的 Counter 类，用于跟踪值出现的次数，以字典的键对值形式进行存储，元素作为 key，其计数作为 value。</p>
</blockquote>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树（Binary Tree）是 n 个节点的有限集合，该集合可以为空集（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。   </p>
<ul>
<li>满二叉树的第 i 层有 2<sup>i-1</sup> 个节点， 总共有 2<sup>i</sup>-1 个节点，总节点数一定是奇数。  </li>
<li>若二叉树有 n 个节点，则该二叉树的高度为 h=log<sub>2</sub>(n+1)。</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>二叉树是一种递归结构，很多问题可以使用递归解决。  </p>
<p>下面各题中对于二叉树的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h4 id="相同树"><a href="#相同树" class="headerlink" title="相同树"></a>相同树</h4><p><a href="https://leetcode.com/problems/same-tree/description/" target="_blank" rel="noopener">Leetcode : 100. Same Tree (Easy)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> p <span class="keyword">and</span> q) <span class="keyword">or</span> (<span class="keyword">not</span> q <span class="keyword">and</span> p):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure>

<h4 id="对称树"><a href="#对称树" class="headerlink" title="对称树"></a>对称树</h4><p><a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener">Leetcode : 101. Symmetric Tree (Easy)</a></p>
<p>思路： 由于输入只有 root，而判断对称树需要比较左右节点是否相等，因此可以构造一个辅助函数 symmetric 来比较左右节点的值。  </p>
<ol>
<li>终止条件是已经到了叶子节点，即 left == None and right == None  </li>
<li>当左右节点的值相等时，继续递归比较左节点的左子树与右节点的右子树是否相等，以及左节点的右子树与右节点的左子树是否相等。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 空树为对称树</span></span><br><span class="line">        <span class="keyword">return</span> self.symmetric(root.left, root.right)</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">symmetric</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right <span class="keyword">and</span> left.val == right.val:</span><br><span class="line">            <span class="keyword">return</span> self.symmetric(left.left, right.right) <span class="keyword">and</span> self.symmetric(left.right, right.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="二叉树的高度"><a href="#二叉树的高度" class="headerlink" title="二叉树的高度"></a>二叉树的高度</h4><p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 104. Maximum Depth of Binary Tree (Easy)</a></p>
<p>问题描述： 求二叉树的高度，利用递归计算，返回左子树和右子树中较大的深度，再加上 1 作为原二叉树的深度。  </p>
<p>时间复杂度为 o(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 110. Balanced Binary Tree (Easy)</a></p>
<p>思路：平衡二叉树是二叉树的任意节点的两颗子树之间的高度差小于等于 1。对于平衡二叉树，其左子树和右子树也是平衡二叉树，因此可以递归判断。需要构造一个函数来求二叉树的高度，可以用之前的 maxDepth。  </p>
<ol>
<li>终止条件：当左子树和右子树的最大高度相差 1 时，返回 False  </li>
<li>继续递归调用 isBalanced, 判断 root.left 和 root.right 是不是平衡二叉树。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.maxDepth(root.left) - self.maxDepth(root.right)) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="二叉树的最小高度"><a href="#二叉树的最小高度" class="headerlink" title="二叉树的最小高度"></a>二叉树的最小高度</h4><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 111. Minimum Depth of Binary Tree (Easy)</a></p>
<p>思路：简单思考有四种情况</p>
<ol>
<li>空树，返回 0</li>
<li>只有右子树，返回右子树高度</li>
<li>只有左子树，返回左子树高度</li>
<li>左右子树都有，返回左右子树高度的较小值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> self.minDepth(root.right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.left:</span><br><span class="line">            <span class="keyword">return</span> self.minDepth(root.left) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="路径和"><a href="#路径和" class="headerlink" title="路径和"></a>路径和</h4><p><a href="https://leetcode.com/problems/path-sum/description/" target="_blank" rel="noopener">Leetcdoe : 112. Path Sum (Easy)</a></p>
<p>思路：利用递归实现，如果根节点为空，则直接返回 False，如果到最后都没有出现 sum == 0 的情况时，再进行一轮递归，则 root == None， 因此也返回 False。必须要注意的是最后的返回一定是递归的结果，当 sum == 0 并且该节点为叶子节点时才返回 True。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        sum -= root.val</span><br><span class="line">        <span class="keyword">if</span> sum == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, sum) <span class="keyword">or</span> self.hasPathSum(root.right, sum)</span><br></pre></td></tr></table></figure>

<h4 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a>Path Sum II</h4><p><a href="https://leetcode.com/problems/path-sum-ii/description/" target="_blank" rel="noopener">Leetcdoe : 113. Path Sum II (Medium)</a></p>
<p>需要返回路径和等于 target 的所有路径集合。<br>思路： 与上一题类似，但需要保存符合要求的节点集合，需要注意的是递归的时候不要用 append 去追加元素到 path 中，会变为全局修改。在递归时，需要判断左右子树是否存在。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type sum: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.findPath([], sum, root)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPath</span><span class="params">(self, path, sum, root)</span>:</span></span><br><span class="line">        path = path + [root.val]</span><br><span class="line">        sum = sum - root.val</span><br><span class="line">        <span class="keyword">if</span> sum == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            self.res.append(path)</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.findPath(path, sum, root.left)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.findPath(path, sum, root.right)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>

<h4 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a>Populating Next Right Pointers in Each Node</h4><p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/" target="_blank" rel="noopener">Leetcode : 116. Populating Next Right Pointers in Each Node(Medium)</a></p>
<p>思路：将二叉树的每个节点都加上一个 next 属性，指向其右边的节点。假设每个父节点都有两个子节点。<br>因此可以如果该节点有左孩子，则必定有右孩子，此时 左孩子.next 指向 右孩子；<br>如果将节点的 next 不是 None，name说明该节点必定不是最右边的节点，则 右孩子.next = 该节点.next.left；<br>否则，该节点是最右边的节点，此时 该节点.right.next = None。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param root, a tree link node</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.left:</span><br><span class="line">            root.left.next = root.right</span><br><span class="line">            <span class="keyword">if</span> root.next:</span><br><span class="line">                root.right.next = root.next.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.right.next = <span class="literal">None</span></span><br><span class="line">            self.connect(root.left)</span><br><span class="line">            self.connect(root.right)</span><br></pre></td></tr></table></figure>

<h4 id="Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="Populating Next Right Pointers in Each Node II"></a>Populating Next Right Pointers in Each Node II</h4><p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/" target="_blank" rel="noopener">Leetcode : 117. Populating Next Right Pointers in Each Node II (Medium)</a></p>
<h4 id="Sum-Root-to-Leaf-Numbers"><a href="#Sum-Root-to-Leaf-Numbers" class="headerlink" title="Sum Root to Leaf Numbers"></a>Sum Root to Leaf Numbers</h4><p><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/description/" target="_blank" rel="noopener">Leetcode : 129. Sum Root to Leaf Numbers (Medium)</a></p>
<p>计算所有路径组成的数的和。<br>思路： 用 pre 来存储该节点 root 之前的路径组成的数，则加上该节点后的数为 pre = pre * 10 + root.val<br>然后返回左右子树相加递归的结果。 当遇到叶子节点时，该条路径遍历完，则返回 pre。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self, root, pre)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre = pre*<span class="number">10</span> + root.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line">        <span class="keyword">return</span> self.sum(root.left, pre) + self.sum(root.right, pre)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.sum(root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>DFS 解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sum = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, num)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                self.sum += num*<span class="number">10</span> + root.val</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                dfs(root.left, num*<span class="number">10</span>+root.val)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                dfs(root.right, num*<span class="number">10</span>+root.val)</span><br><span class="line">            </span><br><span class="line">        dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.sum</span><br></pre></td></tr></table></figure>

<h4 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h4><p><a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 226. Invert Binary Tree (Easy)</a></p>
<p>思路：反转二叉树，对于一个节点 root 而言，只需要将其左孩子和右孩子交换即可实现反转，递归调用即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line"></span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="归并二叉树"><a href="#归并二叉树" class="headerlink" title="归并二叉树"></a>归并二叉树</h4><p><a href="https://leetcode.com/problems/merge-two-binary-trees/description/" target="_blank" rel="noopener">Leetcode : 617. Merge Two Binary Trees (Easy)</a></p>
<p>思路：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1, t2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">and</span> <span class="keyword">not</span> t2:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> t1:</span><br><span class="line">        <span class="keyword">return</span> t2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> t2:</span><br><span class="line">        <span class="keyword">return</span> t1</span><br><span class="line">    root = TreeNode(t1.val + t2.val)</span><br><span class="line">    root.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">    root.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \   \</span><br><span class="line">4   5   6</span><br></pre></td></tr></table></figure>
<ol>
<li>层次遍历，[1, 2, 3, 4, 5, 6]</li>
<li>前序遍历（根左右），[1, 2, 4, 5, 3, 6]</li>
<li>中序遍历（左根右），[4, 2, 5, 1, 3, 6]</li>
<li>后序遍历（左右根），[4, 5, 2, 6, 3, 1]<br>层次遍历使用 <strong>广度优先搜索 BFS</strong> 实现，<br>前中后序遍历使用 <strong>深度优先搜索 DFS</strong> 实现。</li>
</ol>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 144. Binary Tree Preorder Traversal (Medium)</a></p>
<p>递归实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.result.append(root.val)</span><br><span class="line">            self.preorderTraversal(root.left)</span><br><span class="line">            self.preorderTraversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br></pre></td></tr></table></figure>

<p>非递归实现：<br>利用堆栈，用迭代来实现二叉树的前序遍历，一直将左子树进栈，root-&gt;left-&gt;right</p>
<ol>
<li>当根节点存在时，保存根节点的值，并将根节点入栈</li>
<li>将根节点指向左子树</li>
<li>当根节点不存在时（即没有左子树），栈顶元素出栈，并将根节点指向栈顶元素的右子树</li>
<li>循环 123 步</li>
</ol>
<blockquote>
<p>总结：<br>非空：访问，进栈，向左走<br>空：出栈，向右走</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 94. Binary Tree Inorder Traversal (Medium)</a></p>
<p>非递归实现：<br>中序遍历同样利用堆栈实现，堆栈定义与前序遍历相同。left-&gt;root-&gt;right</p>
<ol>
<li>当根节点存在时，将根节点入栈，并将根节点指向左子树</li>
<li>当根节点不存在时（即没有左子树），栈顶元素出栈，保存栈顶元素的值（第一次即最左节点），并将根节点指向栈顶元素的右子树</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 145. Binary Tree Postorder Traversal (Hard)</a></p>
<p>非递归实现：<br>后序遍历同样利用堆栈实现，left-&gt;right-&gt;root，可以通过 root-&gt;right-&gt;left 的结果逆序输出得到，即与前序遍历相似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                root = node.left</span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">Leetcode : 102. Binary Tree Level Order Traversal (Medium)</a></p>
<p>思路：层次遍历利用队列的先进先出特性，将先进入队列的元素 pop 出来。<br>题中需要按照层次来打印出遍历结果，可以用一个临时列表存储二叉树一层的所有节点。即用 queue 来存储当前层元素， tmp 存储下一层元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            result.append([node.val <span class="keyword">for</span> node <span class="keyword">in</span> queue])</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">Leetcode : 107. Binary Tree Level Order Traversal II (Easy)</a></p>
<p>层次遍历，倒序输出遍历结果; 直接翻转102的结果，return result[::-1]</p>
<h4 id="Binary-Tree-Right-Side-View"><a href="#Binary-Tree-Right-Side-View" class="headerlink" title="Binary Tree Right Side View"></a>Binary Tree Right Side View</h4><p><a href="https://leetcode.com/problems/binary-tree-right-side-view/description/" target="_blank" rel="noopener">Leetcode : 199. Binary Tree Right Side View (Medium)</a></p>
<p>复用层次遍历的代码即可，用 queue 存储当前层的节点， tmp 存储下一层的节点，输出每一层 queue 最后一个节点的值即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        res.append(queue[<span class="number">-1</span>].val)</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                tmp.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                tmp.append(node.right)</span><br><span class="line">        queue = tmp</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="得到左下角节点值"><a href="#得到左下角节点值" class="headerlink" title="得到左下角节点值"></a>得到左下角节点值</h4><p><a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/" target="_blank" rel="noopener">Leetcode : 513. Find Bottom Left Tree Value (Medium)</a></p>
<p>思路：利用层次遍历，记录下每一层的元素，返回最后一层的第一个元素即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBottomLeftValue</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        result = root</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            result = queue[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">        <span class="keyword">return</span> result.val</span><br></pre></td></tr></table></figure>

<h4 id="二叉树每层节点的平均值"><a href="#二叉树每层节点的平均值" class="headerlink" title="二叉树每层节点的平均值"></a>二叉树每层节点的平均值</h4><p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/description/" target="_blank" rel="noopener">637. Average of Levels in Binary Tree (Easy)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            sum = <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                sum += node.val</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            result.append(sum/len(queue))</span><br><span class="line">            queue = tmp</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="Zigzag遍历"><a href="#Zigzag遍历" class="headerlink" title="Zigzag遍历"></a>Zigzag遍历</h4><p><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/" target="_blank" rel="noopener">Leetcode : 103. Binary Tree Zigzag Level Order Traversal (Medium)</a></p>
<p>思路： 之字形遍历二叉树，奇数行从左往右，偶数行从右往左，…<br>可以修改层次遍历的代码，通过判断 res 的长度，来判断当前行是奇数行还是偶数行，若是偶数行，则将结果翻转即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        nodes = [node.val <span class="keyword">for</span> node <span class="keyword">in</span> queue]</span><br><span class="line">        <span class="keyword">if</span> len(res) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            res.append(nodes)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(nodes[::<span class="number">-1</span>])</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                tmp.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                tmp.append(node.right)</span><br><span class="line">        queue = tmp</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="通过前序和中序遍历构造二叉树"><a href="#通过前序和中序遍历构造二叉树" class="headerlink" title="通过前序和中序遍历构造二叉树"></a>通过前序和中序遍历构造二叉树</h4><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</a></p>
<p>思路： 前序遍历的第一个元素必定是 root，在中序遍历中 root 左边的是左子树，右边是右子树，因此只要找到 root 在 inorder 中的位置，就分割成了左右子树，之后再根据左右子树的前序遍历和中序遍历进行递归构造二叉树即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">    index = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">    root.left = self.buildTree(preorder[<span class="number">1</span>:index+<span class="number">1</span>], inorder[:index])</span><br><span class="line">    root.right = self.buildTree(preorder[index+<span class="number">1</span>:], inorder[index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="通过中序和后序遍历构造二叉树"><a href="#通过中序和后序遍历构造二叉树" class="headerlink" title="通过中序和后序遍历构造二叉树"></a>通过中序和后序遍历构造二叉树</h4><p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</a></p>
<p>与上一题类似，需要注意的是 array 切片的边界问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder, postorder)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root = TreeNode(postorder[<span class="number">-1</span>])</span><br><span class="line">    index = inorder.index(root.val)</span><br><span class="line">    root.left = self.buildTree(inorder[:index], postorder[:index])</span><br><span class="line">    root.right = self.buildTree(inorder[index+<span class="number">1</span>:], postorder[index:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树（BST），又称二叉排序树、二叉搜索树。</p>
<ol>
<li>没有键值相等的节点</li>
<li>若<strong>左子树</strong>不为空，则左子树上节点值<strong>均小于</strong>根节点的值</li>
<li>若<strong>右子树</strong>不为空，则右子树上节点值<strong>均大于</strong>根节点的值</li>
<li>任意节点的左、右子树也是二叉查找树</li>
</ol>
<p>二叉查找树中序遍历一遍的结果是单调递增的，可以用于二分搜索。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，为 o(logn)，但当二叉查找树退化为单链表时，查找效率最低，最低为 o(n)。</p>
<h4 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a>Unique Binary Search Trees</h4><p><a href="https://leetcode.com/problems/unique-binary-search-trees/description/" target="_blank" rel="noopener">Leetcode : 96. Unique Binary Search Trees (Medium)</a></p>
<p>思路： 给定条件，求有多少种解，一般都是用动态规划，此时只要求解的数量。<br>序列从 1 到 n，当使用 1…n 中的每个数 i 作为根节点时，则 1…i-1 组成左子树，i+1…n 组成右子树，之后再递归构造左右子树，由于根节点唯一，则这样构造的二叉树都是唯一的。  </p>
<p>使用两个变量来记录：<br>G(n)： 长度为 n 的序列组成的 unique BST 数量<br>F(i,n)： 以 i 为根节点的，长度为 n 的序列组成的 unique BST 数量<br>那么 G(n) = F(1,n) + F(2,n) + … + F(n,n), 有 G(0) = 1, G(1) = 1<br>F(i,n) = G(i-1) * G(n-i)，即左子树有 i-1 个节点能构造的 BST 数与右子树有 n-i 个节点能构造的 BST 数之积。 </p>
<p>因此有 G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)  <strong>【卡特兰数】</strong></p>
<p>但是需要注意的是： 直接递归会超时。因此用动态规划解决。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">            dp[i] += dp[j]*dp[i-j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h4 id="Unique-Binary-Search-Trees-II"><a href="#Unique-Binary-Search-Trees-II" class="headerlink" title="Unique Binary Search Trees II"></a>Unique Binary Search Trees II</h4><p><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/description/" target="_blank" rel="noopener">Leetcode : 95. Unique Binary Search Trees II (Medium)</a></p>
<p><strong>此题不理解</strong></p>
<p>输出上一题的所有结果，需要枚举，考虑 DFS。  </p>
<p>根据 BST 的性质，1…i-1 构成左子树，i+1…n 构成右子树。<br>当 begin &gt; end 时，返回 [None]； 当 begin &lt;= end 时，用 left 和 right 来递归构造左右子树。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: List[TreeNode] # 返回一个根节点的list即可</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> self.dfs(<span class="number">1</span>, n)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, begin, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> begin &gt; end:</span><br><span class="line">        <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(begin, end+<span class="number">1</span>):</span><br><span class="line">        left = self.dfs(begin, i<span class="number">-1</span>)</span><br><span class="line">        right = self.dfs(i+<span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                root = TreeNode(i)</span><br><span class="line">                root.left = l</span><br><span class="line">                root.right = r</span><br><span class="line">                res.append(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="验证二叉查找树"><a href="#验证二叉查找树" class="headerlink" title="验证二叉查找树"></a>验证二叉查找树</h4><p><a href="https://leetcode.com/problems/validate-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 98. Validate Binary Search Tree (Medium)</a></p>
<p>思路：利用 BST 中序遍历是有序数组的特点来求解，只要当前节点的值小于或等于上一个节点的值，则直接返回 False，当遍历完成后返回 True</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> (<span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        stack = []</span><br><span class="line">        pre_val = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> node.val &lt;= pre_val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                pre_val = node.val</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h4 id="有序数组构造二叉查找树"><a href="#有序数组构造二叉查找树" class="headerlink" title="有序数组构造二叉查找树"></a>有序数组构造二叉查找树</h4><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 108. Convert Sorted Array to Binary Search Tree (Easy)</a></p>
<p>思路：BST 二叉查找树即 left &lt; root &lt; right，因此利用有序数组构造 BST，且需要满足平衡二叉树的定义，注意到题中只要求给出一种解法，因此可以利用数组中间的数来作为 root，该数左边的用来构造左子树，右边的构造右子树，即将数组分成三个部分， [0, mid-1], mid, [mid+1, len(nums)-1]，再递归产生左右子树即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.toBST(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toBST</span><span class="params">(self, nums, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span> </span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = self.toBST(nums, start, mid - <span class="number">1</span>)</span><br><span class="line">        root.right = self.toBST(nums, mid + <span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>直接使用中间点来构造，一直二分，可以保证是平衡二叉树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    i = len(nums) // <span class="number">2</span></span><br><span class="line">    root = TreeNode(nums[i])</span><br><span class="line">    root.left = self.sortedArrayToBST(nums[:i])</span><br><span class="line">    root.right = self.sortedArrayToBST(nums[i+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="有序链表构造二叉查找树"><a href="#有序链表构造二叉查找树" class="headerlink" title="有序链表构造二叉查找树"></a>有序链表构造二叉查找树</h4><p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 109. Convert Sorted List to Binary Search Tree (Medium)</a></p>
<p>直接将链表转为数组，再调用上一题的代码即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.sortedArrayToBST(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, arr, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(arr[mid])</span><br><span class="line">        root.left = self.sortedArrayToBST(arr, start, mid<span class="number">-1</span>)</span><br><span class="line">        root.right = self.sortedArrayToBST(arr, mid+<span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="二叉查找树中第k小的数"><a href="#二叉查找树中第k小的数" class="headerlink" title="二叉查找树中第k小的数"></a>二叉查找树中第k小的数</h4><p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/" target="_blank" rel="noopener">Leetcode : 230. Kth Smallest Element in a BST (Medium)</a></p>
<p>思路：利用中序遍历，当遍历到第 k 个数时返回当前节点的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        stack =[]</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count == k:</span><br><span class="line">                    <span class="keyword">return</span> node.val</span><br><span class="line">                root = node.right</span><br></pre></td></tr></table></figure>

<h4 id="二叉查找树的最近公共祖先"><a href="#二叉查找树的最近公共祖先" class="headerlink" title="二叉查找树的最近公共祖先"></a>二叉查找树的最近公共祖先</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree (Easy)</a></p>
<p>思路：由于二叉查找树的左子树节点的值小于根节点，右子树节点的值大于根节点，因此可以从根节点出发递归判断。</p>
<ol>
<li>若 root 的值大于 p 和 q 的值，则 LCA 在左子树</li>
<li>若 root 的值小于 p 和 q 的值，则 LCA 在右子树</li>
<li>若 root 的值介于 p 和 q 之间，则 root 就是 LCA</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 236. Lowest Common Ancestor of a Binary Tree (Medium) </a></p>
<p>思路：重点在于找到节点 p 和 q 在左子树还是右子树</p>
<ol>
<li>若当前结点为空或者与 p 和 q 一致，则返回该节点</li>
<li>递归寻找 p 和 q 在左、右子树的位置</li>
<li>若 p 和 q 分别在左、右子树上，则返回 root，否则就在左、右子树上</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p ,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>

<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。<br>除了最后一层之外，其余层的结点都是满的，且最后一层结点靠左对其。</p>
<h4 id="Count-Complete-Tree-Nodes"><a href="#Count-Complete-Tree-Nodes" class="headerlink" title="Count Complete Tree Nodes"></a>Count Complete Tree Nodes</h4><p><a href="https://leetcode.com/problems/count-complete-tree-nodes/description/" target="_blank" rel="noopener">Leetcode : 222. Count Complete Tree Nodes (Medium)</a></p>
<p>求完全二叉树的节点数。<br>思路： 简单做法为直接遍历，返回 len(res)，但没意义，会超时。  </p>
<p>对于完全二叉树：</p>
<ul>
<li>若左子树高度等于右子树高度，则左子树为满二叉树，右子树可能是完全二叉树也可能是满二叉树</li>
<li>若左子树高度大于右子树高度，则右子树为满二叉树，左子树为完全二叉树或满二叉树</li>
</ul>
<p>因此，可以通过求左右子树的高度来计算节点，高度只需要遍历最左边的节点即可。</p>
<ul>
<li>构造 get_height(root) 来得到树高</li>
<li>若左右子树高度相等，则返回节点数为 2<sup>left_height</sup>-1 + 1 + self.countNodes(root.right), 即左子树节点数+root节点+右子树节点数。</li>
<li>若左子树高度大于右子树高度，则返回节点数为 2<sup>right_height</sup>-1 + 1 + self.countNodes(root.left)。  </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        left_height = self.get_height(root.left)</span><br><span class="line">        right_height = self.get_height(root.right)</span><br><span class="line">        <span class="keyword">if</span> left_height == right_height:</span><br><span class="line">            count = <span class="number">2</span> ** left_height + self.countNodes(root.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = <span class="number">2</span> ** right_height + self.countNodes(root.left)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_height</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        height = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            height += <span class="number">1</span></span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">return</span> height</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="二叉树转链表-Flatten-Binary-Tree-to-Linked-List"><a href="#二叉树转链表-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="二叉树转链表 Flatten Binary Tree to Linked List"></a>二叉树转链表 Flatten Binary Tree to Linked List</h4><p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/" target="_blank" rel="noopener">Leetcode : 114. Flatten Binary Tree to Linked List (Medium)</a></p>
<p>问题描述：将一个二叉树变为一个链表。</p>
<p>思路：变平后的链表实际上是二叉树前序遍历的结果，因此先对二叉树进行前序遍历，得到结果，再重新组织该二叉树，注意需要的是原地操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: void Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    res = []    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res.append(root)</span><br><span class="line">        preOrderTraversal(root.left)</span><br><span class="line">        preOrderTraversal(root.right)</span><br><span class="line">    preOrderTraversal(root)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(res)):</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        root.right = res[i]</span><br><span class="line">        root = root.right</span><br></pre></td></tr></table></figure>

<h4 id="Binary-Search-Tree-Iterator"><a href="#Binary-Search-Tree-Iterator" class="headerlink" title="Binary Search Tree Iterator"></a>Binary Search Tree Iterator</h4><p><a href="https://leetcode.com/problems/binary-search-tree-iterator/description/" target="_blank" rel="noopener">Leetcode : 173. Binary Search Tree Iterator (Medium)</a></p>
<p>实现 BST 的 hasNext() 和 next() 方法。 next() 输出下一个最小的值。<br>简单做法： BST 中序遍历结果是递增的，直接先对 BST 进行中序遍历，再 pop(0) 删除第一个元素来输出。<br>可以用递归和非递归方法来进行中序遍历，该题中用递归的速度会更快一些。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.inorderTraversal(root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.inorderTraversal(root.left)</span><br><span class="line">            self.stack.append(root.val)</span><br><span class="line">            self.inorderTraversal(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="前缀树Trie"><a href="#前缀树Trie" class="headerlink" title="前缀树Trie"></a>前缀树Trie</h3><p>Trie，又称前缀树或字典树，是一种有序树状的数据结构，用于保存关联数组，其中的键通常是字符串。</p>
<div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1552209599/trie.jpg"></div>

<p>基本性质：</p>
<ol>
<li>根节点不包含字符，根节点外每一个节点都只包含一个字符。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符串不相同。</li>
</ol>
<h4 id="实现Trie"><a href="#实现Trie" class="headerlink" title="实现Trie"></a>实现Trie</h4><p><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">Leetcode : 208. Implement Trie (Prefix Tree) (Medium)</a></p>
<blockquote>
<p>Implement a trie with insert, search, and startsWith methods.<br>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p>
</blockquote>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="两个有序数组的中位数-Median-of-Two-Sorted-Arrays"><a href="#两个有序数组的中位数-Median-of-Two-Sorted-Arrays" class="headerlink" title="两个有序数组的中位数 Median of Two Sorted Arrays"></a>两个有序数组的中位数 Median of Two Sorted Arrays</h3><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">Leetcode : 4. Median of Two Sorted Arrays (Hard)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">    nums = nums1 + nums2</span><br><span class="line">    nums.sort()</span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> float(<span class="string">'%.1f'</span> %((nums[n//<span class="number">2</span><span class="number">-1</span>] + nums[n//<span class="number">2</span>])/<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> float(<span class="string">'%.1f'</span> %(nums[(n<span class="number">-1</span>)//<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>

<h3 id="Remove-Duplicates-from-Sorted-Array"><a href="#Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Remove Duplicates from Sorted Array"></a>Remove Duplicates from Sorted Array</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">Leetcode : 26. Remove Duplicates from Sorted Array(Easy)</a></p>
<p>思路：数组有序，则重复元素必定相邻。使用两个下标，i 记录当前元素位置，j 记录新数组的元素位置，当 nums[i] != nums[i-1] 时，就将这个重复元素放到新数组中（注意这里是 in-place 操作）。<br>时间复杂度 o(n), 空间复杂度 o(1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[i<span class="number">-1</span>]:</span><br><span class="line">            nums[j] = nums[i]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>

<h3 id="Remove-Duplicates-from-Sorted-Array-II"><a href="#Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="Remove Duplicates from Sorted Array II"></a>Remove Duplicates from Sorted Array II</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/" target="_blank" rel="noopener">Leetcode : 80. Remove Duplicates from Sorted Array II (Medium)</a></p>
<p>思路: 计算数字出现的次数，当次数为 1 或 2 时，就把其加到新数组中。 要注意的是题中需要 in-place 操作，因此直接覆盖 nums 即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">1</span> <span class="keyword">or</span> count == <span class="number">2</span>:</span><br><span class="line">            nums[j] = nums[i]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>

<h3 id="Remove-Element"><a href="#Remove-Element" class="headerlink" title="Remove Element"></a>Remove Element</h3><p><a href="https://leetcode.com/problems/remove-element/description/" target="_blank" rel="noopener">Leetcode : 27. Remove Element(Easy)</a></p>
<p>思路：与上一题相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(nums, val)</span>:</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">            nums[j] = nums[i]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>

<h3 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a>Next Permutation</h3><p><a href="https://leetcode.com/problems/next-permutation/description/" target="_blank" rel="noopener">Leetcode : 31. Next Permutation (Medium)</a></p>
<p>思路：</p>
<ol>
<li>从后往前扫描，寻找两个相邻的升序元素，nums[i] &lt; nums[i+1]；</li>
<li>从后往前扫描，找到第一个比 nums[i] 更大的元素， nums[j]；</li>
<li>交换 nums[i] 和 nums[j]，并对 i 之后的元素进行升序排列。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>, i, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[i]:</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                    nums[i+<span class="number">1</span>:] = sorted(nums[i+<span class="number">1</span>:])</span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">        nums.sort() <span class="comment"># nums[:] = sorted(nums[:])</span></span><br></pre></td></tr></table></figure>

<h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><p><a href="https://leetcode.com/problems/merge-intervals/description/" target="_blank" rel="noopener">Leetcode : 56. Merge Intervals (Medium)</a></p>
<p>思路：首先对 intervals 进行排序，然后选 i=0 的数的 start 和 end 作为比较基准，当下一个数的 start 小于前一个数的 end 时，则表明两个 inteval 可以合并，并将新的 end 置为两者之间的较大者。 当不能合并时，就前一个数添加到 res 中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">    :rtype: List[Interval]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(intervals) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> intervals</span><br><span class="line">    res = []</span><br><span class="line">    intervals = sorted(intervals, key=<span class="keyword">lambda</span> x: (x.start, x.end))</span><br><span class="line">    left = intervals[<span class="number">0</span>].start</span><br><span class="line">    right = intervals[<span class="number">0</span>].end</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(intervals)):</span><br><span class="line">        <span class="keyword">if</span> right &gt;= intervals[i].start:</span><br><span class="line">            right = max(right, intervals[i].end)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            interval = Interval(left, right)</span><br><span class="line">            res.append(interval)</span><br><span class="line">            left = intervals[i].start</span><br><span class="line">            right = intervals[i].end</span><br><span class="line">    interval = Interval(left, right)</span><br><span class="line">    res.append(interval)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a>Insert Interval</h3><p><a href="https://leetcode.com/problems/insert-interval/description/" target="_blank" rel="noopener">Leetcode : 57. Insert Interval (Hard)</a></p>
<p>将 newInterval 插入到 intervals 中，再复用上一题的代码即可，但效率不高。</p>
<h3 id="归并两个有序数组-Merge-Sorted-Array"><a href="#归并两个有序数组-Merge-Sorted-Array" class="headerlink" title="归并两个有序数组 Merge Sorted Array"></a>归并两个有序数组 Merge Sorted Array</h3><p><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">Leetcode : 88. Merge Sorted Array (Easy)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> nums1[m<span class="number">-1</span>] &gt;= nums2[n<span class="number">-1</span>]:</span><br><span class="line">            nums1[m+n<span class="number">-1</span>] = nums1[m<span class="number">-1</span>]</span><br><span class="line">            m -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums1[m+n<span class="number">-1</span>] = nums2[n<span class="number">-1</span>]</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure>

<p>投机做法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums1, m, nums2, n)</span>:</span></span><br><span class="line">    nums1[m:] = nums2[:n]</span><br><span class="line">    nums1.sort()</span><br></pre></td></tr></table></figure>

<h3 id="Pascal’s-Triangle"><a href="#Pascal’s-Triangle" class="headerlink" title="Pascal’s Triangle"></a>Pascal’s Triangle</h3><p><a href="https://leetcode.com/problems/pascals-triangle/description/" target="_blank" rel="noopener">Leetcode : 118. Pascal’s Triangle (Easy)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</span><br><span class="line">        <span class="keyword">if</span> i &lt;= <span class="number">1</span>:</span><br><span class="line">            res.append([<span class="number">1</span>]*(i+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            row = [<span class="number">1</span>] + [<span class="number">0</span>] * (i<span class="number">-1</span>) + [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">                row[j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>] + res[i<span class="number">-1</span>][j]</span><br><span class="line">            res.append(row)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="Pascal’s-Triangle-II"><a href="#Pascal’s-Triangle-II" class="headerlink" title="Pascal’s Triangle II"></a>Pascal’s Triangle II</h3><p><a href="https://leetcode.com/problems/pascals-triangle-ii/description/" target="_blank" rel="noopener">Leetcode : 119. Pascal’s Triangle II (Easy)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(rowIndex+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt;= <span class="number">1</span>:</span><br><span class="line">            res = [<span class="number">1</span>] * (i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>):</span><br><span class="line">                tmp.append(res[j] + res[j+<span class="number">1</span>])</span><br><span class="line">            res = [<span class="number">1</span>] + tmp + [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="旋转数组-Rotate-Array"><a href="#旋转数组-Rotate-Array" class="headerlink" title="旋转数组 Rotate Array"></a>旋转数组 Rotate Array</h3><p><a href="https://leetcode.com/problems/rotate-array/description/" target="_blank" rel="noopener">Leetcode : 189. Rotate Array(Easy)</a></p>
<p>思路: 要注意 k 可能会比 len(nums) 更大，因此先要取余数，除尽的部分相当于 nums 没改变<br>要求原地操作，切片是一个原地操作<br>时间复杂度 o(n)， 空间复杂度 o(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = k % len(nums)</span><br><span class="line">        nums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]</span><br></pre></td></tr></table></figure>

<p>要求时间复杂度 O(1)，对于 [1,2,3,4,5,6,7], k=3<br>[1,2,3,4] -&gt; [4,3,2,1]; [5,6,7] -&gt; [7,6,5]; [4,3,2,1,7,6,5] -&gt; [5,6,7,1,2,3,4]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        k = k % len(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, n-k<span class="number">-1</span>) <span class="comment"># 必须要传入 nums，如果传入切片无法修改 nums</span></span><br><span class="line">        self.reverse(nums, n-k, n<span class="number">-1</span>)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Contains-Duplicate"><a href="#Contains-Duplicate" class="headerlink" title="Contains Duplicate"></a>Contains Duplicate</h3><p><a href="https://leetcode.com/problems/contains-duplicate/description/" target="_blank" rel="noopener">Leetcode : 217. Contains Duplicate (Easy)</a></p>
<p>若直接暴力解决，遍历数组，用 arr 存储遍历过的值，若后面出现过相同的数，则返回 True，该方法会超时。</p>
<p>思路一：将 nums 转为 set，这样 set 中都是不重复的数字，若 set 与 nums 长度不同，则说明有重复数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    s = set(nums)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> len(s) != len(nums) <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>思路二： 先将 nums 排序，再判断前后是否有相同数字即可。</p>
<h3 id="Contains-Duplicate-II"><a href="#Contains-Duplicate-II" class="headerlink" title="Contains Duplicate II"></a>Contains Duplicate II</h3><p><a href="https://leetcode.com/problems/contains-duplicate-ii/description/" target="_blank" rel="noopener">Leetcode : 219. Contains Duplicate II (Easy)</a></p>
<p>思路： 利用字典来存储某个元素上一次出现的位置，当再次出现该元素时，计算两个重复元素之间的距离是否 &lt;= k，是的话就 return True</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">            j = dic[nums[i]]</span><br><span class="line">            <span class="keyword">if</span> i - j &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        dic[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="Contains-Duplicate-III"><a href="#Contains-Duplicate-III" class="headerlink" title="Contains Duplicate III"></a>Contains Duplicate III</h3><p><a href="https://leetcode.com/problems/contains-duplicate-iii/description/" target="_blank" rel="noopener">Leetcode : 220. Contains Duplicate III (Medium)</a></p>
<h3 id="Majority-Element"><a href="#Majority-Element" class="headerlink" title="Majority Element"></a>Majority Element</h3><p><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">Leetcode : 169. Majority Element (Easy)</a></p>
<p>摩尔投票法：快速的计算出一个数组中出现次数过半的数，应用同加异减的思想。设置一个计数器，在遍历数组的时候，如果是这个数，则计数器加 1，否则减 1，当计数器为 0 时，则重置 major 和 cnt。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    major = nums[<span class="number">0</span>]</span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == major:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i] != major:</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">            major = nums[i]</span><br><span class="line">            cnt = <span class="number">1</span>        </span><br><span class="line">    <span class="keyword">return</span> major</span><br></pre></td></tr></table></figure>

<h3 id="Majority-Element-II"><a href="#Majority-Element-II" class="headerlink" title="Majority Element II"></a>Majority Element II</h3><p><a href="https://leetcode.com/problems/majority-element-ii/description/" target="_blank" rel="noopener">Leetcode : 229. Majority Element II (Medium)</a></p>
<p>要求时间复杂度为 O(n)， 空间复杂度为 O(1)</p>
<p>出现次数超过 1/3 数组长的数，最多只有两个。改进摩尔投票法，设置两个计数器，和两个候选数字：</p>
<ol>
<li>若是两个候选数字之一，则将对应的计数器加一；</li>
<li>不是两个候选数字任意一个，则两个计数器都减一；</li>
<li>若某个计数器为 0， 则重置计数器和候选数字；</li>
<li>最后得到两个候选数字，还需要检查出现的次数是否都超过了 1/3。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="comment"># if len(nums) &lt;= 1:</span></span><br><span class="line">    <span class="comment">#     return nums</span></span><br><span class="line">    cnt1, cnt2, can1, can2 = <span class="number">0</span>, <span class="number">0</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num == can1:</span><br><span class="line">            cnt1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> num == can2:</span><br><span class="line">            cnt2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> cnt1 == <span class="number">0</span>:</span><br><span class="line">            can1, cnt1 = num, <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> cnt2 == <span class="number">0</span>:</span><br><span class="line">            can2, cnt2 = num, <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cnt1 -= <span class="number">1</span></span><br><span class="line">            cnt2 -= <span class="number">1</span></span><br><span class="line">    res = [n <span class="keyword">for</span> n <span class="keyword">in</span> (can1, can2) <span class="keyword">if</span> nums.count(n) &gt; len(nums)//<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a>Product of Array Except Self</h3><p><a href="https://leetcode.com/problems/product-of-array-except-self/description/" target="_blank" rel="noopener">Leetcode : 238. Product of Array Except Self (Medium)</a></p>
<p>要求时间复杂度为 O(n)，并且不能使用除法。</p>
<p>思路： 先从左往右计算一次，再从右往左计算一次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    product = [<span class="number">1</span>] * n</span><br><span class="line">    tmp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        product[i] = tmp</span><br><span class="line">        tmp *= nums[i]</span><br><span class="line">    tmp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        product[i] *= tmp</span><br><span class="line">        tmp *= nums[i]</span><br><span class="line">    <span class="keyword">return</span> product</span><br></pre></td></tr></table></figure>

<h3 id="Move-Zeroes"><a href="#Move-Zeroes" class="headerlink" title="Move Zeroes"></a>Move Zeroes</h3><p><a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">Leetcode : 283. Move Zeroes (Medium)</a></p>
<p>问题描述：题目要求 in-place 操作，即<strong>原位操作</strong>，不允许移动和使用临时变量，也就是要原地覆盖掉之前的值。<br>对于本题：只要遇到该数不等于 0，则直接从第一个数开始覆盖掉，遍历完一遍后，前面的数都是不为 0 的，再把后面的数全部填充为 0 即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> x != <span class="number">0</span>:</span><br><span class="line">            nums[i] = x</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="Valid-Sudoku"><a href="#Valid-Sudoku" class="headerlink" title="Valid Sudoku"></a>Valid Sudoku</h3><p><a href="https://leetcode.com/problems/valid-sudoku/description/" target="_blank" rel="noopener">Leetcode : 36. Valid Sudoku (Medium)</a></p>
<p>验证数独板是否有效，每一行每一列，每个九宫格内都只能是 1-9 的数字，且不能重复。</p>
<p>思路：直接将每一行、每一列和每个九宫格进行验证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            row = board[i]</span><br><span class="line">            col = [r[i] <span class="keyword">for</span> r <span class="keyword">in</span> board]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.valid(row) <span class="keyword">or</span> <span class="keyword">not</span> self.valid(col):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]:</span><br><span class="line">                nine = [board[row][col] <span class="keyword">for</span> row <span class="keyword">in</span> [i, i+<span class="number">1</span>, i+<span class="number">2</span>] <span class="keyword">for</span> col <span class="keyword">in</span> [j, j+<span class="number">1</span>, j+<span class="number">2</span>]]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.valid(nine):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> char.isdigit():</span><br><span class="line">                <span class="keyword">if</span> char <span class="keyword">in</span> dic:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic[char] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="旋转图像-Rotate-Image"><a href="#旋转图像-Rotate-Image" class="headerlink" title="旋转图像 Rotate Image"></a>旋转图像 Rotate Image</h3><p><a href="https://leetcode.com/problems/rotate-image/description/" target="_blank" rel="noopener">Leetcode : 48. Rotate Image (Medium)</a></p>
<p>矩阵的翻转方式有： 左右翻转、上下翻转、左上到右下的对角线（转置）翻转。</p>
<p>将矩阵翻转 90 度，相当于先转置数组，再左右翻转数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">    n = len(matrix)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n//<span class="number">2</span>):</span><br><span class="line">            matrix[i][j], matrix[i][n-j<span class="number">-1</span>] = matrix[i][n-j<span class="number">-1</span>], matrix[i][j]</span><br></pre></td></tr></table></figure>

<h3 id="螺旋矩阵-Spiral-Matrix"><a href="#螺旋矩阵-Spiral-Matrix" class="headerlink" title="螺旋矩阵 Spiral Matrix"></a>螺旋矩阵 Spiral Matrix</h3><p><a href="https://leetcode.com/problems/spiral-matrix/description/" target="_blank" rel="noopener">Leetcode : 54. Spiral Matrix(Medium)</a></p>
<p>思路：向右，向下，向左，向上，四个方向遍历输出，但要注意终止条件，输出数组的大小等于矩阵所有元素数量则终止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    up = <span class="number">0</span></span><br><span class="line">    down = len(matrix) - <span class="number">1</span></span><br><span class="line">    size = (right+<span class="number">1</span>) * (down+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> len(res)&lt; size:</span><br><span class="line">                res.append(matrix[up][i])</span><br><span class="line">        up += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(up, down+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> len(res)&lt; size:</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(right, left<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> len(res)&lt; size:</span><br><span class="line">                res.append(matrix[down][i])</span><br><span class="line">        down -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(down, up<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> len(res)&lt; size:</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="螺旋矩阵-Spiral-Matrix-II"><a href="#螺旋矩阵-Spiral-Matrix-II" class="headerlink" title="螺旋矩阵 Spiral Matrix II"></a>螺旋矩阵 Spiral Matrix II</h3><p><a href="https://leetcode.com/problems/spiral-matrix-ii/description/" target="_blank" rel="noopener">Leetcode : 59. Spiral Matrix II(Medium)</a></p>
<p>备注： 需要注意矩阵初始化的格式，可以用 matrix = [[0] * n for i in range(0, n)] 或 matrix = [[0 for col in range(n)] for row in range(n)]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    matrix = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(n)] <span class="keyword">for</span> row <span class="keyword">in</span> range(n)]</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = n<span class="number">-1</span></span><br><span class="line">    up = <span class="number">0</span></span><br><span class="line">    down = n<span class="number">-1</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= n*n:</span><br><span class="line">                matrix[up][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">        up += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(up, down+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= n*n:</span><br><span class="line">                matrix[i][right] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(right, left<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= n*n:</span><br><span class="line">                matrix[down][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">        down -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(down, up<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= n*n:</span><br><span class="line">                matrix[i][left] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure>

<h3 id="Set-Matrix-Zeroes"><a href="#Set-Matrix-Zeroes" class="headerlink" title="Set Matrix Zeroes"></a>Set Matrix Zeroes</h3><p><a href="https://leetcode.com/problems/set-matrix-zeroes/description/" target="_blank" rel="noopener">Leetocde : 73. Set Matrix Zeroes (Medium)</a></p>
<p>暴力法：两次遍历，第一次遍历存储需要置零的行和列，第二次遍历置零。此法时间复杂度为 O(n * m) , 空间复杂度为 O(n+m)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        rows = []</span><br><span class="line">        cols = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    rows.append(i)</span><br><span class="line">                    cols.append(j)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> rows <span class="keyword">or</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>想要空间复杂度为 O(1)， 可以将需要置零的行号和列号记录在 第一列 和 第一行，但这会使第一行和第一列的原始元素丢失，因此只需要设置一个额外的变量来保存第一行或第一列是否需要置零。在更新 matrix 的时候，从下往上遍历，则不会破坏第一行或第一列的原始数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">    m = len(matrix)</span><br><span class="line">    n = len(matrix[<span class="number">0</span>])</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            flag = <span class="number">1</span> <span class="comment"># 说明第 0 列中是有 0 的</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>): <span class="comment"># 第 0 列额外判断</span></span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>         </span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="有序矩阵的第k小元素-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#有序矩阵的第k小元素-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="有序矩阵的第k小元素 Kth Smallest Element in a Sorted Matrix"></a>有序矩阵的第k小元素 Kth Smallest Element in a Sorted Matrix</h3><p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="noopener">Leetcode : 378. Kth Smallest Element in a Sorted Matrix ((Medium))</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">return 13.</span><br></pre></td></tr></table></figure>

<p>思路：对于该有序矩阵，左上角元素最小，右下角元素最大，因此矩阵中的数一定处于这两者之间，可以用这两个数来做一个 range，二分查找出 kth Smallest。<br>对于数 mid，找到 matrix 中有多少个数小于 mid，然后与 k 进行比较，从而更新二分查找的上下界。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix, k)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    low = matrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    high = matrix[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high - <span class="number">1</span>):  <span class="comment">#1</span></span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">        cnt = self.count_num(matrix, mid)</span><br><span class="line">        <span class="keyword">if</span> cnt &lt; k:</span><br><span class="line">            low = mid  <span class="comment">#2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid</span><br><span class="line">    <span class="keyword">return</span> low <span class="keyword">if</span> self.count_num(matrix, low) &gt;= k <span class="keyword">else</span> high</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_num</span><span class="params">(self, matrix, mid)</span>:</span></span><br><span class="line">    n = len(matrix)</span><br><span class="line">    row = <span class="number">0</span></span><br><span class="line">    col = n - <span class="number">1</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(row &lt; n <span class="keyword">and</span> col &gt;= <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">if</span> matrix[row][col] &lt;= mid:</span><br><span class="line">            cnt = cnt + col + <span class="number">1</span></span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            col -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<ol>
<li>注意边界条件是 low &lt; high - 1，最后有两个备选项。若是 low &lt;= high，那么可能会出现死循环，因为前一个数字 low 的计数永远小于 cnt，low 就不会更新。</li>
<li>注意此处 low = mid 和 high = mid</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>单链表</strong>的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><p>快慢指针中的快慢指的是移动的步长，即每次向前移动速度的快慢。例如可以让快指针每次沿链表向前移动 2，慢指针每次向前移动 1 次。  </p>
<p><strong>应用一</strong>：判断环形链表<br>让快慢指针从链表头开始遍历，快指针向前移动两个位置，慢指针向前移动一个位置;如果快指针到达 NULL，说明链表以 NULL 为结尾，不是循环链表。如果 快指针追上慢指针，则表示出现了循环。  </p>
<p><strong>应用二</strong>：在有序链表中寻找中位数<br>该方法在不借助计数器变量实现寻找中位数的功能。原理是：快指针的移动速度是慢指针移动速度的 2 倍，因此当快指针到达链表尾时，慢指针到达中点。程序还要考虑链表结点个数的奇偶数因素，当快指针移动 x 次后到达表尾（1+2x），说明链表有奇数个结点，直接返回慢指针指向的数据即可。如果快指针是倒数第二个结点，说明链表结点个数是偶数，这时可以根据“规则”返回上中位数或下中位数或（上中位数+下中位数）的一半。</p>
<h3 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a>Add Two Numbers</h3><p><a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">Leetcode : 2. Add Two Numbers(Medium)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        num1 = num2 = <span class="number">0</span></span><br><span class="line">        tens = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                num1 = num1 + l1.val * tens</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                num2 = num2 + l2.val * tens</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            tens = tens * <span class="number">10</span></span><br><span class="line">      </span><br><span class="line">        sum = num1 + num2</span><br><span class="line">        </span><br><span class="line">        p = head = ListNode(sum%<span class="number">10</span>)</span><br><span class="line">        sum = sum // <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> sum:</span><br><span class="line">            node = ListNode(sum%<span class="number">10</span>)</span><br><span class="line">            p.next = node</span><br><span class="line">            p = node</span><br><span class="line">            sum = sum // <span class="number">10</span>            </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h3 id="Remove-Nth-Node-From-End-of-List"><a href="#Remove-Nth-Node-From-End-of-List" class="headerlink" title="Remove Nth Node From End of List"></a>Remove Nth Node From End of List</h3><p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">Leetcode : 19. Remove Nth Node From End of List (Medium)</a></p>
<p>思路： 由于可能会改变链表表头，因此添加一个辅助节点 dummy。然后用两个指针，fast 先走 n 步，然后 slow 再和 fast 同步走，当 fast 走到终点时，slow 位于要删除的节点的前面。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    dummy.next = head</span><br><span class="line">    fast = head</span><br><span class="line">    slow = dummy <span class="comment"># 此处需要注意，slow不能是head，因为head有可能要被删除。</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">while</span> fast: </span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next</span><br><span class="line">    slow.next = slow.next.next</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="归并两个有序链表-Merge-Two-Sorted-Lists"><a href="#归并两个有序链表-Merge-Two-Sorted-Lists" class="headerlink" title="归并两个有序链表 Merge Two Sorted Lists"></a>归并两个有序链表 Merge Two Sorted Lists</h3><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">Leetcode : 21. Merge Two Sorted Lists (Easy)</a></p>
<p>思路：链表与树类似，可以用递归方式来定义，这与归并两颗二叉树类似。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val):</span><br><span class="line">            p = l1</span><br><span class="line">            p.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = l2</span><br><span class="line">            p.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h3 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h3><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">Leetcode : 24. Swap Nodes in Pairs (Medium)</a></p>
<p>思路： 由于每次要交换相邻节点，因此可以两个节点作为一个单位进行处理。 用 cur 记录当前节点，pre 记录上一个节点，然后进行交换操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    dummy = pre = ListNode(<span class="number">0</span>)</span><br><span class="line">    dummy.next = head.next</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = tmp.next</span><br><span class="line">        tmp.next = cur</span><br><span class="line">        pre.next = tmp</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = cur.next</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="旋转链表-Rotate-List"><a href="#旋转链表-Rotate-List" class="headerlink" title="旋转链表 Rotate List"></a>旋转链表 Rotate List</h3><p><a href="https://leetcode.com/problems/rotate-list/description/" target="_blank" rel="noopener">Leetcode : 61. Rotate List (Medium)</a></p>
<p>思路： 先计算链表的长度，用 k%size 得到 rotate 的节点的数量，即 rotate 后面 k%size 个节点到前面去。<br>因此，用双指针， fast 先走 k 步，之后 slow 和 fast 同步，这时候 fast 已经走到最后，则将其指向 head，而此时 slow.next 是翻转之后的 head，并且要将 slow.next 置为 None，否则一直无法停止。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    node = head</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        size += <span class="number">1</span> <span class="comment"># 链表的长度</span></span><br><span class="line">        node = node.next</span><br><span class="line">    k = k % size <span class="comment"># 将后面 k 个数 rotate 到前面</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    slow, fast = head, head</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">while</span> fast.next:</span><br><span class="line">        fast = fast.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">    fast.next = head</span><br><span class="line">    head = slow.next </span><br><span class="line">    slow.next = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h3 id="删除有序链表的重复节点-Remove-Duplicates-from-Sorted-List"><a href="#删除有序链表的重复节点-Remove-Duplicates-from-Sorted-List" class="headerlink" title="删除有序链表的重复节点 Remove Duplicates from Sorted List"></a>删除有序链表的重复节点 Remove Duplicates from Sorted List</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="noopener">Leetcode : 83. Remove Duplicates from Sorted List (Easy)</a></p>
<p>思路：由于链表是有序链表，则重复元素必定相邻</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        cur = head.next</span><br><span class="line">        pre = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> pre.val == cur.val:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = cur</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = pre.next</span><br><span class="line">        pre.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>

<h3 id="删除有序链表的重复节点II"><a href="#删除有序链表的重复节点II" class="headerlink" title="删除有序链表的重复节点II"></a>删除有序链表的重复节点II</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/" target="_blank" rel="noopener">Leetcode : 82. Remove Duplicates from Sorted List II (Medium)</a></p>
<p>思路：一般情况下，需要修改链表表头时，会用到辅助指针，即此处在表头添加一个节点 dummy。<br>使用 is_repeated 来标记是否有重复的节点，当存在重复节点时，则将 pre 指针指向 cur.next，这样就过滤掉了所有的重复节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line"></span><br><span class="line">        pre = dummy</span><br><span class="line">        cur = dummy.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            is_repeated = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> pre.next.val == cur.next.val:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                is_repeated = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> is_repeated:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = pre.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a>Partition List</h3><p><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">Leetcode : 86. Partition List (Medium)</a></p>
<p>思路： 用到两个额外的链表，遍历一个原始链表，将比 x 小的节点构建 p1，比 x 大的节点构建 p2，这样能保证节点的相对位置不发生改变。 然后将两个链表相连。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head, x)</span>:</span></span><br><span class="line">    dummy1, dummy2 = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>)</span><br><span class="line">    p1, p2 = dummy1, dummy2</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">            p1.next = head</span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p2.next = head</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        head = head.next</span><br><span class="line">    p2.next = <span class="literal">None</span></span><br><span class="line">    p1.next = dummy2.next</span><br><span class="line">    <span class="keyword">return</span> dummy1.next</span><br></pre></td></tr></table></figure>

<h3 id="反转链表-Reverse-Linked-List"><a href="#反转链表-Reverse-Linked-List" class="headerlink" title="反转链表 Reverse Linked List"></a>反转链表 Reverse Linked List</h3><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="noopener">Leetcode : 92. Reverse Linked List II (Medium)</a></p>
<p>思路：将链表分成三部分，前面一部分，需要反转的部分，以及最后面一部分。需要注意的是当 m = 1 的时候，没有第一部分，因此需要额外进行讨论。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next <span class="keyword">or</span> m == n:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        cur = head</span><br><span class="line">        end = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">            end = cur</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        rend = end <span class="keyword">if</span> m == <span class="number">1</span> <span class="keyword">else</span> cur</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n-m+<span class="number">1</span>):</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> m != <span class="number">1</span>:</span><br><span class="line">            end.next = pre            </span><br><span class="line">        rend.next = cur </span><br><span class="line">        <span class="keyword">return</span> head <span class="keyword">if</span> m != <span class="number">1</span> <span class="keyword">else</span> pre</span><br></pre></td></tr></table></figure>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">Leetcode : 206. Reverse Linked List (Easy)</a></p>
<p>思路：采用循环方式，遍历一遍链表，并将当前元素的指针指向前一个元素，要注意的是必须先使用中间变量保存当前元素的下一个元素，否则在下一次循环时 cur.next 会是前一个元素，会造成死循环。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h3 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a>Copy List with Random Pointer</h3><p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/description/" target="_blank" rel="noopener">Leetcode : 138. Copy List with Random Pointer (Medium)</a></p>
<p>思路：</p>
<ol>
<li>在原链表的每个节点后面都插入一个新节点，新节点的 label 与原节点一样</li>
<li>用 tmp 指向原节点，则新节点指向的 random 为 tmp.next.random = tmp.random.next</li>
<li>将新链表从下图的链表中拆分出来</li>
</ol>
<div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1552209599/138.jpg"></div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    tmp = head</span><br><span class="line">    <span class="keyword">while</span> tmp:</span><br><span class="line">        new_node = RandomListNode(tmp.label)</span><br><span class="line">        new_node.next = tmp.next</span><br><span class="line">        tmp.next = new_node</span><br><span class="line">        tmp = tmp.next.next</span><br><span class="line">    tmp = head</span><br><span class="line">    <span class="keyword">while</span> tmp:</span><br><span class="line">        <span class="keyword">if</span> tmp.random:</span><br><span class="line">            tmp.next.random = tmp.random.next</span><br><span class="line">        tmp = tmp.next.next</span><br><span class="line">    </span><br><span class="line">    new_head = head.next</span><br><span class="line">    pold = head</span><br><span class="line">    pnew = new_head</span><br><span class="line">    <span class="keyword">while</span> pnew.next:</span><br><span class="line">        pold.next = pnew.next</span><br><span class="line">        pnew.next = pnew.next.next</span><br><span class="line">        pold = pold.next</span><br><span class="line">        pnew = pnew.next</span><br><span class="line">    pold.next = <span class="literal">None</span></span><br><span class="line">    pnew.next = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>

<h3 id="环形链表-Linked-List-Cycle"><a href="#环形链表-Linked-List-Cycle" class="headerlink" title="环形链表 Linked List Cycle"></a>环形链表 Linked List Cycle</h3><p><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">Leetcode : 141. Linked List Cycle (Easy)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="Linked-List-Cycle-II"><a href="#Linked-List-Cycle-II" class="headerlink" title="Linked List Cycle II"></a>Linked List Cycle II</h3><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">Leetcode : 142. Linked List Cycle II (Medium)</a></p>
<p>问题描述： 如果链表存在环路，那么返回环路的起始节点。</p>
<p>思路: 利用快慢指针法来判断是否存在环路，假设两个指针 slow 和 fast 的路径如下图，在 Z 点相遇。</p>
<div><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1552209599/142.png"></div>
此时，fast 走过的路径为：a+b+c+b； slow 走过的路径为：a+b。  
由于 fast 速度比 slow 快两倍，因此有： 2*(a+b) = a+b+c+b，则 a=c。  
因此，当两个指针相遇后，令 slow 回到 head，fast 不变，然后两个指针同速度开始走，一次走一步，则两个指针会在 Y 点 相遇，也就是环路的起始节点。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    slow = fast = head</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span> slow == fast:</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span> <span class="comment"># 必须要break，否则死循环</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag: <span class="comment"># 不是环形就返回None，提高效率。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">    </span><br><span class="line">    slow = head</span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h3 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a>Reorder List</h3><p><a href="https://leetcode.com/problems/reorder-list/description/" target="_blank" rel="noopener">Leetcode : 143. Reorder List (Medium)</a></p>
<p>思路： 将链表拆分为两个链表；再将第二个链表 reverse；最后交叉归并两个链表。<br>用快慢指针法找到需要拆分的地方。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next <span class="keyword">or</span> <span class="keyword">not</span> head.next.next:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="comment"># 快慢指针法拆分链表</span></span><br><span class="line">    slow = fast = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">    head1 = head</span><br><span class="line">    head2 = slow.next</span><br><span class="line">    slow.next = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 反转链表</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head2</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    head2 = pre</span><br><span class="line">    <span class="comment"># 将第二个链表插入到第一个链表中</span></span><br><span class="line">    p1 = head1</span><br><span class="line">    p2 = head2</span><br><span class="line">    <span class="keyword">while</span> p2:</span><br><span class="line">        tmp1 = p1.next</span><br><span class="line">        p1.next = p2</span><br><span class="line">        tmp2 = p2.next</span><br><span class="line">        p2.next = tmp1</span><br><span class="line">        p1 = tmp1</span><br><span class="line">        p2 = tmp2</span><br></pre></td></tr></table></figure>

<h3 id="两个链表的交点-Intersection-of-Two-Linked-Lists"><a href="#两个链表的交点-Intersection-of-Two-Linked-Lists" class="headerlink" title="两个链表的交点 Intersection of Two Linked Lists"></a>两个链表的交点 Intersection of Two Linked Lists</h3><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">Leetcode : 160. Intersection of Two Linked Lists (Easy)</a></p>
<p>思路：对于链表 A 和 B，相交于公共部分 C，设两个链表的公共部分长度为 c，那么 A 的长度为 a + c，B 的长度为 b + c，那么有 a + c + b = b + c +a。  </p>
<p>当链表 A 访问到尾部时，则从链表 B 的头部开始访问 B；<br>当链表 B 访问到尾部时，则从链表 A 的头部开始访问 A。<br>这样可以控制访问 A 和 B 的指针同时访问到交点，若 A 和 B 没有交点，则两个指针同时为空，返回 None</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        p = headA</span><br><span class="line">        q = headB</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p != q:</span><br><span class="line">            p = p.next <span class="keyword">if</span> p <span class="keyword">else</span> headB</span><br><span class="line">            q = q.next <span class="keyword">if</span> q <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>

<h3 id="回文链表-Palindrome-Linked-List"><a href="#回文链表-Palindrome-Linked-List" class="headerlink" title="回文链表 Palindrome Linked List"></a>回文链表 Palindrome Linked List</h3><p><a href="https://leetcode.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">Leetcode : 234. Palindrome Linked List (Easy)</a></p>
<p>方法一：<br>将链表的值存到数组中，然后再判断是否为回文数组。<br>时间复杂度 o(n), 空间复杂度 o(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] != arr[len(arr)<span class="number">-1</span>-i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>方法二：<br>将后半段链表反转，再与前半段进行比较从而判断。<br>时间复杂度 o(n), 空间复杂度 o(1)  </p>
<p>利用<strong>快慢指针法</strong>找到单链表的中点，注意边界条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        fast = slow = head</span><br><span class="line">        rhead = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        </span><br><span class="line">        rhead = self.reverseList(slow.next)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> rhead:</span><br><span class="line">            <span class="keyword">if</span> rhead.val != head.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            rhead = rhead.next</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        cur = head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h3 id="Delete-Node-in-a-Linked-List"><a href="#Delete-Node-in-a-Linked-List" class="headerlink" title="Delete Node in a Linked List"></a>Delete Node in a Linked List</h3><p><a href="#https://leetcode.com/problems/delete-node-in-a-linked-list/description/">Leetcode : 237. Delete Node in a Linked List (Easy)</a></p>
<p>本题需要删除链表中的一个节点 node，一般删除一个节点会通过保留上一个节点来操作，但该题中只给了当前节点，因此可以将下一个节点的值赋给当前节点，然后将当前节点指向下下个节点，这样就相当于删除了当前节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    node.val = node.next.val</span><br><span class="line">    node.next = node.next.next</span><br></pre></td></tr></table></figure>

<h3 id="奇偶链表-Odd-Even-Linked-List"><a href="#奇偶链表-Odd-Even-Linked-List" class="headerlink" title="奇偶链表 Odd Even Linked List"></a>奇偶链表 Odd Even Linked List</h3><p><a href="https://leetcode.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener">Leetcode : 328. Odd Even Linked List (Medium)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        even_head = head.next</span><br><span class="line">        odd = head</span><br><span class="line">        even = even_head</span><br><span class="line">        <span class="keyword">while</span> even <span class="keyword">and</span> even.next:</span><br><span class="line">            odd.next = odd.next.next</span><br><span class="line">            odd = odd.next</span><br><span class="line">            even.next = even.next.next</span><br><span class="line">            even = even.next</span><br><span class="line">        odd.next = even_head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>



      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          
            <a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="tag"># 哈希表</a>
          
            <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          
            <a href="/tags/%E6%A0%88/" rel="tag"># 栈</a>
          
            <a href="/tags/%E9%98%9F%E5%88%97/" rel="tag"># 队列</a>
          
            <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag"># 二叉树</a>
          
            <a href="/tags/%E6%95%B0%E7%BB%84/" rel="tag"># 数组</a>
          
            <a href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag"># 链表</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/04/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2/" rel="next" title="leetcode 搜索算法">
                <i class="fa fa-chevron-left"></i> leetcode 搜索算法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/25/Python-%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/" rel="prev" title="Python 编码总结">
                Python 编码总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Cactus" />
          <p class="site-author-name" itemprop="name">Cactus</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xieyiyu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/cactus4869" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈与队列"><span class="nav-number">1.</span> <span class="nav-text">栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用栈实现括号匹配"><span class="nav-number">1.1.</span> <span class="nav-text">用栈实现括号匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Evaluate-Reverse-Polish-Notation"><span class="nav-number">1.2.</span> <span class="nav-text">Evaluate Reverse Polish Notation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小值栈"><span class="nav-number">1.3.</span> <span class="nav-text">最小值栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用栈实现队列"><span class="nav-number">1.4.</span> <span class="nav-text">用栈实现队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用队列实现栈"><span class="nav-number">1.5.</span> <span class="nav-text">用队列实现栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表"><span class="nav-number">2.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#两数之和-Two-Sum"><span class="nav-number">2.1.</span> <span class="nav-text">两数之和 Two Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无重复字符的最长子串-Longest-Substring-Without-Repeating-Characters"><span class="nav-number">2.2.</span> <span class="nav-text">无重复字符的最长子串 Longest Substring Without Repeating Characters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Single-Number"><span class="nav-number">2.3.</span> <span class="nav-text">Single Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Repeated-DNA-Sequences"><span class="nav-number">2.4.</span> <span class="nav-text">Repeated DNA Sequences</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同构字符串-Isomorphic-Strings"><span class="nav-number">2.5.</span> <span class="nav-text">同构字符串 Isomorphic Strings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长和谐序列-Longest-Harmonious-Subsequence"><span class="nav-number">2.6.</span> <span class="nav-text">最长和谐序列 Longest Harmonious Subsequence</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树"><span class="nav-number">3.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">3.1.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相同树"><span class="nav-number">3.1.1.</span> <span class="nav-text">相同树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对称树"><span class="nav-number">3.1.2.</span> <span class="nav-text">对称树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的高度"><span class="nav-number">3.1.3.</span> <span class="nav-text">二叉树的高度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#平衡二叉树"><span class="nav-number">3.1.4.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的最小高度"><span class="nav-number">3.1.5.</span> <span class="nav-text">二叉树的最小高度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路径和"><span class="nav-number">3.1.6.</span> <span class="nav-text">路径和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Path-Sum-II"><span class="nav-number">3.1.7.</span> <span class="nav-text">Path Sum II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Populating-Next-Right-Pointers-in-Each-Node"><span class="nav-number">3.1.8.</span> <span class="nav-text">Populating Next Right Pointers in Each Node</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Populating-Next-Right-Pointers-in-Each-Node-II"><span class="nav-number">3.1.9.</span> <span class="nav-text">Populating Next Right Pointers in Each Node II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sum-Root-to-Leaf-Numbers"><span class="nav-number">3.1.10.</span> <span class="nav-text">Sum Root to Leaf Numbers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反转二叉树"><span class="nav-number">3.1.11.</span> <span class="nav-text">反转二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归并二叉树"><span class="nav-number">3.1.12.</span> <span class="nav-text">归并二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遍历"><span class="nav-number">3.2.</span> <span class="nav-text">遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#前序遍历"><span class="nav-number">3.2.1.</span> <span class="nav-text">前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中序遍历"><span class="nav-number">3.2.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#后序遍历"><span class="nav-number">3.2.3.</span> <span class="nav-text">后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#层次遍历"><span class="nav-number">3.2.4.</span> <span class="nav-text">层次遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binary-Tree-Right-Side-View"><span class="nav-number">3.2.5.</span> <span class="nav-text">Binary Tree Right Side View</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#得到左下角节点值"><span class="nav-number">3.2.6.</span> <span class="nav-text">得到左下角节点值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树每层节点的平均值"><span class="nav-number">3.2.7.</span> <span class="nav-text">二叉树每层节点的平均值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Zigzag遍历"><span class="nav-number">3.2.8.</span> <span class="nav-text">Zigzag遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过前序和中序遍历构造二叉树"><span class="nav-number">3.2.9.</span> <span class="nav-text">通过前序和中序遍历构造二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过中序和后序遍历构造二叉树"><span class="nav-number">3.2.10.</span> <span class="nav-text">通过中序和后序遍历构造二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉查找树"><span class="nav-number">3.3.</span> <span class="nav-text">二叉查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Unique-Binary-Search-Trees"><span class="nav-number">3.3.1.</span> <span class="nav-text">Unique Binary Search Trees</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unique-Binary-Search-Trees-II"><span class="nav-number">3.3.2.</span> <span class="nav-text">Unique Binary Search Trees II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#验证二叉查找树"><span class="nav-number">3.3.3.</span> <span class="nav-text">验证二叉查找树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有序数组构造二叉查找树"><span class="nav-number">3.3.4.</span> <span class="nav-text">有序数组构造二叉查找树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有序链表构造二叉查找树"><span class="nav-number">3.3.5.</span> <span class="nav-text">有序链表构造二叉查找树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉查找树中第k小的数"><span class="nav-number">3.3.6.</span> <span class="nav-text">二叉查找树中第k小的数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉查找树的最近公共祖先"><span class="nav-number">3.3.7.</span> <span class="nav-text">二叉查找树的最近公共祖先</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的最近公共祖先"><span class="nav-number">3.3.8.</span> <span class="nav-text">二叉树的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完全二叉树"><span class="nav-number">3.4.</span> <span class="nav-text">完全二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Count-Complete-Tree-Nodes"><span class="nav-number">3.4.1.</span> <span class="nav-text">Count Complete Tree Nodes</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">3.5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树转链表-Flatten-Binary-Tree-to-Linked-List"><span class="nav-number">3.5.1.</span> <span class="nav-text">二叉树转链表 Flatten Binary Tree to Linked List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binary-Search-Tree-Iterator"><span class="nav-number">3.5.2.</span> <span class="nav-text">Binary Search Tree Iterator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前缀树Trie"><span class="nav-number">3.6.</span> <span class="nav-text">前缀树Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现Trie"><span class="nav-number">3.6.1.</span> <span class="nav-text">实现Trie</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">4.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#两个有序数组的中位数-Median-of-Two-Sorted-Arrays"><span class="nav-number">4.1.</span> <span class="nav-text">两个有序数组的中位数 Median of Two Sorted Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Remove-Duplicates-from-Sorted-Array"><span class="nav-number">4.2.</span> <span class="nav-text">Remove Duplicates from Sorted Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Remove-Duplicates-from-Sorted-Array-II"><span class="nav-number">4.3.</span> <span class="nav-text">Remove Duplicates from Sorted Array II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Remove-Element"><span class="nav-number">4.4.</span> <span class="nav-text">Remove Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Next-Permutation"><span class="nav-number">4.5.</span> <span class="nav-text">Next Permutation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Merge-Intervals"><span class="nav-number">4.6.</span> <span class="nav-text">Merge Intervals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Insert-Interval"><span class="nav-number">4.7.</span> <span class="nav-text">Insert Interval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并两个有序数组-Merge-Sorted-Array"><span class="nav-number">4.8.</span> <span class="nav-text">归并两个有序数组 Merge Sorted Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pascal’s-Triangle"><span class="nav-number">4.9.</span> <span class="nav-text">Pascal’s Triangle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pascal’s-Triangle-II"><span class="nav-number">4.10.</span> <span class="nav-text">Pascal’s Triangle II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旋转数组-Rotate-Array"><span class="nav-number">4.11.</span> <span class="nav-text">旋转数组 Rotate Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Contains-Duplicate"><span class="nav-number">4.12.</span> <span class="nav-text">Contains Duplicate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Contains-Duplicate-II"><span class="nav-number">4.13.</span> <span class="nav-text">Contains Duplicate II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Contains-Duplicate-III"><span class="nav-number">4.14.</span> <span class="nav-text">Contains Duplicate III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Majority-Element"><span class="nav-number">4.15.</span> <span class="nav-text">Majority Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Majority-Element-II"><span class="nav-number">4.16.</span> <span class="nav-text">Majority Element II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Product-of-Array-Except-Self"><span class="nav-number">4.17.</span> <span class="nav-text">Product of Array Except Self</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Move-Zeroes"><span class="nav-number">4.18.</span> <span class="nav-text">Move Zeroes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#矩阵"><span class="nav-number">5.</span> <span class="nav-text">矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Valid-Sudoku"><span class="nav-number">5.1.</span> <span class="nav-text">Valid Sudoku</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旋转图像-Rotate-Image"><span class="nav-number">5.2.</span> <span class="nav-text">旋转图像 Rotate Image</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#螺旋矩阵-Spiral-Matrix"><span class="nav-number">5.3.</span> <span class="nav-text">螺旋矩阵 Spiral Matrix</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#螺旋矩阵-Spiral-Matrix-II"><span class="nav-number">5.4.</span> <span class="nav-text">螺旋矩阵 Spiral Matrix II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-Matrix-Zeroes"><span class="nav-number">5.5.</span> <span class="nav-text">Set Matrix Zeroes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序矩阵的第k小元素-Kth-Smallest-Element-in-a-Sorted-Matrix"><span class="nav-number">5.6.</span> <span class="nav-text">有序矩阵的第k小元素 Kth Smallest Element in a Sorted Matrix</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表"><span class="nav-number">6.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#快慢指针法"><span class="nav-number">6.1.</span> <span class="nav-text">快慢指针法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Add-Two-Numbers"><span class="nav-number">6.2.</span> <span class="nav-text">Add Two Numbers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Remove-Nth-Node-From-End-of-List"><span class="nav-number">6.3.</span> <span class="nav-text">Remove Nth Node From End of List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并两个有序链表-Merge-Two-Sorted-Lists"><span class="nav-number">6.4.</span> <span class="nav-text">归并两个有序链表 Merge Two Sorted Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Swap-Nodes-in-Pairs"><span class="nav-number">6.5.</span> <span class="nav-text">Swap Nodes in Pairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#旋转链表-Rotate-List"><span class="nav-number">6.6.</span> <span class="nav-text">旋转链表 Rotate List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除有序链表的重复节点-Remove-Duplicates-from-Sorted-List"><span class="nav-number">6.7.</span> <span class="nav-text">删除有序链表的重复节点 Remove Duplicates from Sorted List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除有序链表的重复节点II"><span class="nav-number">6.8.</span> <span class="nav-text">删除有序链表的重复节点II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Partition-List"><span class="nav-number">6.9.</span> <span class="nav-text">Partition List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反转链表-Reverse-Linked-List"><span class="nav-number">6.10.</span> <span class="nav-text">反转链表 Reverse Linked List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反转链表"><span class="nav-number">6.11.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Copy-List-with-Random-Pointer"><span class="nav-number">6.12.</span> <span class="nav-text">Copy List with Random Pointer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#环形链表-Linked-List-Cycle"><span class="nav-number">6.13.</span> <span class="nav-text">环形链表 Linked List Cycle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linked-List-Cycle-II"><span class="nav-number">6.14.</span> <span class="nav-text">Linked List Cycle II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reorder-List"><span class="nav-number">6.15.</span> <span class="nav-text">Reorder List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个链表的交点-Intersection-of-Two-Linked-Lists"><span class="nav-number">6.16.</span> <span class="nav-text">两个链表的交点 Intersection of Two Linked Lists</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回文链表-Palindrome-Linked-List"><span class="nav-number">6.17.</span> <span class="nav-text">回文链表 Palindrome Linked List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Delete-Node-in-a-Linked-List"><span class="nav-number">6.18.</span> <span class="nav-text">Delete Node in a Linked List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#奇偶链表-Odd-Even-Linked-List"><span class="nav-number">6.19.</span> <span class="nav-text">奇偶链表 Odd Even Linked List</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2017 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cactus</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
