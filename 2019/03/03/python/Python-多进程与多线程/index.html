<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="在多核 CPU 时代，使用多进程和多线程能够充分利用 CPU 多核性能来提高程序的执行效率。 本文将着重介绍 Python 多进程和多线程的区别和应用场景选取。">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 多进程与多线程">
<meta property="og:url" content="https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Cactus&#39;s blog">
<meta property="og:description" content="在多核 CPU 时代，使用多进程和多线程能够充分利用 CPU 多核性能来提高程序的执行效率。 本文将着重介绍 Python 多进程和多线程的区别和应用场景选取。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-03-03T23:15:15.000Z">
<meta property="article:modified_time" content="2020-01-11T13:02:31.078Z">
<meta property="article:author" content="Cactus">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="多进程">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Python 多进程与多线程</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Cactus&#39;s blog" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/03/07/python/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/02/25/python/Python-%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&text=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&is_video=false&description=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Python 多进程与多线程&body=Check out this article: https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&name=Python 多进程与多线程&description=&lt;p&gt;在多核 CPU 时代，使用多进程和多线程能够充分利用 CPU 多核性能来提高程序的执行效率。 本文将着重介绍 Python 多进程和多线程的区别和应用场景选取。&lt;/p&gt;" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&t=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础知识"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程"><span class="toc-number">1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">1.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程和线程的区别"><span class="toc-number">1.3.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程通信与线程通信"><span class="toc-number">1.4.</span> <span class="toc-text">进程通信与线程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程"><span class="toc-number">1.5.</span> <span class="toc-text">协程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-多线程"><span class="toc-number">2.</span> <span class="toc-text">Python 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动线程"><span class="toc-number">2.1.</span> <span class="toc-text">启动线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock"><span class="toc-number">2.2.</span> <span class="toc-text">Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GIL"><span class="toc-number">2.3.</span> <span class="toc-text">GIL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-多进程"><span class="toc-number">3.</span> <span class="toc-text">Python 多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">3.1.</span> <span class="toc-text">fork()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocessing"><span class="toc-number">3.2.</span> <span class="toc-text">multiprocessing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程池-Pool"><span class="toc-number">3.3.</span> <span class="toc-text">进程池 Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-中的进程通信"><span class="toc-number">3.4.</span> <span class="toc-text">python 中的进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#multiprocess-Queue"><span class="toc-number">3.4.1.</span> <span class="toc-text">multiprocess.Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子进程-subprocess"><span class="toc-number">3.5.</span> <span class="toc-text">子进程 subprocess</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#subprocess-Popen-类"><span class="toc-number">3.5.1.</span> <span class="toc-text">subprocess.Popen 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#subprocess-PIPE"><span class="toc-number">3.5.2.</span> <span class="toc-text">subprocess.PIPE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#communicate"><span class="toc-number">3.5.3.</span> <span class="toc-text">communicate()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择多进程还是多线程"><span class="toc-number">4.</span> <span class="toc-text">选择多进程还是多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-密集型"><span class="toc-number">4.1.</span> <span class="toc-text">CPU 密集型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-密集型"><span class="toc-number">4.2.</span> <span class="toc-text">IO 密集型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Python 多进程与多线程
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Cactus's blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-03-03T23:15:15.000Z" itemprop="datePublished">2019-03-03</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Python/">Python</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Python/" rel="tag">Python</a>, <a class="tag-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a>, <a class="tag-link" href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/" rel="tag">多进程</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>在多核 CPU 时代，使用多进程和多线程能够充分利用 CPU 多核性能来提高程序的执行效率。 本文将着重介绍 Python 多进程和多线程的区别和应用场景选取。</p>
<a id="more"></a>

<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。每个应用程序都有一个自己的进程，提供执行程序所需的所有资源。</p>
<p>每个进程启动时都会最先产生一个线程，即主线程。然后再由主线程创建其他线程。进程是并行的，即同一时刻可以运行多个进程。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统进行运算调度的最小单位，被包含在进程之中，是进程的实际运作单位。</p>
<p>一条线程是指进程中一个单一顺序的控制流，一个进程中有多个线程，每条线程并发执行不同的任务。线程是并发的，存在交替执行的情况。</p>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>一个程序至少有一个进程，一个进程至少有一个线程。</p>
<ol>
<li>根本区别：进程是资源分配的基本单位，线程是程序执行的最小单位</li>
<li>开销方面：每个进程有独立的代码和数据空间，每启动一个进程，系统会为他分配地址空间，进程间的切换有较大开销；同一类线程共享代码和数据空间，切换和创建的开销较小</li>
<li>线程通信更加方便，同一进程下的线程共享全局变量、静态变量等数据；而进程需要以通信方式(IPC)进行</li>
<li>由于进程有自己独立的地址空间，因此多进程程序更加健壮；而多线程程序有一个线程挂掉，全部线程都会挂掉</li>
</ol>
<h3 id="进程通信与线程通信"><a href="#进程通信与线程通信" class="headerlink" title="进程通信与线程通信"></a>进程通信与线程通信</h3><p>线程通信： 同一进程下的线程共享相同的数据空间，可以直接通信。 需要做好同步/互斥 mutex，保护共享的全局变量。</p>
<p>进程通信： 需要通过操作系统，以 IPC 方式进行。</p>
<ol>
<li>管道： 是半双工通信方式，数据只能单向流动，只能在父子进程或者兄弟进程中使用。 </li>
<li>命名管道： 是半双工的通信方式，但允许无亲缘关系进程间的通信。 命名管道是一种 FIFO 对象，常用于客户端-服务器通信。</li>
<li>消息队列： 消息队列是消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>信号量： 是一个计数器，用于为多个进程提供对共享数据对象的访问。</li>
<li>共享内存： 映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式。需要使用信号量用来同步对共享存储的访问。</li>
<li>套接字： 与其它通信机制不同的是，它可用于不同机器间的进程通信</li>
</ol>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程 Coroutine：又称微线程，纤程。是一种程序组件，协程看上去是子程序（函数），但在执行过程中在子程序内部可以中断，转而执行其他子程序（不是调用），在适当的时候再返回来执行。  </p>
<p>特点：只有一个线程执行。  </p>
<p>优势：执行效率高，由于子程序切换不是由线程，而是由程序自身控制，因此没有线程切换的消耗；不需要多线程的锁机制，由于只有一个线程，不存在同时写变量冲突，协程中控制共享资源不加锁。<br>python generator 的 yield 可以在一定程度上实现协程。</p>
<ul>
<li>线程由操作系统控制</li>
<li>协程由程序自身控制</li>
</ul>
<h2 id="Python-多线程"><a href="#Python-多线程" class="headerlink" title="Python 多线程"></a>Python 多线程</h2><p>Python 标准库提供了 <code>_thread</code> 和 <code>threading</code> 两个模块进行多线程操作，<code>_thread</code> 是低级模块，<code>threading</code> 是高级模块，对 <code>_thread</code> 进行了封装， 因此一般开发中只需使用 <code>threading</code> 模块。</p>
<h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>启动线程有两种方法</p>
<ol>
<li>直接使用 threading.Thread()，把一个函数传入并创建 Thread 实例，然后调用 start() 开始执行。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个函数名可随便定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    print(<span class="string">'thread %s ended'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    t1 = threading.Thread(target=run, args=(<span class="number">1000000</span>,), name=<span class="string">"thread1"</span>)</span><br><span class="line">    t2 = threading.Thread(target=run, args=(<span class="number">10</span>,), name = <span class="string">"thread2"</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># t1.join() # 使主线程在子线程结束后再退出</span></span><br><span class="line">    <span class="comment"># t2.join()</span></span><br><span class="line">    print(<span class="string">'thread %s ended'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread MainThread is running...</span><br><span class="line">thread thread1 is running...</span><br><span class="line">thread thread2 is running...</span><br><span class="line">thread thread2 ended</span><br><span class="line">thread MainThread ended</span><br><span class="line">thread thread1 ended</span><br></pre></td></tr></table></figure>

<p>任何进程都会默认启动一个线程，叫做主线程，主线程又可以启动新的线程。 threading 模块中的 <code>current_thread()</code> 方法可以返回当前执行的实例。 主线程实例名字为 <code>MainThread</code>，子线程名字可以在创建时指定。</p>
<p>我们注意到上面的结果中，主线程 MainThread 结束后，子线程 thread1 仍在运行，可以通过 <code>join()</code> 方法进行线程合并。 join() 函数执行顺序是逐个执行每个线程，执行完毕后继续往下执行，能够使主线程在子线程结果后再退出。</p>
<ol start="2">
<li>继承 threading.Thread 来定义线程类，重写 run 方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        super(MyThread, self).__init__() <span class="comment"># 重构 run() 函数必须写</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"thread %s is running..."</span> %self.n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">"thread1"</span>)</span><br><span class="line">    t1.start()</span><br></pre></td></tr></table></figure>

<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>由于线程之间数据共享，当有多个线程对同一个共享数据进行操作，就可能把数据改乱，因此需要考虑线程安全问题。 </p>
<p>threading 模块中定义了 <code>Lock</code> 类，提供<strong>互斥锁</strong>的功能来保证多线程情况下数据的一致性。</p>
<p>Lock 锁的使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock = threading.Lock() <span class="comment"># 创建锁</span></span><br><span class="line">lock.acquire([timeout]) <span class="comment"># 锁定，可以设置 timeout，在超时后通过返回值可以判断是否得到了锁</span></span><br><span class="line">lock.release() <span class="comment"># 释放</span></span><br></pre></td></tr></table></figure>

<p>定义一个共享变量 balance，初始值为 0，创建两个线程进行操作，理论上结果应该是 0。 但实际上，如果循环的次数多的话，最终结果不一定会是 0。</p>
<p>原因是: 在操作系统中，高级语言的一条语句在 CPU 中执行其实是若干条语句。<br>就比如 <code>balance = balance + n</code>，会先计算出 balance + n 并将结果存入临时变量中， 再将临时变量的值赋给 balance。 因此，多个线程同时修改 balance 的时候，就可能把它改乱。</p>
<p>解决方法： 给 change() 加锁，当 thread1 执行 change() 时，该线程获得锁，那么其他线程就不能执行 change()，只能等待锁释放。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">balance = <span class="number">0</span> <span class="comment"># 假设这是存款</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance += n</span><br><span class="line">    balance -= n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            change(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = threading.Thread(target=run, args=(<span class="number">5</span>, ))</span><br><span class="line">    t2 = threading.Thread(target=run, args=(<span class="number">8</span>, ))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure>

<p>使用锁能够确保某段关键代码只由一个线程从头到尾完整执行，而缺点是阻止了多线程并发执行，效率降低。</p>
<h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p>对于其他语言，CPU 是多核时可以支持多个线程同时执行，但 python 在设计时有 GIL（Global Interpreter Lock）全局解释锁，导致无论是单核还是多核，只能同时允许一个线程执行，无法利用多线程实现多核任务。GIL 锁只在 Cpython 中存在。</p>
<p>在一个 python 进程中，GIL 锁只有一个，某个线程想要执行，就必须拿到 GIL。在 python3 中，GIL 使用计时器，当执行时间达到阈值时，当前线程就释放 GIL 锁。</p>
<p>多核多线程比单核多线程更差，因为在单核下多线程，每次释放 GIL，唤醒的那个线程都能获取到 GIL 锁，能够无缝执行。<br>但多核下，CPU0 释放 GIL 后，其他 CPU 上的线程都会进行竞争，但 GIL 可能会马上又被 CPU0 拿到，导致其他几个 CPU 上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低</p>
<p>python 可以用多进程实现多核任务，多个 python 进程有各自独立的 GIL 锁，互不影响。</p>
<h2 id="Python-多进程"><a href="#Python-多进程" class="headerlink" title="Python 多进程"></a>Python 多进程</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>在 linux/unix 中，可以使用 fork() 调用实现多进程。fork() 函数通过系统调用创建一个与原来进程几乎完全相同的进程，相当于把当前进程（父进程）复制了一份（子进程）。</p>
<p>fork() 函数的特性在于： 调用一次，会返回两次，是父进程和子进程在各自的地址空间返回，可能有三种不同的返回值。</p>
<ol>
<li>如果成功创建子进程，在父进程中，返回子进程的 ID</li>
<li>如果成功创建子进程，在子进程中，返回 0</li>
<li>如果创建失败，返回 -1</li>
</ol>
<p>python 的 os 模块封装了 fork() 方法，子进程调用 getppid() 可以得到父进程的 ID, getpid() 是得到当前进程。 要注意的是，在 windows 中没有 fork() 方法.</p>
<p>子进程是在 fork 之后开始向下执行，而不是从头开始执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="string">'process %s start.'</span> %os.getpid())</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'I am child process %s, my parent is %s.'</span> %(os.getpid(), os.getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'I am %s, I created a child process %s.'</span> %(os.getpid(),pid))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process 26601 start.</span><br><span class="line">I am 26601, I created a child process 26602.</span><br><span class="line">I am child process 26602, my parent is 26601.</span><br></pre></td></tr></table></figure>

<h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>要实现跨平台的多进程，可以使用 multiprocessing 模块，提供一个 Process 类来代表一个进程对象。</p>
<p>Process 类与 Thread 类相似，有两种使用方法：</p>
<ol>
<li>直接使用 Process</li>
</ol>
<p>创建子进程实例时，只需要传入执行函数和函数参数，start() 方法启动子进程，join() 会等待子进程执行完毕，用于进程同步。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">p = multiprocessing.Process(targte=fun, args=(<span class="number">1</span>,<span class="number">2</span>,))</span><br><span class="line">p.start()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>继承 Process 来自定义进程类，重写 run 方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		super(MyProcess, self).__init__()</span><br><span class="line">		self.name = name</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(os.getpid(), self.name)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]:</span><br><span class="line">		p = MyProcess(name)</span><br><span class="line">		p.start()</span><br><span class="line">		p.join()</span><br></pre></td></tr></table></figure>

<h3 id="进程池-Pool"><a href="#进程池-Pool" class="headerlink" title="进程池 Pool"></a>进程池 Pool</h3><p>进程池 Pool 可以用来批量创建子进程，对 Pool 对象调用 join() 方法会等待所有子进程执行完毕，之前必须先调用 close() 方法，调用 close() 后就不能再继续添加新进程。</p>
<p>Pool 常用方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">apply()</td>
<td align="center">同步执行（串行）</td>
</tr>
<tr>
<td align="left">apply_async()</td>
<td align="center">异步执行（并行）</td>
</tr>
<tr>
<td align="left">terminate()</td>
<td align="center">立刻关闭进程池</td>
</tr>
<tr>
<td align="left">close()</td>
<td align="center">等待所有进程结束后，才关闭进程池</td>
</tr>
<tr>
<td align="left">join()</td>
<td align="center">主进程等待所有子进程执行完毕，必须在 close() 或 terminate() 之后用</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg1, agr2)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">size = multiprocessing.cpu_count()</span><br><span class="line">pool = multiprocessing.Pool(processes = size) <span class="comment"># 不指定的话，pool 的默认大小为 CPU 核数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">	pool.apply_async(fun, args=(<span class="number">1</span>, <span class="number">2</span>, ))</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure>

<h3 id="python-中的进程通信"><a href="#python-中的进程通信" class="headerlink" title="python 中的进程通信"></a>python 中的进程通信</h3><p>进程之间不共享数据， 进程间需要通信的话可以使用 multiprocess 的 Queue, Pipes 等方式来交换数据。</p>
<h4 id="multiprocess-Queue"><a href="#multiprocess-Queue" class="headerlink" title="multiprocess.Queue"></a>multiprocess.Queue</h4><p>Queue 是多进程安全的队列，可以实现多进程之间的数据传递。主要有 put 和 get 两个函数。put() 用于插入数据到队列中，get() 是从队列中读取并删除一个元素。</p>
<h3 id="子进程-subprocess"><a href="#子进程-subprocess" class="headerlink" title="子进程 subprocess"></a>子进程 subprocess</h3><p>subprocess 能够方便地启动一个子进程，并控制输入输出。可以用于替换 os.system, os.popen 等方法。</p>
<h4 id="subprocess-Popen-类"><a href="#subprocess-Popen-类" class="headerlink" title="subprocess.Popen 类"></a>subprocess.Popen 类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.Popen(args, stdin=<span class="literal">None</span>, stdout=<span class="literal">None</span>, stderr=<span class="literal">None</span>, shell=<span class="literal">False</span>, executable=<span class="literal">None</span>, ...)</span><br></pre></td></tr></table></figure>
<p>创建并返回一个子进程，并在子进程中执行制定的程序。</p>
<ul>
<li>args： 必填，要执行的命令或可执行文件的路径，及传给程序的参数</li>
<li>stdin： 子进程的标准输入</li>
<li>stdout： 子进程的标准输出，可以制定输出到文件</li>
<li>stderr： 子进程的标准错误输出</li>
<li>shell： True 则指定使用 shell 运行程序</li>
<li>executable： 指定子进程在什么 shell 中运行，默认为 /bin/sh</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subporcess</span><br><span class="line">p = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">stdout, stderr = p.communicate()</span><br><span class="line">print(stdout)</span><br></pre></td></tr></table></figure>

<h4 id="subprocess-PIPE"><a href="#subprocess-PIPE" class="headerlink" title="subprocess.PIPE"></a>subprocess.PIPE</h4><p>可以被用于 Popen 的 stdin, stdout, stderr 三个参数的特殊值，表示需要创建一个新的管道。</p>
<h4 id="communicate"><a href="#communicate" class="headerlink" title="communicate()"></a>communicate()</h4><p><code>p.communicate(input=None)</code><br>和子进程 p 交流，将 input 的数据发送到子进程的 stdin 中，并同时读取子进程的 stdout 和 stderr。</p>
<p>需要注意的是： communicate() 只能通过管道和子进程通信，也就是需要设置 subprocess.PIPE； 且 communicate() 会立即阻塞父进程，直至子进程结束。</p>
<h2 id="选择多进程还是多线程"><a href="#选择多进程还是多线程" class="headerlink" title="选择多进程还是多线程"></a>选择多进程还是多线程</h2><p>应用程序可以分为<code>CPU 密集型</code>和<code>IO 密集型</code>两种，选择多进程还是多线程来执行程序，首先需要看程序属于哪种类型。</p>
<h3 id="CPU-密集型"><a href="#CPU-密集型" class="headerlink" title="CPU 密集型"></a>CPU 密集型</h3><ul>
<li>也叫计算密集型任务，特点：需要进行大量判断，主要消耗 CPU 资源，大部分时间用于计算、逻辑判断等 CPU 动作的程序，如计算圆周率、视频高清解码等；  </li>
<li>python 这种脚本语言不适合计算密集型任务，最好用 C 语言；</li>
<li>python CPU 密集型任务用多进程模型。</li>
</ul>
<h3 id="IO-密集型"><a href="#IO-密集型" class="headerlink" title="IO 密集型"></a>IO 密集型</h3><ul>
<li>涉及到网络、磁盘 IO 的任务是 IO 密集型任务，特点：CPU 消耗较少，大部分时间在等待 IO 操作完成（IO 操作速度远低于 CPU 和内存的速度）， 如 web 应用、文件处理、爬虫； 线程 A 在进行 IO 等待时可以切换到线程 B 执行，多线程可以利用 IO 阻塞等待时的空闲时间执行其他线程，提升效率。</li>
<li>IO 密集型任务最合适的语言是开发效率最高（代码量最少）的语言，脚本语言是首选；</li>
<li>python IO 密集型任务用多线程模型，多线程只使用一个 CPU 核心。</li>
<li>io 操作不占用 CPU（从硬盘、从网络、从内存读数据都算 io）</li>
</ul>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319272686365ec7ceaeca33428c914edf8f70cca383000" target="_blank" rel="noopener">[1] 进程和线程</a></p>
<p><a href="https://www.jianshu.com/p/a69dec87e646" target="_blank" rel="noopener">[2] Python 多进程与多线程</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础知识"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程"><span class="toc-number">1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">1.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程和线程的区别"><span class="toc-number">1.3.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程通信与线程通信"><span class="toc-number">1.4.</span> <span class="toc-text">进程通信与线程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程"><span class="toc-number">1.5.</span> <span class="toc-text">协程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-多线程"><span class="toc-number">2.</span> <span class="toc-text">Python 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#启动线程"><span class="toc-number">2.1.</span> <span class="toc-text">启动线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock"><span class="toc-number">2.2.</span> <span class="toc-text">Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GIL"><span class="toc-number">2.3.</span> <span class="toc-text">GIL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-多进程"><span class="toc-number">3.</span> <span class="toc-text">Python 多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">3.1.</span> <span class="toc-text">fork()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocessing"><span class="toc-number">3.2.</span> <span class="toc-text">multiprocessing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程池-Pool"><span class="toc-number">3.3.</span> <span class="toc-text">进程池 Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#python-中的进程通信"><span class="toc-number">3.4.</span> <span class="toc-text">python 中的进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#multiprocess-Queue"><span class="toc-number">3.4.1.</span> <span class="toc-text">multiprocess.Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子进程-subprocess"><span class="toc-number">3.5.</span> <span class="toc-text">子进程 subprocess</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#subprocess-Popen-类"><span class="toc-number">3.5.1.</span> <span class="toc-text">subprocess.Popen 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#subprocess-PIPE"><span class="toc-number">3.5.2.</span> <span class="toc-text">subprocess.PIPE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#communicate"><span class="toc-number">3.5.3.</span> <span class="toc-text">communicate()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择多进程还是多线程"><span class="toc-number">4.</span> <span class="toc-text">选择多进程还是多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-密集型"><span class="toc-number">4.1.</span> <span class="toc-text">CPU 密集型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-密集型"><span class="toc-number">4.2.</span> <span class="toc-text">IO 密集型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&text=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&is_video=false&description=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Python 多进程与多线程&body=Check out this article: https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&title=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&name=Python 多进程与多线程&description=&lt;p&gt;在多核 CPU 时代，使用多进程和多线程能够充分利用 CPU 多核性能来提高程序的执行效率。 本文将着重介绍 Python 多进程和多线程的区别和应用场景选取。&lt;/p&gt;" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://xieyiyu.github.io/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/&t=Python 多进程与多线程" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Cactus
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
