<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2020/01/17/test/"/>
      <url>/2020/01/17/test/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 时间函数总结</title>
      <link href="/2019/12/15/python/Python-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/15/python/Python-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>在实际开发中，常常需要用到日期和时间，并将其进行格式化处理，在 Python 中的时间模块常用的是 time 和 datetime，这两个模块中的方法容易混淆，特此对 Python 中的日期时间获取与格式化进行梳理总结。</p><a id="more"></a><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><ol><li><p>UTC time Coordinated Universal Time：世界协调时间，又称格林尼治天文时间、世界标准时间。与 UTC time 对应的是各个时区的 local time，也就是本地时间，如北京时间。</p></li><li><p>epoch time：表示时间开始的起点，是一个特定的时间，不同平台上这个时间点的值不太相同，对 Unix，epoch time 是 1970-01-01 00:00:00 UTC。</p></li><li><p>timestamp：时间戳，也称为 Unix 时间或 POSIX 时间，是一种时间表示方式，表示从格林尼治时间 1970 年 1 月 1 日 0 时 0 分 0 秒开始到现在所经过的毫秒数，其值为 float 类型。<strong>但需要注意的是这在某些编程语言中是秒数，比如 python。</strong></p></li></ol><p>对应的，在 python 中日期时间也有三种表示方式。</p><ol><li><p>timestamp： 时间戳</p></li><li><p>struct_time：时间元组，共有九个元素组。stamptime 时间戳和格式化时间字符串之间的转化必须通过 struct_time 才行，所以 struct_time 是 3 种时间表示的中心。</p></li><li><p>format time：格式化时间，已格式化的结构字符串使时间更具可读性。包括自定义格式和固定格式。</p></li></ol><p>在使用过程中，常需要在三种时间格式之间进行相应的转换，以得到我们想要的表现格式。</p><h3 id="time-模块"><a href="#time-模块" class="headerlink" title="time 模块"></a>time 模块</h3><p>在 time 模块中，获取当前时间只有一种方式，使用<code>time.time()</code>，但得到的是时间戳格式的时间，想要获取时间元组和格式化时间，只能进行转换。</p><h4 id="timestamp-与-struct-time"><a href="#timestamp-与-struct-time" class="headerlink" title="timestamp 与 struct_time"></a>timestamp 与 struct_time</h4><p>localtime 和 gmtime 方法都可以将时间戳转化为时间元组，如果不传入参数默认为当前时间。localtime 转的是本地时间， gmtime 是世界标准时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># struct_time to timestamp</span></span><br><span class="line">time.mktime(time.localtime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># timestamp to struct_time</span></span><br><span class="line">t = time.time() <span class="comment"># 1576397965.253168</span></span><br><span class="line">time.localtime(t)</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=12, tm_mday=15, tm_hour=16, tm_min=19, tm_sec=25, tm_wday=6, tm_yday=349, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">time.gmtime(t)</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=12, tm_mday=15, tm_hour=8, tm_min=19, tm_sec=25, tm_wday=6, tm_yday=349, tm_isdst=0)</span></span><br></pre></td></tr></table></figure><h5 id="struct-time"><a href="#struct-time" class="headerlink" title="struct_time"></a>struct_time</h5><table><thead><tr><th>属性</th><th>含义</th><th>值</th></tr></thead><tbody><tr><td>tm_wday</td><td>weekday</td><td>0 - 6（0 表示周日）</td></tr><tr><td>tm_yday</td><td>一年中的第几天</td><td>1 - 366</td></tr><tr><td>tm_isdst</td><td>是否是夏令时</td><td>默认为 -1</td></tr></tbody></table><p>struct_time 属性值获取可以通过两种方式获取：</p><ul><li>利用下标，如 st[0] 即 tm_year 的值</li><li>通过对象名 <code>st.tm_year</code> 获取</li></ul><h4 id="struct-time-与-format-time"><a href="#struct-time-与-format-time" class="headerlink" title="struct_time 与 format_time"></a>struct_time 与 format_time</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># struct_time to format_time</span></span><br><span class="line">time.strftime(<span class="string">"%Y-%m-%d"</span>) <span class="comment"># '2019-12-18'</span></span><br><span class="line">time.strftime(<span class="string">"%Y-%m-%d"</span>, time.localtime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># format_time to struct_time</span></span><br><span class="line">time.strptime(<span class="string">'2019-12-18'</span>, <span class="string">'%Y-%m-%d'</span>)</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=12, tm_mday=18, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=2, tm_yday=352, tm_isdst=-1)</span></span><br></pre></td></tr></table></figure><h5 id="format-time"><a href="#format-time" class="headerlink" title="format_time"></a>format_time</h5><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>%a</td><td>本地（locale）简化星期名称</td></tr><tr><td>%A</td><td>本地完整星期名称</td></tr><tr><td>%b</td><td>本地简化月份名称</td></tr><tr><td>%B</td><td>本地完整月份名称</td></tr><tr><td>%c</td><td>本地相应的日期和时间表示</td></tr><tr><td>%d</td><td>一个月中的第几天（01 - 31）</td></tr><tr><td>%H</td><td>一天中的第几个小时（24小时制，00 - 23）</td></tr><tr><td>%I</td><td>第几个小时（12小时制，01 - 12）</td></tr><tr><td>%j</td><td>一年中的第几天（001 - 366）</td></tr><tr><td>%m</td><td>月份（01 - 12）</td></tr><tr><td>%M</td><td>分钟数（00 - 59）</td></tr><tr><td>%p</td><td>本地 am 或者 pm 的相应符</td></tr><tr><td>%S</td><td>秒（00 - 61, 60 是闰秒，61 是基于历史原因保留）</td></tr><tr><td>%U</td><td>一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。</td></tr><tr><td>%w</td><td>一个星期中的第几天（0 - 6，0是星期天）</td></tr><tr><td>%W</td><td>和 %U 基本相同，不同的是 %W 以星期一为一个星期的开始。</td></tr><tr><td>%x</td><td>本地相应日期</td></tr><tr><td>%X</td><td>本地相应时间</td></tr><tr><td>%y</td><td>去掉世纪的年份（00 - 99）</td></tr><tr><td>%Y</td><td>完整的年份</td></tr><tr><td>%Z</td><td>时区的名字（如果不存在为空字符）</td></tr><tr><td>%%</td><td>‘%’字符</td></tr></tbody></table><p>最常用： <code>%Y-%m-%d %H:%M:%S</code></p><h3 id="datetime-模块"><a href="#datetime-模块" class="headerlink" title="datetime 模块"></a>datetime 模块</h3><p>datetime 模块是对 time 模块的进一步封装，对用户更加友好，在时间的获取上也比较方便。 datetime 模块中常用的类有 date、time、datetime 和 timedelta。</p><h4 id="date-类"><a href="#date-类" class="headerlink" title="date 类"></a>date 类</h4><p>date 对象由 year、 month、 day 三部分组成： datetime.date(year, month, day)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">a = datetime.date(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">18</span>)</span><br><span class="line">a.year <span class="comment"># 2019</span></span><br><span class="line">a.month <span class="comment"># 12</span></span><br><span class="line">a.day <span class="comment"># 18</span></span><br></pre></td></tr></table></figure><h4 id="time-类"><a href="#time-类" class="headerlink" title="time 类"></a>time 类</h4><p>datetime.time(hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ) </p><p>静态方法和字段：</p><ul><li>time.min、time.max：time类所能表示的最小、最大时间。其中，time.min = time(0, 0, 0, 0)， time.max = time(23, 59, 59, 999999)；</li><li>time.resolution：时间的最小单位，这里是 1 微秒；</li></ul><h4 id="datetime-类"><a href="#datetime-类" class="headerlink" title="datetime 类"></a>datetime 类</h4><p>datetime 相当于 date 和 time 结合起来<br><code>datetime.datetime (year, month, day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] )</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">dt = datetime.datetime.now() <span class="comment"># datetime.datetime(2019, 12, 18, 20, 56, 36, 415244)</span></span><br><span class="line">dt.date() <span class="comment"># datetime.date(2019, 12, 18)</span></span><br><span class="line">dt.time() <span class="comment"># datetime.time(20, 56, 36, 415244)</span></span><br><span class="line">dt.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>) <span class="comment"># '2019-12-18 20:56:36'</span></span><br><span class="line">dt.ctime() <span class="comment"># 'Wed Dec 18 20:56:36 2019'，返回一个日期时间的 C 格式字符串</span></span><br><span class="line">dt.utctimetuple() <span class="comment"># UTC 时间元组：time.struct_time(tm_year=2019, tm_mon=12, tm_mday=18, tm_hour=20, tm_min=56, tm_sec=36, tm_wday=2, tm_yday=352, tm_isdst=0)</span></span><br></pre></td></tr></table></figure><h4 id="timedelta-类"><a href="#timedelta-类" class="headerlink" title="timedelta 类"></a>timedelta 类</h4><p>timedelta 类可以实现日期之间的加减运算，包括 date、time、datetime 对象。注意不能计算月份。</p><ol><li>获取之前或之后的时间: 天(days), 小时(hours), 分钟(minutes), 秒(seconds), 微秒(microseconds)。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dt - datetime.timedelta(days=<span class="number">1</span>) <span class="comment"># 昨天，datetime.datetime(2019, 12, 17, 20, 56, 36, 415244)</span></span><br><span class="line">dt + datetime.timedelta(hours=<span class="number">8</span>) <span class="comment"># 当前时间向后 8 小时，datetime.datetime(2019, 12, 19, 4, 56, 36, 415244)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>获取时间差，时间差单位默认为秒，可以查看天(days), 秒(seconds), 微秒(microseconds)。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start_time = datetime.datetime.now()</span><br><span class="line">end_time = start_time + datetime.timedelta(hours=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">end_time - start_time <span class="comment"># datetime.timedelta(seconds=28800)</span></span><br><span class="line">(end_time - start_time).seconds <span class="comment"># 28800</span></span><br><span class="line">(end_time - start_time).days <span class="comment"># 0</span></span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.cnblogs.com/awakenedy/articles/9182036.html" target="_blank" rel="noopener">Python datetime模块详解</a><br><a href="https://www.cnblogs.com/haitaoli/p/10823403.html" target="_blank" rel="noopener">python time模块和datetime模块详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 数据结构底层实现</title>
      <link href="/2019/09/25/python/Python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/09/25/python/Python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>list、dict、set、tuple 是 python 中常用的四种数据结构，在平常的学习中只是简单学习了其使用方式，没有了解底层实现，特此记录和学习一下更深层次的知识。</p><a id="more"></a><h2 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h2><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>python 的内建数据类型 dict 字典，就是用哈希表实现的。</p><p>Python 是使用开放寻址法中的二次探查来解决冲突的。然后如果使用的容量超过数组大小的 2/3，就申请更大的容量。数组大小较小的时候 resize 为 * 4，较大的时候 resize * 2。实际上是用左移的形式。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合 set 中的元素互不相同，没有重复元素，set 中的元素是无序的，比如 {1, 2, 3} 和 {3, 2, 1} 是同一个集合，创建一个空集合可以用 <code>s = set()</code>，将一个 list 转为 set 元素的顺序会打乱。</p><p>set 和 dict 的底层实现方式类似，都是使用哈希，把 set 的实现方式叫做 Hash Set，dict 的实现叫 Hash Table。<br>set 与 dict 的不同是，set 只存储 key，对于 set 查找元素的时间复杂度为 O(1)</p><p>set 的去重是通过两个函数 <code>__hash__</code> 和 <code>__eq__</code> 结合实现的</p><ol><li>当两个变量的哈希值不同时，就认为这两个变量是不同的</li><li>当两个变量哈希值相同时，调用 <code>__eq__</code> 方法，返回 True 则这两个变量是同一个，应该去除一个；返回 False 则不去重，因为哈希值相同的变量的值可能不同。</li></ol><p>set 中的元素和 dict 的 key 必须是可以 hash 的，不可变类型类型都是可 hash 的，比如 number(int, float, complex)、布尔型、字符串(str, bytes)、tuple、None；而可变类型 list、set、dict 都是不可哈希的。</p><p>set 的 hash 寻址是二次散列和顺序寻址结合的,</p><h5 id="set-常用方法"><a href="#set-常用方法" class="headerlink" title="set 常用方法"></a>set 常用方法</h5><ol><li>s.add(elem)： 添加一个元素到 set 中，如果元素存在则什么都不做</li><li>s.remove(elem)： 删除 set 中的一个元素，元素不存则报错 KeyError</li><li>s.pop()： 删除并返回<strong>任意</strong>元素，空集报错 KeyError</li><li>s.clear()： 删除所有元素<br>set 不能修改元素，只能添加和删除元素，时间复杂度平均为 O(1), 最差的情况是 O(n)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> dict </tag>
            
            <tag> list </tag>
            
            <tag> set </tag>
            
            <tag> tuple </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 文本处理三剑客</title>
      <link href="/2019/09/23/linux/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/"/>
      <url>/2019/09/23/linux/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>grep、awk、sed 是 linux 中进行文本处理的三大利器，称为 linux 三剑客。grep 适合单纯的文本查找和匹配，awk 适合用于格式化文本，sed 适合编辑匹配的文本。</p><a id="more"></a><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 是 linux 的文本搜索工具，根据用户指定的 “模式”（可以是正则表达式）对目标文件逐步进行匹配检查，并打印匹配到的行。</p><h3 id="grep-格式与参数"><a href="#grep-格式与参数" class="headerlink" title="grep 格式与参数"></a>grep 格式与参数</h3><p>grep [options] pattern [filepath]</p><p>-c ：统计匹配到的行数；<br>-E ：使用扩展的正则表达式<br>-f ：&lt;规则文件&gt; 查找符合指定规则文件的内容，格式为每行一个规则样式；<br>-i ：忽略大小写；<br>-n ：输出行号；<br>-o ：只显示被匹配到的字符串；<br>-v ：反向匹配，也就是输出不匹配的内容，相当于 [^]； </p><p>若希望输出匹配行的前后行 -A -B -C 参数： </p><ul><li>grep 字符串 filepath -A 1 ： 输出除匹配的该行外，还显示其后面一行(After 1)</li><li>grep 字符串 filepath -B 1 ： 输出除匹配的该行外，还显示其前面一行(Before 1)</li><li>grep 字符串 filepath -C 1 ： 输出除匹配的该行外，还显示前一行和后一行</li></ul><h3 id="grep-实例"><a href="#grep-实例" class="headerlink" title="grep 实例"></a>grep 实例</h3><p>1.统计某个文本中 abc 出现的次数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -o <span class="string">'abc'</span> filename | wc -l</span><br><span class="line"><span class="comment"># 不能用 grep -c 这只显示出符合要求的行数，一行多个的话无法判断</span></span><br></pre></td></tr></table></figure><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>awk 是一种编程语言，用于 linux 处理数据和生成报告，更适合文本格式化，对文本进行较复杂的格式处理。 awk 将文件逐行输入，以空格为默认分隔符将每行切片，然后可以对切开的每部分进行分析和处理。</p><h3 id="awk-格式与参数"><a href="#awk-格式与参数" class="headerlink" title="awk 格式与参数"></a>awk 格式与参数</h3><p><code>awk [options] &#39;pattern{action}&#39; filepath</code><br>pattern 表示 awk 在数据中查找的内容，action 是在找到匹配内容时执行的命令</p><p>-F fs ：指定分隔符 fs，fs 可以是字符串或正则表达式，如果有多个分隔符： <code>awk -F &#39;[:,]&#39; filepath</code><br>-f scriptfile ：从脚本文件中读取 awk 命令<br>-v var=value ：赋值一个用户定义变量，将外部变量传递给 awk</p><h3 id="awk-变量"><a href="#awk-变量" class="headerlink" title="awk 变量"></a>awk 变量</h3><h4 id="awk-内建变量"><a href="#awk-内建变量" class="headerlink" title="awk 内建变量"></a>awk 内建变量</h4><ul><li>$0 整行, $1-$n 第n个字段，awk 逐行处理文本，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。 直接 print 或 print $0 就显示整行。</li><li>NF ：浏览记录的域的个数（字段数）； $NF 是最后一列的内容，$(NF-1) 是倒数第二列</li><li>FS ：输入字段分隔符，默认为空白字符</li><li>OFS ：输出字段分隔符，默认为空白字符</li><li>RS ：输入记录分隔符，指定输入时的换行符，原换行符扔有效，比如 RS=’:’，则遇到冒号就换行输出</li><li>ORS ：输出记录分隔符，输出时用指定符号代替换行符</li><li>NR ：已经读出的记录数，即行号，从 1 开始，有多个文件的话值也是不断累加的，用于最后可以输出总共的记录数。</li><li>FNR ：各文件分别计数, 行号，后跟一个文件和 NR 一样，跟多个文件，第二个文件行号从 1 开始</li><li>FILENAME ：当前文件名</li><li>ARGC ：命令行参数的个数</li><li>ARGV ：数组，保存的是命令行所给定的各参数，查看参数</li></ul><p>使用时要加 -v</p><p><strong>实例</strong><br>1.查看最近 5 条登录用户和 ip 地址，第一列是用户名，第三列是 IP </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ last -n 5 | awk <span class="string">'&#123;print $1"\t"$3&#125;'</span></span><br></pre></td></tr></table></figure><p>2.过滤文本，查看 /etc/passwd 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F <span class="string">":"</span> <span class="string">'&#123;print NR, $1, $5, $6&#125;'</span> OFS=<span class="string">"\t"</span> /etc/passwd <span class="comment"># OFS 指定输出格式</span></span><br></pre></td></tr></table></figure><p>3.统计 ip.txt 文件中出现次数最多的 ip， 文本第二个字段是 ip</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ip.txt | awk <span class="string">'NR!=1 &#123;if($2) print $2&#125;'</span> | sort | uniq -c | sort -nr | head -n 1</span><br><span class="line"><span class="comment"># uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用, -c 在每列旁边显示该行重复出现的次数。</span></span><br><span class="line"><span class="comment"># sort -n 是按照数值排序，否则会按字典序； sort -r 是倒序，由大到小排序</span></span><br><span class="line"><span class="comment"># NR!=1 去掉第一行，也就是 title；if($2) 保证非空</span></span><br></pre></td></tr></table></figure><p>4.统计文件中每个单词出现的次数，一行有多个单词，每个单词按照空格分割</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v RS=<span class="string">' '</span> <span class="string">'&#123;if($0) print&#125;'</span>  test1 | grep -v <span class="string">"^$"</span> | sort | uniq -c</span><br><span class="line"><span class="comment"># RS=' ' 按照空格切分，并遇到空格就换行；grep -v "^$" 去掉空白行，这个空白行是由于空格分割导致的</span></span><br></pre></td></tr></table></figure><p>如果每个单词占一行的话：<br><code>cat word.txt | sort | uniq -c</code></p><h4 id="awk-自定义变量"><a href="#awk-自定义变量" class="headerlink" title="awk 自定义变量"></a>awk 自定义变量</h4><p>使用 <code>-v var=value</code> 结构可以自定义变量，可以在 print 前后定义变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v name=<span class="string">"myname"</span> <span class="string">'&#123;print name, $NF&#125;'</span> test.txt</span><br><span class="line">$ awk <span class="string">'&#123;name="myname"; print name, $NF&#125;'</span> test.txt <span class="comment"># 直接在编程体中定义</span></span><br></pre></td></tr></table></figure><h3 id="awk-pattern-匹配"><a href="#awk-pattern-匹配" class="headerlink" title="awk pattern 匹配"></a>awk pattern 匹配</h3><ol><li><p>未指定，则匹配每一行</p></li><li><p>/regular expression/ ：仅处理能够模式匹配到的行，正则表达式需要用 <code>/ /</code> 括起来</p></li><li><p>relational expression：关系表达式，结果为“真”才会被处理，即非 0 非空</p></li><li><p>line ranges：行范围<br>startline(起始行), endline(结束行)：/pat1/,/pat2/  不支持直接给出数字，可以有多段，中间可以有间隔</p></li><li><p>BEGIN/END 模式<br><code>awk &#39;BEGIN{BEGIN 操作} {文件行处理块} END{END 操作}&#39; filepath</code></p></li></ol><ul><li>BEGIN 模块是在文件输入前执行的，不输入任何文件数据也会执行该模块，常用于设置修改内置变量如 OFS,RS 等，为用户自定义的变量赋初始值或者打印标题信息等。操作语句以 “;” 或分行隔开。BEGIN 可缺省。  </li><li>END 模块是处理完文件后的操作</li></ul><p><strong>实例</strong><br>1.正则匹配<br>~ 表示模式开始，/pattern/ 中间是模式，用 !~ // 表示模式取反</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'/80/&#123;print $4&#125;'</span> netstat.txt <span class="comment"># 匹配字段中有 80 的</span></span><br><span class="line">$ awk <span class="string">'$4 ~ /^c/&#123;print $4&#125;'</span> netstat.txt <span class="comment"># 第 4 列是以字母 c 开头的</span></span><br><span class="line">$ awk <span class="string">'$4 !~ /^c/&#123;print $4&#125;'</span> netstat.txt <span class="comment"># 第 4 列不是以字母 c 开头的</span></span><br><span class="line">$ awk <span class="string">'$6 ~ /FIN|WAIT/ || NR==1 &#123;print $4,$6&#125;'</span> netstat.txt <span class="comment"># 第 6 列包含 FIN 或 WAIT 的，并显示 titie，对第一行不做处理</span></span><br></pre></td></tr></table></figure><p>2.使用关系表达式<br><code>awk &#39;$0{print}&#39; file</code> 去掉空行 </p><p>3.统计每个用户的进程占了多少内存（计算 RSS 列）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | awk <span class="string">'NR!=1&#123;a[$1]+=$6;&#125; END &#123;for (i in a) print i "," a[i]"KB";&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="awk-高阶用法"><a href="#awk-高阶用法" class="headerlink" title="awk 高阶用法"></a>awk 高阶用法</h3><h4 id="条件语句-if-else"><a href="#条件语句-if-else" class="headerlink" title="条件语句 if-else"></a>条件语句 if-else</h4><p>if(condition){statement;…} else{statement}<br>if(condition1){statement1} else if(condition2){statement2} else{statement3}</p><p>1.使用 awk 拆分文件，可以使用重定向，如按照第 6 列拆分文件 NR!=1 表示不处理表头，文件名即为第 6 列的名字</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;if(NR!=1 &amp;&amp; $6) print &gt; $6&#125;'</span> netstat.txt</span><br></pre></td></tr></table></figure><p>2.复杂一点，可以使用 if-else if 语句，将符合某个条件的行划分到一个文本中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'NR!=1 &amp;&amp; $6 &#123;if($6 ~ /FIN|WAIT/) print &gt; 1.txt; </span></span><br><span class="line"><span class="string">      else if($6 ~ /LISTEN/) print &gt; 2.txt; </span></span><br><span class="line"><span class="string">      else print &gt; 3.txt&#125;'</span> netstat.txt</span><br></pre></td></tr></table></figure><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h5><p>语法 ：while(condition){statement;…}</p><p>使用场景 ：用于对一行内多个字段进行逐一处理，或对数组中的各元素逐一处理</p><p>1.以 : 分割，显示每一行长度大于 3 的单词及其长度</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F : <span class="string">'&#123;i=1; while(i&lt;NF)&#123;if(length($i)&gt;=3)&#123;print $i, length($i)&#125;; i++&#125;&#125;'</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>2.计算 1+2+3+…+100</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;i=1; sum=0; while(i&lt;=100)&#123;sum+=i; i++&#125;; print sum&#125;'</span></span><br></pre></td></tr></table></figure><h5 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h5><p>语法 ：for(expr1; expr2; expr3){statement;…}<br>遍历数组 ：for(var in array){statement;…} </p><p>显示每行每个单词的长度，按照空格分隔</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;for(i=1;i&lt;=NF;i++)&#123;print $i, length($i)&#125;&#125;'</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>sed 是一种流编辑器（stream editor），一次处理一行内容，是一个文本编辑工具，实现数据的替换，删除，增加，选取等。</p><p>原理：</p><ol><li>sed 将当前处理的行存储在临时缓冲区中，即模式空间(patternspace)</li><li>使用 sed 命令处理缓冲区中的内容</li><li>处理完成后，将缓冲区内容输出到屏幕，然后读下一行进行处理。</li></ol><h3 id="sed-格式和参数"><a href="#sed-格式和参数" class="headerlink" title="sed 格式和参数"></a>sed 格式和参数</h3><p><code>sed [options] &#39;[地址定界]动作&#39; filepath</code></p><p><strong>options：</strong></p><ul><li><code>-e &lt;script&gt;</code> ：直接在命令列模式上进行 sed 的动作编辑，可以用多个 -e ‘actions’ -e ‘actions’</li><li><code>-f &lt;script文件&gt;</code> ：将 sed 动作写在文件内，以指定的 script 来处理输入的文本</li><li>-i ：直接修改读取的文件内容，不输出到终端，也可选择将修改重定向到一个新的文件</li><li>-n ：使用安静模式，一般 sed 会将所有的输入都列出在终端，使用 -n 就只有被匹配处理过的行会显示出来</li><li>-r ：使用扩展的正则表达式</li></ul><p><strong>地址定界：</strong></p><ul><li>无地址 ：全文处理</li><li>单地址 ： <ul><li><code>#</code> ：指定的行</li><li><code>/pattern/</code> ：被此处模式所能够匹配到的每一行</li></ul></li><li>地址范围：<code>#,#</code>   <code>/pat1/,/pat2/</code>     <code>#,/pat1/</code></li><li>步长 ~：<ul><li><code>sed -n &#39;1~2p&#39;</code> ：只打印奇数行 （1~2 从第 1 行，一次加 2 行）</li><li><code>sed -n &#39;2~2p&#39;</code> ：只打印偶数行</li></ul></li></ul><p><strong>动作说明：</strong></p><ul><li>a ：新增，a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</li><li>i ：插入，在当前行之前插入文本。多行时除最后一行外，每行末尾需用”&quot;续行</li><li>d ：删除行</li><li>p ：打印，将某个选择的数据打印，通常和 sed -n 搭配使用</li><li>s ：替换，搭配正则表达式，如 ‘s/old/new/g’</li></ul><h3 id="sed-实例"><a href="#sed-实例" class="headerlink" title="sed 实例"></a>sed 实例</h3><p>1.在每行最前面或最后面添加 #</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/^/#/g'</span> filepath</span><br><span class="line">$ sed <span class="string">'s/$/#/g'</span> filepath</span><br></pre></td></tr></table></figure><p>2.指定需要替换的内容，允许多个匹配，用分号隔开</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'3s/old/new/g'</span> filepath <span class="comment"># 替换第 3 行的</span></span><br><span class="line">$ sed <span class="string">'3,6s/old/new/g'</span> filepath <span class="comment"># 替换第 3-6 行的</span></span><br><span class="line">$ sed <span class="string">'s/old/new/1'</span> filepath <span class="comment"># 替换每行的第一个</span></span><br><span class="line">$ sed <span class="string">'s/old/new/3g; xxx'</span> filepath <span class="comment"># 替换每行的第三个以后的</span></span><br><span class="line">$ sed <span class="string">'1~2s/old/new/g'</span> filepath <span class="comment"># 替换奇数行的 old</span></span><br></pre></td></tr></table></figure><p>3.使用 &amp; 表示被匹配的变量，在周围添加内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/my/[&amp;]/g'</span> filepath <span class="comment"># 将所有的 my 变为 [my]</span></span><br></pre></td></tr></table></figure><p>4.删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'2d'</span> filepath <span class="comment"># 删除第 2 行</span></span><br></pre></td></tr></table></figure><p>5.打印</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'2!p'</span> filepath <span class="comment"># 打印除了第 2 行的内容</span></span><br><span class="line">$ sed -n <span class="string">'1,3p'</span> filepath <span class="comment"># 打印第 1-3 行</span></span><br><span class="line">$ sed -n <span class="string">'/aaa/p'</span> filepath <span class="comment"># 打印包含 aaa 的行</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/along21/p/10366886.html#auto_id_15" target="_blank" rel="noopener">Linux文本三剑客超详细教程—grep、sed、awk</a><br><a href="https://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">AWK 简明教程</a><br><a href="https://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">SED 简明教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> grep </tag>
            
            <tag> awk </tag>
            
            <tag> sed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库连接池</title>
      <link href="/2019/09/20/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/2019/09/20/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>为了解决共享资源的频繁分配、释放的一些问题，有一个著名的设计模式：资源池。 将该模式应用到数据库连接管理领域，就是建立一个数据库连接池。</p><a id="more"></a><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个，这样可以使得一个数据库连接可以得到高效、安全的复用，避免了数据库频繁建立、关闭的开销，极大的节省了系统资源和时间。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>数据库连接池的基本原理是： 在内部对象池中维护一定数量的数据库连接，并对外暴露数据库连接获取和返回方法。一旦数据库连接建立后，不同的数据库访问请求就可以共享复用这些连接。</p><p>外部使用者可以通过 getConnection 方法从连接池中获取数据库连接，使用完毕后通过 releaseConnection 方法将连接返回池子，但此时连接并没有关闭，而是由连接池管理器回收，并为下一次使用做好准备。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>资源重用</li><li>更快的系统响应速度： 数据库连接池在初始化时，就已经创建了若干数据库连接置于池中备用，请求访问可以直接使用。</li><li>新的资源分配手段</li><li>统一的连接管理，避免数据库连接泄漏: 在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。</li></ol><h2 id="python-数据库连接池"><a href="#python-数据库连接池" class="headerlink" title="python 数据库连接池"></a>python 数据库连接池</h2><h3 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h3><p>python 中可以用 pymysql、MySQLdb 等进行数据库连接和增删查改操作，但每次请求连接 mysql 时，都是独立的请求访问，比较浪费资源，当请求达到一定数量时，对 mysql 的性能会产生较大影响，因此在 python 中可以使用数据库连接池包 DBUtils 来访问 mysql，从而达到资源复用的目的。</p><p>DBUtils 提供两种外部接口：</p><ul><li>PersistentDB：用于单线程，提供线程专用的数据库连接，并自动管理连接。</li><li>PooledDB： 用于多线程，提供线程间可共享的数据库连接，并自动管理连接。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> DBUtils.PooledDB <span class="keyword">import</span> PooledDB</span><br><span class="line"><span class="keyword">from</span> DBUtils.PersistentDB <span class="keyword">import</span> PersistentDB</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">'host'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">    <span class="string">'port'</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="string">'database'</span>: <span class="string">'student_course'</span>,</span><br><span class="line">    <span class="string">'user'</span>: <span class="string">'root'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'a123456'</span>,</span><br><span class="line">    <span class="string">'charset'</span>: <span class="string">'utf8'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_db_pool</span><span class="params">(is_mult_thread)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_mult_thread:</span><br><span class="line">        poolDB = PooledDB(</span><br><span class="line">            creator=pymysql, <span class="comment"># 指定数据库连接驱动</span></span><br><span class="line">            maxconnections=<span class="number">3</span>, <span class="comment"># 连接池允许的最大连接数,0 和 None 表示没有限制</span></span><br><span class="line">            mincached=<span class="number">2</span>, <span class="comment"># 初始化时,连接池至少创建的空闲连接,0 表示不创建</span></span><br><span class="line">            maxcached=<span class="number">5</span>, <span class="comment"># 连接池中空闲的最多连接数,0 和 None 表示没有限制</span></span><br><span class="line">            maxshared=<span class="number">3</span>, <span class="comment"># 连接池中最多共享的连接数量,0 和 None 表示全部共享</span></span><br><span class="line">            blocking=<span class="literal">True</span>, <span class="comment"># 连接池中如果没有可用共享连接后,是否阻塞等待,True 表示等待, False 表示不等待然后报错</span></span><br><span class="line">            setsession=[], <span class="comment"># 开始会话前执行的命令列表</span></span><br><span class="line">            ping=<span class="number">0</span>, <span class="comment"># ping Mysql 服务器检查服务是否可用</span></span><br><span class="line">            **config</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        poolDB = PersistentDB(</span><br><span class="line">            creator=pymysql, <span class="comment"># 指定数据库连接驱动</span></span><br><span class="line">            maxusage=<span class="number">1000</span>, <span class="comment"># 一个连接最大复用次数,0 或者 None 表示没有限制,默认为 0</span></span><br><span class="line">            **config</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> poolDB</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    db_pool = get_db_pool(<span class="literal">False</span>) <span class="comment"># 以单线程的方式初始化数据库连接池</span></span><br><span class="line">    conn = db_pool.connection() <span class="comment"># 从数据库连接池中取出一条连接</span></span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(<span class="string">'select * from sc'</span>) <span class="comment"># 执行 sql 语句</span></span><br><span class="line">    result = cursor.fetchall() <span class="comment"># 得到所有结果</span></span><br><span class="line">    print(result)</span><br><span class="line">    conn.close() <span class="comment"># 把连接返还给连接池</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5af026a06fb9a07ac47ff282" target="_blank" rel="noopener">数据库连接池的实现及原理</a><br><a href="https://blog.csdn.net/shuaihj/article/details/14223015" target="_blank" rel="noopener">谈谈数据库连接池的原理</a><br><a href="https://blog.csdn.net/zbc1090549839/article/details/51336458" target="_blank" rel="noopener">Python实现Mysql数据库连接池</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化测试之Selenium</title>
      <link href="/2019/09/14/test/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8BSelenium/"/>
      <url>/2019/09/14/test/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8BSelenium/</url>
      
        <content type="html"><![CDATA[<p>Selenium 是用于 web 应用的自动化测试工具，可以模拟浏览器操作，自动完成 web 基本任务管理。</p><a id="more"></a><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>适合自动化测试的情况：</p><ol><li>项目周期长且相对稳定</li><li>需要做频繁的冒烟测试</li><li>需要经常做回归测试</li><li>需要进行大数据量的数据驱动测试</li></ol><p>不适合自动化测试的情况：</p><ol><li>项目周期短，且用例不会多次重复执行</li><li>被测项目不稳定，变化频繁</li></ol><p>需要关注的指标：</p><ol><li>自动化测试用例的覆盖率</li><li>节省的时间成本 = 手工测试所花时间 - 自动化测试所花时间</li><li>自动化测试的投入</li><li>自动化测试发现的缺陷数</li><li>关键指标是： 自动化测试的投入产出比 ROI = (手工测试的成本 - 自动化测试的成本) / 自动化测试的成本，ROI 为正值且越大说明回报越好</li></ol><h2 id="Selenium-原理"><a href="#Selenium-原理" class="headerlink" title="Selenium 原理"></a>Selenium 原理</h2><p>selenium 的原理涉及到三个部分：</p><ol><li>WebDriver API，即 client，也就是写的代码</li><li>浏览器驱动 driver，也就是下载的 chromedriver.exe</li><li>浏览器</li></ol><h3 id="Selenium-执行流程"><a href="#Selenium-执行流程" class="headerlink" title="Selenium 执行流程"></a>Selenium 执行流程</h3><p>client 并不知道浏览器是如何工作的，可以通过 driver，实现 client 与浏览器之间的通信，client 根据 webdriver 协议发送请求给 driver，driver 解析请求，并在浏览器上执行相应的操作，并把执行结果返回给 client。具体如下：</p><ol><li>对于每一条 Selenium 脚本，一个 HTTP 请求会被创建并且发送给浏览器的驱动</li><li>浏览器驱动中包含了一个 HTTP Server，用来接收这些 HTTP 请求</li><li>HTTP Server 接收到请求后根据请求来具体操控对应的浏览器</li><li>浏览器执行具体的测试步骤</li><li>浏览器将步骤执行结果返回给 HTTP Server</li><li>HTTP Server 又将结果返回给 Selenium 的脚本，如果是错误的 HTTP 代码，控制台会显示相应的报错信息。</li></ol><h3 id="webdriver-协议"><a href="#webdriver-协议" class="headerlink" title="webdriver 协议"></a>webdriver 协议</h3><p>webdriver 基于的协议是 JSON Wire protocol，数据传输使用的是 json，JSON Wire protocol 是在 http 协议基础上，对 http 请求及响应的 body 部分的数据进一步规范。</p><p>在 client 和 server 之间，只要是基于 JSON Wire Protocol 来传递数据，无论 client 使用 java、python 还是其他语言实现，driver 都能处理相应的脚本。</p><h2 id="Selenium-的简单使用"><a href="#Selenium-的简单使用" class="headerlink" title="Selenium 的简单使用"></a>Selenium 的简单使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动浏览器</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 打开一个网页</span></span><br><span class="line">driver.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="comment"># 百度搜索 selenium</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(<span class="string">"selenium"</span>)</span><br><span class="line"><span class="comment"># 单击搜索按钮</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line"><span class="comment"># 后退</span></span><br><span class="line">driver.back()</span><br><span class="line"><span class="comment"># 前进</span></span><br><span class="line">driver.forward()</span><br><span class="line"><span class="comment"># 截图</span></span><br><span class="line">driver.save_screenshot(<span class="string">"baidu.png"</span>)</span><br><span class="line"><span class="comment"># 退出浏览器</span></span><br><span class="line">driver.close()</span><br><span class="line"><span class="comment">#关闭浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><ul><li>driver.quit(): 退出并关闭窗口的每一个相关的驱动程序</li><li>driver.close(): 关闭当前窗口</li></ul><h2 id="Python-webdriver-API"><a href="#Python-webdriver-API" class="headerlink" title="Python webdriver API"></a>Python webdriver API</h2><h3 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h3><p>webdriver 提供了一系列的对象定位方法，常用的有：</p><ul><li>find_element_by_id()，唯一</li><li>find_element_by_name()，唯一</li><li>find_element_by_class_name()</li><li>find_element_by_linx_text()， 操作对象是文字超链接</li><li>find_element_by_partial_link_text()，操作对象是文字超链接</li><li>find_element_by_tag_name()， 标签名</li><li>find_element_by_xpath()</li><li>find_element_by_css_selector()</li></ul><p>定位一组对象，用 find_elements，返回的是一个 list，可以用于批量操作对象，如选择复选框</p><ol><li>find_elements_by_tag_name()</li><li>find_element_by_css_selector()</li></ol><p>判断元素是否存在： 需要用元素定位和异常捕获的方法判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    driver.find_element_by_id(<span class="string">"none"</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">"element does not exist"</span>)</span><br></pre></td></tr></table></figure><p>注意： 在 selenium 中不能定位不可见元素，比如 hidden 和 display=none 的元素</p><h3 id="操作测试对象"><a href="#操作测试对象" class="headerlink" title="操作测试对象"></a>操作测试对象</h3><ul><li>clear() ：清除内容</li><li>click() ：鼠标点击</li><li>send_keys() ：向输入框输入</li><li>submit() ：提交表单</li></ul><h3 id="显式等待和隐式等待"><a href="#显式等待和隐式等待" class="headerlink" title="显式等待和隐式等待"></a>显式等待和隐式等待</h3><p>显示等待 WebDriverWait()：是针对某个特定元素设置的等待时间，在设置时间内，默认每隔一段时间检测一次当前页面某个元素是否存在，如果在规定的时间内找到了元素，则直接执行，即找到元素就执行相关操作，如果超过设置时间检测不到则抛出异常。</p><p>隐式等待 implicitly_wait()：是设置了全局等待，设置等待时间，是对页面中的所有元素设置加载时间，如果超出了设置时间的则抛出异常。隐式等待可以理解成在规定的时间范围内，浏览器在不停的刷新页面，直到找到相关元素或者时间结束。</p><p>强制等待 sleep()：也叫线程等待，设置固定休眠时间，执行 sleep() 后线程休眠，上面两种等待不会休眠。</p><h2 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h2><p>appium 是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web应用和混合应用。</p><ol><li>移动原生应用 native：用 iOS 或 Android SDK 写的应用</li><li>移动 web 应用 H5：使用移动浏览器访问的应用</li><li>混合应用：原生代码封装网页视图，原生代码和 web 内容交互</li></ol><p>appium 类库封装了标准 Selenium 客户端类库，实现了 Mobile JSON Wire Protocol</p><p>流程： 使用 python（client）编写一个 appium 自动化脚本并执行，首先会请求 appium-Server（mac 和 win 下不同），appium-Server 通过解析，驱动 Android 虚拟机或真机来执行 appium 脚本。</p><h3 id="元素定位-1"><a href="#元素定位-1" class="headerlink" title="元素定位"></a>元素定位</h3><p>可以使用 uiautomatorviewer 工具来查看控件的属性，定位方式与 selenium 相同，有 id、name、class_name、xpath 等方法。</p><h3 id="native-与-h5-切换"><a href="#native-与-h5-切换" class="headerlink" title="native 与 h5 切换"></a>native 与 h5 切换</h3><p>在混合开发的 app 中，原生应用可以通过 uiautomator 获取控件信息，而 h5 也就是 web 网页是 B/S 架构，两者的运行环境不同，因此需要进行上下文(context) 切换，再对 h5 页面元素进行定位操作。</p><p>切换到 h5，进行 h5 元素定位：</p><ol><li>导航到应用程序中 web 页面</li><li>获取上下文列表 driver.contexts，它返回一个我们可以访问的上下文列表，例如：NATIVE_APP 或 WEBVIEW_xxx</li><li>通过 driver.switch_to.context 切换到你要操作的 webview，原来是在 NATIVE_APP，切换到 WEBVIEW_xxx</li><li>操作完后，返回到原来的 app view</li></ol><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言是一些布尔表达式，当需要在一个值为 False 时中断当前操作的话，可以使用断言。</p><p>断言可以用于单元测试，判断到某个节点位置必须满足某些逻辑条件时才能继续运行下去，不满足程序就会崩溃或报错，这个时候就可以使用断言。</p><h3 id="断言与异常"><a href="#断言与异常" class="headerlink" title="断言与异常"></a>断言与异常</h3><ul><li>断言用于开发测试期间，是给程序员自己使用的；断言触发后程序崩溃退出，不需要从错误中恢复</li><li>异常在程序运行期间触发；异常通常会用 try/except/finally 等结构捕获异常，之后还能从错误中恢复继续运行</li></ul><h3 id="python-常用断言"><a href="#python-常用断言" class="headerlink" title="python 常用断言"></a>python 常用断言</h3><ul><li>assertEqual(a, b [, msg=’xxx’])： 断言 a 和 b 相等，msg 为测试失败时打印的信息； assertNotEqual(a, b)</li><li>assertIs(a, b [, msg=’xxx’]): 断言 a 是 b； assertNotIs(a, b)</li><li>assertIn(a, b [, msg=’xxx’])：断言 a 在 b 中； assertNotIn(a, b)</li><li>assertIsInstance(a, b [, msg=’xxx’])： 断言 a 是 b 的一个实例； assertNotIsInstance(a, b)</li><li>assertTrue(x [, msg=’xxx’])： 断言 x 为 True； assertFalse(x)</li><li>assertIsNone(x [, msg=’xxx’])： 断言 x 是 None； assertIsNotNone(x)</li></ul><h2 id="单元测试-unittest"><a href="#单元测试-unittest" class="headerlink" title="单元测试 unittest"></a>单元测试 unittest</h2><p><a href="#https://huilansame.github.io/huilansame.github.io/archivers/python-unittest">Python必会的单元测试框架 —— unittest</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁的产生和解决方法</title>
      <link href="/2019/09/07/%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2019/09/07/%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>当两个或两个以上的进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，造成死锁。</p><a id="more"></a><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><ol><li>互斥条件： 资源分配是排他性的，每个资源只能同时给一个进程使用</li><li>不可剥夺条件： 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，只能进程自己主动释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。</li></ol><h2 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h2><h3 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h3><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略，也就是忽略它。</p><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>死锁的预防是破坏死锁产生的四个必要条件之一，属于静态策略。</p><ol><li><p>互斥条件，是资源本身特点，不可避免</p></li><li><p>破坏不可剥夺条件： 采用 <strong>可剥夺资源</strong>，允许进程强行从占有者那里夺取某些资源。缺点是可能降低系统性能。、</p></li><li><p>破坏请求和保持条件： 采用 <strong>资源一次性分配</strong> ，所有进程在开始执行前请求所需要的全部资源。比如数据库中的<strong>一次封锁法</strong>。 缺点是进程执行是动态的，不可预测；资源利用率低；降低进程的并发性</p></li><li><p>破坏循环等待条件： 采用 <strong>资源有序分配</strong>，系统给进程编号，按某一顺序申请资源，释放资源则反序释放。 比如数据库中的<strong>顺序封锁法</strong>。 缺点是增加了系统的开销</p></li></ol><ul><li>一次封锁法：要求每个事务在开始执行时必须把需要访问的数据项全部加锁。</li><li>顺序封锁法：对数据库中的事务访问的所有数据项规定一个加锁顺序，每个事务在执行过程中必须按此顺序对所需的数据项加锁。</li></ul><h3 id="死锁避免（动态策略）"><a href="#死锁避免（动态策略）" class="headerlink" title="死锁避免（动态策略）"></a>死锁避免（动态策略）</h3><p>在进程在每次申请资源时，对其操作进行动态检查，根据检查结果决定是否分配资源，若在资源分配过程中预测有发生死锁的可能，则进行死锁的避免。关键是确定资源分配的安全性。</p><h4 id="1-安全状态"><a href="#1-安全状态" class="headerlink" title="1. 安全状态"></a>1. 安全状态</h4><p>系统中的所有进程按照某一调度次序分配资源，并且进程能够依次运行完毕，那这种进程序列 {P1，P2，…，Pn} 是一个安全序列，此时系统处于安全状态，这种情况不会发生死锁。如果发生死锁，那么系统一定处于不安全状态。</p><p>在安全序列中，系统当前可用资源 + 前一个进程 P[i] 所释放的资源能够 &gt;= P[i+1] 还需要的资源</p><p>系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配后系统处于安全状态，则将资源分配给进程；否则，令进程等待。</p><h4 id="2-银行家算法"><a href="#2-银行家算法" class="headerlink" title="2. 银行家算法"></a>2. 银行家算法</h4><p>银行家算法是一种避免死锁的算法，实质是设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。</p><h5 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h5><p>问题描述：<br>一个银行家拥有一定数量的资金，有若干个客户要贷款。每个客户须在一开始就声明他所需贷款的总额。若该客户贷款总额不超过银行家的资金总数，银行家可以接收客户的要求。客户在借满所需的全部单位款额之前可能会等待，但银行家须保证这种等待是有限的，可完成的。</p><p>银行家算法是从当前状态出发，逐个按安全序列检查各客户谁能完成其工作，然后假定其完成工作且归还全部贷款，再进而检查下一个能完成工作的客户，也就是说是算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p>缺点：</p><ol><li>要求客户数保持固定不变，这在多道程序系统中难以做到   </li><li>要保证所有客户在有限的时间内得到满足，但实时客户要求快速响应，可能难以快速响应  </li><li>寻找一个安全序列会增加系统的开销</li></ol><h5 id="多个资源的银行家算法"><a href="#多个资源的银行家算法" class="headerlink" title="多个资源的银行家算法"></a>多个资源的银行家算法</h5><p>n 个进程 m 个资源。</p><p>检查一个状态是否安全的算法如下：</p><ol><li>查找需求矩阵中是否存在一行小于等于剩余可用资源。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到可用资源中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。如果一个状态不是安全的，需要拒绝进入这个状态。</li></ol><h3 id="死锁的检测与恢复"><a href="#死锁的检测与恢复" class="headerlink" title="死锁的检测与恢复"></a>死锁的检测与恢复</h3><p>由于操作系统有并发、共享及随机性等特点，通过死锁预防和死锁避免需要较大的系统开销，且不能充分利用资源，因此这样难以达到排除死锁的目的。</p><p>死锁的检测：建立资源分配表和进程等待表。</p><p>死锁的恢复：从其他进程强制剥夺资源给死锁进程；可以直接撤销死锁进程，或撤销代价最小的进程；回退策略。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/abigale1011/article/details/6450845" target="_blank" rel="noopener">什么是死锁及死锁的必要条件和解决方法</a><br><a href="https://blog.csdn.net/qq_28602957/article/details/53508447" target="_blank" rel="noopener">【操作系统】处理死锁的方法</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 死锁 </tag>
            
            <tag> 银行家算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 正则表达式</title>
      <link href="/2019/09/05/linux/Linux-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/09/05/linux/Linux-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在 linux 中，常用的正则表达式引擎有：</p><ul><li>POSIX 基本正则表达式（BRE）引擎，grep 使用</li><li>POSIX 扩展正则表达式（ERE）引擎，grep -E 使用</li></ul><a id="more"></a><h2 id="linux-正则表达式的元字符"><a href="#linux-正则表达式的元字符" class="headerlink" title="linux 正则表达式的元字符"></a>linux 正则表达式的元字符</h2><blockquote><p><code>. * [ ] ^ $ { } + ? | ( )</code></p></blockquote><h3 id="BRE-和-ERE-通用元字符"><a href="#BRE-和-ERE-通用元字符" class="headerlink" title="BRE 和 ERE 通用元字符"></a>BRE 和 ERE 通用元字符</h3><p><code>\</code> : 转义，将元字符当做普通字符，如 <code>\(...\)与\{...\}</code></p><p><code>.</code> : 匹配任意单个字符（除 NULL）</p><p><code>*</code> : 匹配前一个字符 0 次或多次，如 <code>.*</code> 匹配任意字符的任意长度</p><p><code>^</code> : 开头定位，匹配以后面字符开头的行</p><p><code>$</code> : 结尾定位，匹配以前面字符结尾的行</p><p><code>[]</code> : 匹配方括号内的任意字符，其中可用连字符（-）指的连续字符的范围； 可以用 <code>^</code> 符号表示匹配不在列表中的任一字符，匹配数字 <code>[0-9]</code>，匹配非数字 <code>[^0-9]</code>。</p><h3 id="BRE-特有元字符"><a href="#BRE-特有元字符" class="headerlink" title="BRE 特有元字符"></a>BRE 特有元字符</h3><p><code>\{n, m\}</code> : 区间表达式，匹配前面一个字符 n 到 m 次，<code>\{n\}</code> 匹配 n 次</p><h3 id="ERE-特有元字符"><a href="#ERE-特有元字符" class="headerlink" title="ERE 特有元字符"></a>ERE 特有元字符</h3><p>相比于 BRE，使用 ERE 更加方便，建议以后使用 grep -E 来进行正则匹配<br><code>{n, m}</code> ： 区间表达式，匹配前面一个字符 n 到 m 次，<code>{n}</code> 匹配 n 次， <code>{n,}</code> 匹配 n 次以上</p><p><code>+</code> : 匹配前一个字符 0 次或多次</p><p><code>?</code> : 匹配前一个字符 0 次或 1 次</p><p><code>|</code> : 表示 “或” ，实现多个正则表达式的匹配，匹配其中之一</p><p><code>()</code> : 匹配括号括起来的正则表达式群</p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li>[[:alnum:]] 所有字母与数字； [[:alpha:]] 所有字母； [[:digit:]] 所有数字  </li><li>[[:blank:]] 所有水平空格； [[:space:]] 所有水平与垂直空格符； [[:punct:]] 所有标点符号  </li><li>[[:graph:]] 所有可打印字符（不包含空格）； [[:print:]] 所有可打印字符(包含空格)  </li><li>[[:upper:]] 所有大写字母； [[:lower:]] 所有小写字母</li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 会在文本文件中查找一个指定的正则表达式，并把匹配行输出到标准输出。</p><p><code>grep [options] regex [file...]</code> 其中 regex 即正则表达式</p><h3 id="grep-参数"><a href="#grep-参数" class="headerlink" title="grep 参数"></a>grep 参数</h3><p>-c 显示符合要求的行的个数；<br>-i 忽略大小写；<br>-n 输出行号；<br>-v 反向输出，也就是不匹配的内容；<br>-o 只显示被匹配到的字符串；<br>-f &lt;规则文件&gt; 查找符合指定规则文件的内容，格式为每行一个规则样式<br>-E 使用扩展正则表达式进行匹配</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol><li><p>匹配空行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'^$'</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><p>查找文件 test 中有三个数字连在一起的行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -n -E <span class="string">'[0-9][0-9][0-9]'</span> <span class="built_in">test</span> <span class="comment"># -n 显示行号，-E 可以省略，grep 查找可以省略 ''</span></span><br><span class="line">grep -n -E <span class="string">'[0-9]&#123;3&#125;'</span> <span class="built_in">test</span> <span class="comment"># 不能省略 -E，需要用扩展的正则</span></span><br><span class="line">grep -n -E <span class="string">'[[:digit:]]&#123;3&#125;'</span> test2 <span class="comment"># 用字符集</span></span><br></pre></td></tr></table></figure></li><li><p>查找 good 或 glad</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">'g(oo|la)d'</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 多线程爬虫</title>
      <link href="/2019/08/31/python/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB/"/>
      <url>/2019/08/31/python/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<p>爬虫主要运行时间消耗是请求网页时的 IO 阻塞，使用多线程能够让不同请求的等待同时进行，从而提高爬虫运行效率。</p><a id="more"></a><p>基于多线程（这里开启了10个线程），使用 github 的 api，抓取 fork cpython 项目的信息，并将数据存储到 json 文件中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计时用的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func(*args, **kw)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'running'</span>, end-start, <span class="string">'s'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.qurl = Queue()</span><br><span class="line">        self.data = list()</span><br><span class="line">        self.email = <span class="string">'xxx'</span> <span class="comment"># 登录github用的邮箱</span></span><br><span class="line">        self.password = <span class="string">'xxx'</span> <span class="comment"># 登录github用的密码</span></span><br><span class="line">        self.page_num = <span class="number">120</span></span><br><span class="line">        self.thread_num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">produce_url</span><span class="params">(self)</span>:</span></span><br><span class="line">        baseurl = <span class="string">'https://api.github.com/repos/python/cpython/forks?page=&#123;&#125;'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, self.page_num + <span class="number">1</span>):</span><br><span class="line">            url = baseurl.format(i)</span><br><span class="line">            self.qurl.put(url) <span class="comment"># 生成URL存入队列，等待其他线程提取</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.qurl.empty(): <span class="comment"># 保证url遍历结束后能退出线程</span></span><br><span class="line">            url = self.qurl.get() <span class="comment"># 从队列中获取URL</span></span><br><span class="line">            print(<span class="string">'crawling'</span>, url)</span><br><span class="line">            req = requests.get(url, auth = (self.email, self.password))</span><br><span class="line">            data = req.json()</span><br><span class="line">            <span class="keyword">for</span> datai <span class="keyword">in</span> data:</span><br><span class="line">                result = &#123;</span><br><span class="line">                    <span class="string">'project_name'</span>: datai[<span class="string">'full_name'</span>],</span><br><span class="line">                    <span class="string">'project_url'</span>: datai[<span class="string">'html_url'</span>],</span><br><span class="line">                    <span class="string">'project_api_url'</span>: datai[<span class="string">'url'</span>],</span><br><span class="line">                    <span class="string">'star_count'</span>: datai[<span class="string">'stargazers_count'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                self.data.append(result)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @run_time</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.produce_url()</span><br><span class="line"></span><br><span class="line">        ths = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.thread_num):</span><br><span class="line">            th = Thread(target=self.get_info)</span><br><span class="line">            th.start()</span><br><span class="line">            ths.append(th)</span><br><span class="line">        <span class="keyword">for</span> th <span class="keyword">in</span> ths:</span><br><span class="line">            th.join()</span><br><span class="line"></span><br><span class="line">        s = json.dumps(self.data, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'github_thread.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(s)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'Data crawling is finished.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Spider().run()</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://juejin.im/post/5b0951ab51882538ac1ce3c8" target="_blank" rel="noopener">https://juejin.im/post/5b0951ab51882538ac1ce3c8</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 协程</title>
      <link href="/2019/08/25/python/Python-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2019/08/25/python/Python-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>协程 Coroutine，也叫微线程，是一种比线程更加轻量级的存在，一个线程可以有多个协程。</p><a id="more"></a><h2 id="协程概述"><a href="#协程概述" class="headerlink" title="协程概述"></a>协程概述</h2><p>协程的执行过程中在子程序内部可以中断，转而执行其他子程序（不是调用），在适当的时候再返回来执行。  </p><p><strong>特点</strong> ：只有一个线程执行。  </p><p><strong>优势</strong></p><ol><li>执行效率高，由于子程序切换不是由线程，而是由程序自身控制，因此没有线程切换的消耗</li><li>不需要多线程的锁机制，由于只有一个线程，不存在同时写变量冲突，协程中控制共享资源不加锁。  </li></ol><ul><li>线程由操作系统控制</li><li>协程由程序自身控制</li></ul><h2 id="python-实现协程"><a href="#python-实现协程" class="headerlink" title="python 实现协程"></a>python 实现协程</h2><p>python 中实现协程大概经过三个阶段</p><ol><li>最初的生成器变形 yield/send </li><li>在 python3.4 中引入 @asyncio.coroutine 和 yield from </li><li>在 python3.5 中引入 async/await 关键字</li></ol><h3 id="yield-send"><a href="#yield-send" class="headerlink" title="yield/send"></a>yield/send</h3><p>python 生成器的 yield 可以在一定程度上实现协程。</p><p>传统的生产者/消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但容易造成死锁。</p><p>使用协程，在生产者生产消息后，直接通过 yield 跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 等待接收数据</span></span><br><span class="line">        num = <span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">'consuming '</span>, num)</span><br><span class="line"></span><br><span class="line">consumer = consume()</span><br><span class="line">next(consumer) <span class="comment"># 得先 next 才能 send，否则会报错，也可以用 consumer.send(None)</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    print(<span class="string">'start producting '</span>, n)</span><br><span class="line">    consumer.send(n)</span><br></pre></td></tr></table></figure><p>主线程中创建了一个 consumer 协程，并在主线程中产生数据，协程中消费数据，输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start producting  0</span><br><span class="line">consuming  0</span><br><span class="line">start producting  1</span><br><span class="line">consuming  1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="asyncio-yield-from"><a href="#asyncio-yield-from" class="headerlink" title="asyncio/yield from"></a>asyncio/yield from</h3><p>先来看 yield 和 yield from 的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> range(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = generator1()</span><br><span class="line">g2 = generator2()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> g1:</span><br><span class="line">    print(x)</span><br><span class="line"><span class="comment"># range(0, 5)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> g2:</span><br><span class="line">    print(x)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>range(5) 是一个可迭代对象，yield 和 yield from 后边接可迭代对象时，yield 是 直接 yield 的是可迭代对象，而 yield from 是将可迭代对象中的元素一个一个yield出来。</p><p>asyncio 是一个基于事件循环的实现异步 IO 的模块，使用 @asyncio.coroutine 可以把一个 generator 标记为 coroutine 类型，然后在 coroutine 内部用 yield from 调用另一个 coroutine 实现异步操作。</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>在 python 3.5 以后， async/await 成为了实现协程更好的替代方案。<br>async/await 让协程表面上独立于生成器存在，将细节都隐藏于 asyncio 模块下，语法更清晰明了。</p><p>在一个普通函数前加 async 关键字，可以将其变成协程。注意，async 无法将一个生成器转化为协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio, random</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">my_coroutine</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> len(alist) &gt; <span class="number">0</span>:</span><br><span class="line">        c = random.randint(<span class="number">0</span>, len(alist)<span class="number">-1</span>)</span><br><span class="line">        print(alist.pop(c))</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    loop = asyncio.get_event_loop() <span class="comment">#运行协程用事件循环，可以看到交替执行的结果</span></span><br><span class="line">    strs = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">    ints = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    c1 = my_coroutine(strs)</span><br><span class="line">    c2 = my_coroutine(ints)</span><br><span class="line">    tasks = [c1, c2]</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(<span class="string">'All task finished.'</span>)</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">a</span><br><span class="line">3</span><br><span class="line">c</span><br><span class="line">2</span><br><span class="line">b</span><br><span class="line">All task finished.</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/soonfly/article/details/78361819" target="_blank" rel="noopener">理解Python协程:从yield/send到yield from再到async/await</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 迭代器与生成器</title>
      <link href="/2019/08/23/python/Python-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2019/08/23/python/Python-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>在 python 中，生成器 generator 可以实现一遍循环一遍计算，是一种惰性计算，也就是在真正需要的时候才计算结果，这样可以节省空间，避免不必要的计算，从而提升性能。</p><a id="more"></a><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可迭代对象 Iterable： 能够直接作用于 for 循环的对象，如 list、tuple、dict、set、str、file、generator<br>迭代器 Iterator： 可以被 next() 函数调用并不断返回下一个值的对象</p><p>生成器是 Iterator 对象，但 list、 dict、 str 虽然都是 Iterable，但不是 Iterator， 可以用 iter() 方法将其变成 Iterable 类型。</p><p>Python 的 Iterator 对象表示的是一个数据流，Iterator 对象可以被 next() 函数调用并不断返回下一个数据，直到没有数据时抛出 StopIteration 错误。可以把这个数据流看做是一个有序序列甚至是无限大的数据流，只能不断通过 next() 函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><h3 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h3><p>如果一个容器类提供了 <code>__iter__()</code> 方法，并且该方法能返回一个能够逐个访问容器内所有元素的迭代器，则我们说该容器类实现了迭代器协议。</p><p>for 循环的本质是不断调用 next()。</p><p>Python 处理 for 循环时，首先会调用内建函数 iter(something)，它实际上会调用 <code>something.__iter__()</code>，返回 something 对应的迭代器。而后，for 循环会调用内建函数 next()，作用在迭代器上，获取迭代器的下一个元素，并赋值给 x。此后，Python 才开始执行循环体。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>迭代器是一个更加抽象的概念，生成器是一个迭代器对象，是创建迭代器的简单而强大的工具。</p><p>python 中提供两种方式来构造生成器： 生成器表达式和生成器函数。</p><h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>将列表的 [] 改为 ()，就是一个生成器表达式，生成器需要通过调用 next(g) 来获得其下一个返回值，直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">print(l) <span class="comment"># [0, 1, 4, 9, 16]，使用列表推导，会一次产生所有结果</span></span><br><span class="line"></span><br><span class="line">g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">print(g) <span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x000002590811D830&gt;</span></span><br><span class="line">print(next(g)) <span class="comment"># 0</span></span><br><span class="line">print(next(g)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>实际上我们在用生成器时，并不会去调用 next()，因为生成器实现了迭代器协议，是一个可迭代对象，因此可以通过 for 循环来迭代，不用考虑 StopIteration 的异常。如果生成器推导较复杂，则可以通过生成器函数来完成。</p><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><p>带有 yield 关键词的函数是一个生成器函数，可以用于迭代。 yield 类似于 return，迭代一次遇到 yield 就返回 yield 后面的值，并记住这个返回位置，下一次迭代就从遇到 yield 的下一行开始执行。注意，<strong>每次从暂停恢复时，生成器函数的内部变量、指令指针、内部求值栈等内容和暂停时完全一致。</strong></p><p>与普通函数不同，生成器函数被调用后，其函数体内的代码不会立即执行，而是返回一个生成器。当生成器调用成员方法时，相应生成器函数中的代码才会执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> i ** <span class="number">2</span></span><br><span class="line">g = my_generator() <span class="comment"># &lt;class 'generator'&gt;</span></span><br><span class="line"><span class="comment"># for x in g:</span></span><br><span class="line"><span class="comment">#     print(x) # 0,1,4,9</span></span><br><span class="line">print(next(g)) <span class="comment"># 0</span></span><br><span class="line">print(g.__next__()) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h3 id="generator-send-value"><a href="#generator-send-value" class="headerlink" title="generator.send(value)"></a>generator.send(value)</h3><p>generator.send(value) 方法可以将上一次被挂起的 yield 表达式的值设置为 value，也就可以与生成器函数进行通信，这是使用 yield 在 python 中使用协程的基础。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        y = <span class="keyword">yield</span> i ** <span class="number">2</span></span><br><span class="line">        print(y)</span><br><span class="line">g = my_generator() <span class="comment"># &lt;class 'generator'&gt;</span></span><br><span class="line">print(next(g)) <span class="comment"># 0</span></span><br><span class="line">print(g.send(<span class="number">30</span>)) <span class="comment"># 先是 y = 30，再 print(30)，接着再继续 for 循环， i == 1，yield 会返回 1，因此打印 1</span></span><br><span class="line">print(next(g)) <span class="comment"># 因为会从上一次 yield 的下一行开始执行，也就是 print(y)，但是这时候 y 并没有值，因此会打印 None，接着再继续 for 循环，i == 2</span></span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">30</span><br><span class="line">1</span><br><span class="line">None</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>注意： 在一个生成器对象没有执行 next 之前，由于没有 yield 被挂起，那么此时如果执行 send 会报错。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://liam.page/2017/06/30/understanding-yield-in-python/" target="_blank" rel="noopener">Python 中的黑暗角落（一）：理解 yield 关键字</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 装饰器</title>
      <link href="/2019/08/19/python/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2019/08/19/python/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>python 中的函数与 java、c++ 中不同之处在于： python 中的函数可以作为变量当做参数传入另一个函数中。装饰器 Decorator 本质上就是一个 python 函数，可以让其他函数在不需要任何代码变动的前提下增加额外功能。  </p><a id="more"></a><p>有了装饰器，就可以抽离出大量与函数本身功能无关的雷同代码到装饰器中并继续重用，也就是能够给函数增加额外的功能。装饰器的返回值是一个函数对象。</p><p>常用场景：插入日志、性能测试、事务处理、缓存、权限校验等。 </p><p>首先来看一个简单的例子： 如果有两个函数 foo1 和 foo2 都要实现在进入函数主体前，先处理日志的功能，那么我们可能会新定义一个函数 use_logging 来专门处理，这样 foo1 和 foo2 就只需要调用 use_logging，其他函数有需要也可以重用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    logging.warning(<span class="string">"%s is running"</span> % func.__name__) <span class="comment"># logging 的默认设置 warn 会输出，info 不会</span></span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo1'</span>)</span><br><span class="line"></span><br><span class="line">use_logging(foo1)</span><br><span class="line"><span class="comment"># WARNING:root:foo1 is running</span></span><br><span class="line"><span class="comment"># i am foo1</span></span><br></pre></td></tr></table></figure><p>这样看起来达到了我们的目的，实现了函数运行前先处理日志的功能，但是每次我们调用的是 use_logging 函数，而真正的业务逻辑是在 foo1 中，这样破坏了原有的代码结果，我们希望是能够直接调用 foo1 函数，这就可以用到装饰器来实现。</p><h3 id="简单的装饰器"><a href="#简单的装饰器" class="headerlink" title="简单的装饰器"></a>简单的装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        logging.warning(<span class="string">"%s is running"</span> % fun.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo1'</span>)</span><br><span class="line"></span><br><span class="line">f = use_logging(foo1) <span class="comment"># use_logging 是一个装饰器，返回的是 wrapper，这里相当于是 f=wrapper</span></span><br><span class="line">f() <span class="comment"># 也就是执行 wrapper()，然后返回 func()，就是执行 foo1()</span></span><br></pre></td></tr></table></figure><p>在这里 use_logging 装饰器把执行真正业务逻辑的函数 func 包裹在里面，也就是 foo1 被 use_logging 所装饰。 在这个例子中，函数进入和退出时 ，被称为一个横切面，这种编程方式被称为面向切面的编程。</p><h3 id="使用语法糖"><a href="#使用语法糖" class="headerlink" title="使用语法糖 @"></a>使用语法糖 @</h3><p>语法糖： 指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p><p>@ 符号是装饰器的语法糖，放在函数定义之前，这样就不需要赋值，直接调用 foo1() 即可，这样 foo1() 不需要做任何修改，就可以增加额外的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'i am foo1'</span>)</span><br><span class="line">foo1()</span><br></pre></td></tr></table></figure><h3 id="args、-kwargs"><a href="#args、-kwargs" class="headerlink" title="*args、 **kwargs"></a>*args、 **kwargs</h3><p>如果业务逻辑函数 foo1 需要带参数，就可以给装饰器里的 wrapper 带上同样的参数，但可能有多个带有不同参数的函数需要使用装饰器 use_logging 的话，就可以使用 <code>*args，**kwargs</code> 来定义，这样不管 foo1 带有多少个参数，都可以完整的传到 func 中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line"><span class="keyword">return</span> func(*args, **kwargs) <span class="comment"># 可以让其用于任何函数，无论参数形式如何</span></span><br><span class="line"><span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>在上面的装饰器中，我们只给装饰器传入了一个参数，也就是要执行的业务逻辑函数 func，但如果我们在调用装饰器时，想要加上其他参数，比如可以给日志定义级别，因为不同业务逻辑需要的日志级别可能不同，这时我们就可以给装饰器加上参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">'warn'</span>:</span><br><span class="line">                logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">elif</span> level == <span class="string">'error'</span>:</span><br><span class="line">                logging.error(<span class="string">"%s has error"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(level="warn")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(name, msg)</span>:</span></span><br><span class="line">    print(<span class="string">'i am %s, %s'</span> %(name, msg))</span><br><span class="line"></span><br><span class="line">foo1(<span class="string">'foo1'</span>, <span class="string">'hello!'</span>)</span><br></pre></td></tr></table></figure><p>这个带参数的装饰器实际上只是在原有装饰器的基础上再套上一层，是对原有装饰器的一个函数封装，并返回一个装饰器。</p><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>相比于函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。</p><p>类装饰器使用类的 <code>__call__</code> 方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'class decorator runing'</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'class decorator ending'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Decor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><h3 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h3><p>使用装饰器会使得原函数的一些元信息消失，比如 <code>__name__</code>, <code>__doc__</code> 会被装饰器的替代。比如之前的装饰器在最后打印 <code>print(foo1.__name__)</code>，得到的是 wrapper，而不是 foo1.</p><p>可以使用 functools.wraps 来进行装饰器修复，wraps 本身是一个装饰器，能够把原函数的元信息拷贝到装饰器里的 func 函数中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps <span class="comment"># 导入模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func) # 使用 wraps，记得要传入 func</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(level="warn")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(name, msg)</span>:</span></span><br><span class="line">    print(<span class="string">'i am %s, %s'</span> %(name, msg))</span><br><span class="line"></span><br><span class="line">foo1(<span class="string">'foo1'</span>, <span class="string">'hello!'</span>)</span><br><span class="line">print(foo1.__name__) <span class="comment"># foo1, 如果不加 @wraps(func)，打印出的是 wrapper</span></span><br></pre></td></tr></table></figure><h3 id="装饰器执行顺序"><a href="#装饰器执行顺序" class="headerlink" title="装饰器执行顺序"></a>装饰器执行顺序</h3><p>一个函数可以定义多个装饰器，执行顺序是从里到外，先调用最靠近函数的装饰器，下面的装饰器执行顺序为 c、b、a，也就是 foo = a(b(c(foo)))</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="常用内置装饰器"><a href="#常用内置装饰器" class="headerlink" title="常用内置装饰器"></a>常用内置装饰器</h3><ol><li>@staticmethod</li><li>@classmethod</li><li>@property<br>可以把类中的一个方法当做属性使用，调用时就只要 a.func, 而不用 a.func()。<br>被修饰的特性方法，内部可以实现处理逻辑，但对外提供统一的调用方式，遵循了统一访问的原则。</li></ol><p>在给一个类的属性比如分数 score 初始化时，为了限制它的范围，我们可以给它加上 set_score()、 get_score() 方法，然后在调用时通过 s.get_score(60) 来设置大小，get_score() 来获取值，但是这样调用又略显复杂，没有直接用属性那么简单。python 的 @property 装饰器就可以把方法变成一个属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">60</span> <span class="comment"># 相当于是 s.get_score(60)</span></span><br><span class="line">s.score = <span class="string">'a'</span> <span class="comment"># ValueError: score must be an integer!</span></span><br><span class="line">s.score = <span class="number">101</span> <span class="comment"># ValueError: score must be an integer!</span></span><br></pre></td></tr></table></figure><p>@property 本身创建了一个装饰器 @score.setter，负责把一个 setter 方法变成属性赋值，实际上就相当于之前自己定义的 set_score(); 当然也有一个 @score.getter 装饰器用来获取属性值。</p><ol start="4"><li>functools.wraps<br>用在装饰器的代码里。可以把原始函数的<code>__name__</code>等属性复制到 wrapper() 函数中，这样就可以获取到真实函数的<code>__name__</code>属性，而不是 wrapper。</li></ol><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包就是能够读取其他函数内部变量的函数，可以理解为定义在一个函数内部的函数，外部的叫外函数，内部的叫内函数。</p><p>在一个外函数中定义了一个内函数，内函数用到了外函数的临时变量，外函数的返回值是内函数的引用，这就构成了闭包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(a)</span>:</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(x)</span>:</span></span><br><span class="line">print(a * x + b) <span class="comment"># a,b 是 outer 的临时变量</span></span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">demo = outer(<span class="number">1</span>)</span><br><span class="line">demo(<span class="number">2</span>) <span class="comment"># 输出 1*2+10 = 12</span></span><br></pre></td></tr></table></figure><p>若要在内函数中修改闭包变量（外函数绑定给内函数的局部变量）：</p><ol><li>在 python3 中，用 nonlocal 关键字申明变量，表示这个变量不是局部变量空间的，需要向上一层变量空间中寻找该变量</li><li>在 python2 中，没有 nonlocal 关键字，但可以把闭包变量改为可变类型数据进行修改，如 set、list、dict</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(a)</span>:</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = [a]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">nonlocal</span> b</span><br><span class="line">b += <span class="number">1</span> <span class="comment"># 方法1</span></span><br><span class="line">c[<span class="number">0</span>] += <span class="number">1</span> <span class="comment"># 方法2</span></span><br><span class="line">print(b, c[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">demo = outer(<span class="number">1</span>)</span><br><span class="line">demo() <span class="comment"># 输出 11, 2</span></span><br></pre></td></tr></table></figure><p>在使用闭包的过程中，一旦外函数被调用一次返回了内函数的引用，虽然每次调用内函数，是开启一个函数执行过后消亡，但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(b)</span>:</span></span><br><span class="line"><span class="keyword">nonlocal</span> a</span><br><span class="line">a += b</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">demo = outer(<span class="number">1</span>)</span><br><span class="line">demo(<span class="number">2</span>) <span class="comment"># 输出 1+2=3</span></span><br><span class="line">demo(<span class="number">3</span>) <span class="comment"># 输出 3+3=6</span></span><br></pre></td></tr></table></figure><h3 id="装饰器实战"><a href="#装饰器实战" class="headerlink" title="装饰器实战"></a>装饰器实战</h3><h4 id="装饰器为访问页面添加登录验证功能"><a href="#装饰器为访问页面添加登录验证功能" class="headerlink" title="装饰器为访问页面添加登录验证功能"></a>装饰器为访问页面添加登录验证功能</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义用户字典</span></span><br><span class="line">users = &#123;<span class="string">'xieyiyu'</span>: <span class="string">'123456'</span>,</span><br><span class="line">         <span class="string">'lily'</span>: <span class="string">'123'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化当前用户名，无用户名，登录状态为 False</span></span><br><span class="line">current_user = &#123;<span class="string">'username'</span>: <span class="literal">None</span>, <span class="string">'login'</span>: <span class="literal">False</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth_deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 若已经登录，执行基本函数</span></span><br><span class="line">        <span class="keyword">if</span> current_user[<span class="string">'username'</span>] <span class="keyword">and</span> current_user[<span class="string">'login'</span>]:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 若未登录，提示用户输入用户名和密码</span></span><br><span class="line">        username = input(<span class="string">'请输入用户名：'</span>).strip()</span><br><span class="line">        passwd = input(<span class="string">'请输入密码：'</span>).strip()</span><br><span class="line">        <span class="comment"># 验证用户名和密码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> username <span class="keyword">not</span> <span class="keyword">in</span> users.keys():</span><br><span class="line">            print(<span class="string">'用户名不存在'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> passwd == users[username]: <span class="comment"># 登录成功，将 current_user 设置为该用户</span></span><br><span class="line">                current_user[<span class="string">'username'</span>] = username</span><br><span class="line">                current_user[<span class="string">'login'</span>] = <span class="literal">True</span></span><br><span class="line">                print(<span class="string">'登录成功'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'用户名或密码输入错误，请重新登录'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth_deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span> <span class="comment"># 在进入页面前先校验用户是否登录了</span></span><br><span class="line">    <span class="keyword">if</span> current_user[<span class="string">'username'</span>]:</span><br><span class="line">        print(<span class="string">'你好, %s'</span> %current_user[<span class="string">'username'</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'请先登录'</span>)</span><br><span class="line"></span><br><span class="line">index()</span><br></pre></td></tr></table></figure><h4 id="用装饰器实现数据库连接"><a href="#用装饰器实现数据库连接" class="headerlink" title="用装饰器实现数据库连接"></a>用装饰器实现数据库连接</h4><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://foofish.net/python-decorator.html" target="_blank" rel="noopener">理解 Python 装饰器看这一篇就够了</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python decimal 模块</title>
      <link href="/2019/08/10/python/Python-decimal-%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/08/10/python/Python-decimal-%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>python 中的 decimal 模块提供十进制浮点运算支持。</p><a id="more"></a><p>我们先来看下直接对两个浮点数进行运算得到的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1.1</span></span><br><span class="line">b = <span class="number">2.2</span></span><br><span class="line">print(a + b) <span class="comment"># 输出 3.3000000000000003</span></span><br></pre></td></tr></table></figure><p>输出不是期望的 3.3，这是由于原生的二进制浮点数本身存在误差，直接计算的话会得到不精确的结果。 为了消除这种误差，可以用 decimal 模块进行更加精确的浮点计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line">a = Decimal(<span class="string">'1.1'</span>)</span><br><span class="line">b = Decimal(<span class="string">'2.2'</span>)</span><br><span class="line">print(a + b) <span class="comment"># 输出 3.3</span></span><br></pre></td></tr></table></figure><h3 id="设定有效数字"><a href="#设定有效数字" class="headerlink" title="设定有效数字"></a>设定有效数字</h3><p>通过 getcontext().prec 可以设置有效数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> getcontext</span><br><span class="line">getcontext().prec = <span class="number">4</span></span><br><span class="line">print(Decimal(<span class="string">'2.2'</span>)/Decimal(<span class="string">'1.3'</span>)) <span class="comment"># 1.692</span></span><br></pre></td></tr></table></figure><h3 id="设定小数位数"><a href="#设定小数位数" class="headerlink" title="设定小数位数"></a>设定小数位数</h3><p>Deicmal() 函数可以四舍五入设置保留的小数位，且不用管小数原来的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line">Decimal(num).quantize(Decimal(<span class="string">'0.000000'</span>)) <span class="comment"># 四舍五入，保留六位小数，不管 num 是什么形式</span></span><br></pre></td></tr></table></figure><p>而使用格式化的方式，如 float(‘%.6f’ % a) 可以控制保留六位小数，但是如果后面都是 0 的话，比如 0.00000，返回的是 0.0； 如果是 1.2200000 的话，返回的是 1.22</p><p>【参考】<br><a href="https://finthon.com/python-decimal/" target="_blank" rel="noopener">Python中的decimal模块执行精确的浮点运算</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 单例模式</title>
      <link href="/2019/08/05/python/Python-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/08/05/python/Python-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式是确保某个类只有一个实例存在，保证了在程序的不同位置都可以且仅可以取到同一个对象实例。如果实例不存在，会创建一个实例；如果已存在就会返回这个实例。</p><a id="more"></a><h2 id="单例模式特点"><a href="#单例模式特点" class="headerlink" title="单例模式特点"></a>单例模式特点</h2><p>只有一个实例、单例类的构造函数是私有的，自行创建类的实例、向整个系统公开这个实例接口</p><h2 id="单例模式使用场景"><a href="#单例模式使用场景" class="headerlink" title="单例模式使用场景"></a>单例模式使用场景</h2><ol><li>Python 的 logger 就是一个单例模式，用以日志记录</li><li>Windows 的资源管理器是一个单例模式</li><li>线程池，数据库连接池等资源池一般也用单例模式</li><li>网站计数器</li></ol><p>为什么不用全局变量？<br>全局变量不能保证应用程序只有一个实例，且可能会有名称空间的干扰，如果有重名的可能会被覆盖，不能继承</p><h2 id="python-实现单例模式"><a href="#python-实现单例模式" class="headerlink" title="python 实现单例模式"></a>python 实现单例模式</h2><p>python 有多种方式来实现单例模式： 模块、<code>__new__</code>、 装饰器、 元类 metaclass</p><h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p><strong>python  的模块就是天然的单例模式</strong>，在模块第一次导入时，会生成 <code>.pyc</code> 文件，之后的导入就会加载 <code>.pyc</code> 文件，而不会再次执行模块代码。</p><p>如果想创建一个单例类，可以新建一个 mysingleton.py 文件，也就是一个模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">my_singleton = My_Singleton()</span><br></pre></td></tr></table></figure><p>在其他文件中，只要导入上满这个模块中的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure><h3 id="使用-new-方法"><a href="#使用-new-方法" class="headerlink" title="使用 __new__ 方法"></a>使用 <code>__new__</code> 方法</h3><p>为了使类只能出现一个实例，可以用 <code>__new__</code> 来控制实例的创建过程，将类的实例和一个类变量 <code>_instance</code> 关联起来，如果 <code>cls._instance</code> 为 None 则创建实例，否则直接返回 <code>cls._instance</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">s1 = Singleton()</span><br><span class="line">s2 = Singleton()</span><br><span class="line">print(id(s1) == id(s2)) <span class="comment"># True,说明是同一个实例</span></span><br></pre></td></tr></table></figure><p>但是当有多个线程同时去初始化对象时，就很可能同时判断 <code>_instance is None</code>，无法实现单例。这种情况下，需要用同步锁来解决问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> synchronize <span class="keyword">import</span> make_synchronized</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"><span class="meta">    @make_synchronized # 用装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h3><p>可以使用装饰器来修饰某个类，使其只能生成一个实例。</p><ol><li>定义一个装饰器 singleton，它返回了一个内部函数 getinstance，该函数会判断某个类是否在字典 instances 中。</li><li>如果不存在，将 <code>cls</code> 作为 key，<code>cls(*args, **kw)</code> 作为 value 存到 instances 中，否则，直接返回 <code>instances[cls]</code>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h3><p>元类（metaclass）可以控制类的创建过程，它主要做三件事：</p><ol><li>拦截类的创建</li><li>修改类的定义</li><li>返回修改后的类</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 面向对象</title>
      <link href="/2019/08/02/python/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/08/02/python/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>面向对象编程(OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。简单的说就是基于类和对象的使用。</p><a id="more"></a><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象的三个特征：封装、继承、多态</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别。</p><ul><li>封装数据： 为了保护隐私，明确区分内外数据，对外提供操作该数据的接口</li><li>封装方法： 目的是隔离复杂度</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在定义一个类的时候可以从当前有的类中进行继承。</p><p>python 允许多继承，并且在子类中拥有父类所有的成员变量和方法，为了缓解代码中的冗余，子类在父类的基础上增加的成员变量可以如下修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">Person.__init__(self, name, sex)</span><br><span class="line">self.mother = mother</span><br></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>当子类继承父类之后，成员方法既可以重写也可以不重写。当调用的时候只要保证新方法编写正确，不用管原来的代码</p><ul><li>对扩展开放（Open for extension）：允许子类重写方法函数</li><li>对修改封闭（Closed for modification）：不重写，直接继承父类方法函数</li></ul><p>鸭子类型： 一些类含有相同的方法，则这些类就互称为鸭子</p><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p><h4 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h4><p>private：私有变量以 <code>__</code> 开头，只有内部能够访问，可以给类增加 get、set 方法<br>特殊变量： <code>__xxx__</code>, 可以直接访问</p><h4 id="init-和-new-区别"><a href="#init-和-new-区别" class="headerlink" title="init 和 new 区别"></a><strong>init</strong> 和 <strong>new</strong> 区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值。</span><br><span class="line">__new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例，是个静态方法。</span><br><span class="line"></span><br><span class="line">即，__new__在__init__之前被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. __init__ 方法为初始化方法, __new__方法才是真正的构造函数，创建实例。</span><br><span class="line">2. __new__方法默认返回实例对象供__init__方法、实例方法使用。</span><br><span class="line">3. __init__ 方法为初始化方法，为类的实例提供一些属性或完成一些动作。</span><br><span class="line">4. __new__是一个静态方法，而__init__是一个实例方法。</span><br></pre></td></tr></table></figure><h4 id="self-和-cls-区别"><a href="#self-和-cls-区别" class="headerlink" title="self 和 cls 区别"></a>self 和 cls 区别</h4><p>self 是实例方法定义，cls 主要用在类方法定义。</p><p>一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。<br>而使用 @staticmethod 或 @classmethod，就可以不需要实例化，直接类名.方法名()来调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(name)</span>:</span> <span class="comment"># 静态函数，这种方法与类有某种关系但不需要使用到实例或者类来参与</span></span><br><span class="line">print(name) <span class="comment"># 既可以作为类的方法使用，也可以作为类的实例的方法使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo2</span><span class="params">(self, name)</span>:</span></span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo3</span><span class="params">(cls, name)</span>:</span></span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.foo1(<span class="string">'xyy'</span>)</span><br><span class="line">A.foo1(<span class="string">'xyy'</span>)</span><br><span class="line"></span><br><span class="line">a.foo2(<span class="string">'xyy'</span>)</span><br><span class="line">A.foo2(<span class="string">'xyy'</span>) <span class="comment"># 报错</span></span><br><span class="line"></span><br><span class="line">a.foo3(<span class="string">'xyy'</span>)</span><br><span class="line">A.foo3(<span class="string">'xyy'</span>)</span><br></pre></td></tr></table></figure><p>@staticmethod 和 @classmethod 都可以直接类名.方法名()来调用</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2019/07/28/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/07/28/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>数据库索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息，索引的目的是为了加快检索表中数据。索引的实现通常使用 B树 及其变种 B+树。</p><a id="more"></a><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>原理：通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。 </p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>创建唯一索引，保证数据库表中每行数据的唯一性</li><li>加快数据的检索速度</li><li>加速表与表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li></ol><p>缺点:</p><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>适用于建立索引的情况：<code>主键、经常搜索、连接(外键)、排序的、where 的、统计或分组的</code></p><ol><li>建立在经常需要搜索的字段上，可以加快搜索的速度；</li><li>在作为主键的字段上，强制该列的唯一性和组织表中数据的排列结构；</li><li>经常与其他表进行连接的字段，这些字段主要是外键，可以加快连接的速度；</li><li>经常需要根据范围进行搜索的字段上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要排序的字段上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li></ol><p>不适用于建立索引的情况：</p><ol><li>查询中很少使用或者参考的字段不应该创建索引。</li><li>数据值选择性很低的字段，不适合建索引，比如性别</li><li>对于大的文本字段甚至超长字段，不要建索引，比如text, image 和 bit 数据类型</li><li>修改操作远远多于检索操作时，不应该创建索引。</li><li>频繁更新（增删改）的字段不适合创建索引</li></ol><h3 id="mysql-创建索引的方式"><a href="#mysql-创建索引的方式" class="headerlink" title="mysql 创建索引的方式"></a>mysql 创建索引的方式</h3><p>在执行 CREATE TABLE 语句时可以创建索引，也可以单独用 CREATE INDEX 或 ALTER TABLE 来为表增加索引。</p><ol><li><p>在创建表时建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">sno <span class="built_in">INT</span> AUTO_INCREMENT</span><br><span class="line">sname <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">birth <span class="built_in">DATE</span></span><br><span class="line"></span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(sno) <span class="comment"># 创建主键索引</span></span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> [sname_index] (sname) <span class="comment"># 创建唯一索引，也可以在上面字段定义时使用 UNIQUE 来创建</span></span><br><span class="line"><span class="keyword">INDEX</span> [sname_birth_index] (sname, birth) <span class="comment"># 创建普通的组和索引</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>CREATE [UNIQUE | CLUSTERED] INDEX index_name ON table_name(column_name1 ASC, column_name2 DESC)<br>注意： create index 不能创建主键索引</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>|CLUSTERED] <span class="keyword">INDEX</span> [index_name] (<span class="keyword">column</span> <span class="keyword">name</span>)</span><br></pre></td></tr></table></figure><p>alter table 可以创建主键索引： ALTER TABLE student ADD PRIMARY KEY (sno)</p></li></ol><p><strong>删除索引</strong>  </p><ol><li>DROP INDEX index_name ON table_name</li><li>ALTER TABLE table_name DROP INDEX index_name</li><li>ALTER TABLE table_name DROP PRIMARY KEY</li></ol><p><strong>查看索引</strong><br>SHOW INDEX FROM database_name.table_name;</p><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><p>聚簇索引：物理索引，与基表的物理顺序相同，数据值的顺序总是按照顺序排列。一般情况下主键会默认创建聚簇索引，在一张表上最多只能创建一个聚集索引。直接缩小范围找到记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CLUSTERED <span class="keyword">INDEX</span> my_index <span class="keyword">ON</span> student(<span class="keyword">id</span>)</span><br></pre></td></tr></table></figure><p>非聚簇索引： 表数据存储顺序与索引顺序无关，需要通过位置去找到记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> UNCLUSTERED <span class="keyword">INDEX</span> my_index <span class="keyword">ON</span> student(my_column)</span><br></pre></td></tr></table></figure><h3 id="唯一索引与主键索引"><a href="#唯一索引与主键索引" class="headerlink" title="唯一索引与主键索引"></a>唯一索引与主键索引</h3><p>唯一索引： 保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用，允许有空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> CLUSTERED <span class="keyword">INDEX</span> my_index <span class="keyword">ON</span> student(my_column)</span><br></pre></td></tr></table></figure><p>主键索引： 就是主键，是一种特殊的唯一索引，不能为空。一张表中只能定义一个主键索引，通常有一列或列组合，用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。为表定义一个主键将自动创建主键索引（聚簇索引）。主键可以是聚簇索引也可以是非聚簇索引。</p><p>区别：</p><ol><li>主键索引一定是唯一索引，唯一索引不一定是主键索引</li><li>唯一索引可以为空，主键索引不能为空</li><li>一张表只能有一个主键索引，可以有多个唯一索引</li></ol><h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><ol><li>如果条件中有 or，即使其中有部分条件带索引也不会使用。 要想使用 or，又想让索引生效，只能将 or 条件中的每个列都加上索引。</li><li>like 查询是以 % 开头，索引失效；但以 % 结尾，索引可以使用</li><li>存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>对于多列索引，必须满足 最左匹配原则 (eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)。</li><li>where 子句里对索引列上有数学运算，用不上索引</li><li>where 子句里对有索引列使用函数，用不上索引， where abs(id)=1</li><li>如果 mysql 估计使用全表扫描要比使用索引快,则不使用索引，比如数据量极小的表</li></ol><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>一般把排序分组频率最高的列放在最左边。</p><p>如果在一个表的三列，col1，col2，col3 建立了一个联合索引，在 select 语句中：</p><ol><li>where col1，where col1 and col2， where col1 and col2 and col3，可以命中索引</li><li>where col2，where col3，不会命中索引</li><li>where col1 and col3，能够命中部分索引，也就是 col1 这部分</li><li>where col2 and col1，先会拿 col2 去比较，没有结果，但是 mysql 会对这个语句进行优化，把 col1 放在第一位，因此可以命中索引 </li></ol><h2 id="索引的实现原理"><a href="#索引的实现原理" class="headerlink" title="索引的实现原理"></a>索引的实现原理</h2><h3 id="为什么加索引能够优化慢查询："><a href="#为什么加索引能够优化慢查询：" class="headerlink" title="为什么加索引能够优化慢查询："></a>为什么加索引能够优化慢查询：</h3><p>DB 在执行一条 Sql 语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。 </p><p>索引其实是一种优化查询的数据结构，比如 Mysql 中的索引是用 B+ 树实现的，而 B+ 树就是一种能够优化查询速度的数据结构，可以利用索引快速查找数据，所以能优化查询。</p><p>能够优化查询速度的数据结构： B 树、 B+ 树、 哈希表、 平衡二叉树等</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树（Balance tree），也叫 B树，是一种平衡的多叉树，又称平衡多路查找树或外部查找树。</p><p>满足条件：</p><ol><li>任意非叶子节点最多只有 M 个儿子节点，且 M &gt; 2</li><li>根节点的儿子数为 [2, M]</li><li>除根节点外的非叶子节点的儿子数为 [M/2, M]</li><li>每个节点存放至少 M/2-1（取上整）和至多 M-1 个关键字（至少2个关键字）</li><li>非叶子节点的关键字个数 = 指向儿子的指针个数 - 1</li><li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li><li>非叶子结点的指针：P[1], P[2], …, P[M]；其中 P[1] 指向关键字小于 K[1] 的子树，P[M] 指向关键字大于 K[M-1] 的子树，其它 P[i] 指向关键字属于 (K[i-1], K[i]) 的子树；</li><li>所有叶子结点位于同一层；</li></ol><p>如图，一棵 M=3 的 B-树</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1564304350/B-tree.jpg"></div><p>B-树的特性：</p><ol><li>关键字集合分布在整颗树中；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束；</li><li>其搜索性能等价于在关键字全集内做一次二分查找；</li><li>自动层次控制；</li></ol><p>B-树的查找性能为 O(logn), n 为关键词总数， 与 M 无关。</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B-树的变体，sqlite、mysql 应用 B+树处理索引。</p><p>B+树与B-树的定义基本相同，除了以下几点：</p><ol><li>非叶子结点的子树指针与关键字个数相同</li><li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树，（注意B-树是开区间）</li><li>所有叶子结点增加一个链指针，构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li><li>所有关键字都在叶子结点出现，非叶子节点仅具有索引作用</li></ol><p>如图，一棵 M=3 的 B+树</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1564304772/B%2Btree.jpg"></div><p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p><h3 id="B-树和B-树的优点"><a href="#B-树和B-树的优点" class="headerlink" title="B+树和B-树的优点"></a>B+树和B-树的优点</h3><p>B+ 树的优点：</p><ol><li>由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的 key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。</li><li>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li></ol><p>B-树的优点：<br>由于B树的每一个节点都包含 key 和 value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</p><h3 id="B-树和B-树的区别"><a href="#B-树和B-树的区别" class="headerlink" title="B+树和B-树的区别"></a>B+树和B-树的区别</h3><ol><li><p>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个叶子结点，但是其只拥有m-1个关键字。</p></li><li><p>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</p></li><li><p>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</p></li><li><p>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</p></li></ol><h3 id="数据库索引为何不用二叉树"><a href="#数据库索引为何不用二叉树" class="headerlink" title="数据库索引为何不用二叉树"></a>数据库索引为何不用二叉树</h3><p>考虑到磁盘 IO 的影响，它相对于内存来说是很慢的。</p><p>数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。</p><p>所以我们要减少 IO 次数，对于树来说，IO 次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。</p><h3 id="为什么-mysql-要用-B-树"><a href="#为什么-mysql-要用-B-树" class="headerlink" title="为什么 mysql 要用 B+树"></a>为什么 mysql 要用 B+树</h3><p>mysql 中的数据是存放在磁盘中的，读取数据需要对磁盘进行访问，数据量太大的话无法一次性加载到内存中，而使用 B树或B+树就只需加载部分索引。<strong>局部性原理与磁盘预读</strong></p><p>预读: 即使只需要一个字节，操作系统也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这里的一定长度叫做页，也就是操作系统操作磁盘时的基本单位。一般操作系统中一页的大小是4Kb。</p><p><strong>磁盘预读</strong><br>当一个数据被用到时，其附近的数据也通常会马上被使用。 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><p><strong>不用 AVL 或 红黑树的原因是</strong>：当数据量比较大时，都会由于树的深度过大而造成 IO 读写过于频繁，进而导致查询效率低下。而B+树的操作能够保持较低的高度，从而保证高效的查找效率。</p><p><strong>不用 B 树的原因是</strong>：</p><ol><li><p>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p></li><li><p>B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></li><li><p>数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，方便扫库，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。<br>对于多条数据的查找，B树要做局部的中序遍历，还可能要跨层访问；而B+树所有数据都在叶子节点，不用跨层，且有链表结构，只需要找到首尾通过链表就能读出所有数据。</p></li></ol><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ol><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ol><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><p>用 B+树查找的时间为 O(logn)，用 hash 查找的时间为 O(1)，那索引实现为什么要用 B+树而不是 hash 呢？<br>答： 与业务场景相关</p><ol><li>如果只查找一个值的话，hash 是一个很好的选择，而数据库经常会选择多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比 hash 就快得多。</li><li>数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，能够提高查找效率。</li></ol><h2 id="MyIASM-和-InnoDB-的索引结构"><a href="#MyIASM-和-InnoDB-的索引结构" class="headerlink" title="MyIASM 和 InnoDB 的索引结构"></a>MyIASM 和 InnoDB 的索引结构</h2><h3 id="MyIASM"><a href="#MyIASM" class="headerlink" title="MyIASM"></a>MyIASM</h3><p>MyISAM 引擎的索引结构为 B+树，其中B+树的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，索引文件仅保存数据记录的地址，只不过是用索引指向了实际的数据，这种索引就是非聚集索引。</p><p>在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 引擎的索引结构也是 B+树，但是 Innodb 的索引文件本身就是数据文件，即B+树的数据域存储的就是实际的数据，这种索引是聚集索引。这个索引的 key 就是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。</p><p>InnoDB 的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。<br>InnoDB 不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+树的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p><p>InnoDB 数据文件本身是一颗B+树。</p><p>B+ 树一个节点的大小： Mysql的Innodb引擎中一页的默认大小是16k（如果操作系统中一页大小是4k，那么Mysql中1页=操作系统中4页）</p><p>B+ 树一个节点存储的内容：<br>非叶子节点： 索引 + 指针<br>叶子节点： 数据</p><p>【参考文献】<br><a href="#https://blog.csdn.net/u013411246/article/details/81088914">B树、B-树、B+树、B*树之间的关系</a><br><a href="https://www.cnblogs.com/0201zcr/p/5296843.html" target="_blank" rel="noopener">mysql 数据库引擎</a><br><a href="https://juejin.im/post/5c822b0ce51d453a42155c3d" target="_blank" rel="noopener">面试必备之MYSQL索引底层原理分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 索引 </tag>
            
            <tag> B Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步异步和阻塞非阻塞</title>
      <link href="/2019/07/20/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
      <url>/2019/07/20/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
      
        <content type="html"><![CDATA[<p>在实际开发中，经常会听到同步、异步、阻塞、非阻塞等概念，还可能遇到以下四种组合情况：</p><ol><li>同步 + 阻塞</li><li>同步 + 非阻塞</li><li>异步 + 阻塞</li><li>异步 + 非阻塞</li></ol><a id="more"></a><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步和异步是指: 请求发起方对消息结果的获取是主动发起的，还是等被动通知的。</p><ol><li>请求方主动发起，一直在等待应答结果： 同步阻塞</li><li>请求方主动发起，先去处理其他的事情，但通过不断轮询查看发起的请求是否有应答结果： 同步非阻塞</li><li>由服务方通知，也就是请求方发出请求后，一直在等待通知：异步阻塞</li><li>由服务方通知，请求方发出请求后，就先去处理其他事情：异步非阻塞<br>当事情处理完成之后，服务方会主动通知请求方，它的请求已经完成，这就是异步。异步通知的方式一般是通过状态改变，消息通知，或者回调函数来完成，大多数时候采用的都是回调函数。</li></ol><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞和非阻塞概念通常是和对于 IO 操作，如网络 IO 和磁盘 IO 等</p><p>阻塞和非阻塞通常形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其它所有需要这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。而非阻塞允许多个线程同时进入临界区。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之哈希表</title>
      <link href="/2019/07/09/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2019/07/09/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>哈希 (Hash、散列) 是电脑科学中一种对资料的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。</p><a id="more"></a><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>Hash 就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。直观解释起来，就是对一串数据 m 进行杂糅，输出另一段固定长度的数据 h，作为这段数据的特征（指纹）。也就是说，无论数据块 m 有多大，其输出值 h 为固定长度。这种转换是一种压缩映射。</p><p>Hash 主要应用于数据结构中和密码学中。</p><ul><li>使用 Hash 的数据结构叫做哈希表，主要是为了提高查询的效率。</li><li>在密码学中，hash 算法的作用主要是用于消息摘要和签名，主要用于对整个消息的完整性进行校验。</li></ul><p>hash 函数的特点：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</p><h3 id="常见的-hash-函数"><a href="#常见的-hash-函数" class="headerlink" title="常见的 hash 函数"></a>常见的 hash 函数</h3><ul><li><p>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。</p></li><li><p>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。</p></li><li><p>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。</p></li><li><p>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</p></li><li><p>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</p></li><li><p>伪随机数法：采用一个伪随机数当作哈希函数。</p></li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表（Hash table，也叫散列表），是根据关键码值 (Key value) 而直接进行访问的数据结构。</p><p>根据键（Key）值将数据映射到内存中一个位置的函数称为哈希函数，根据哈希函数建立的记录数据的表称为哈希表。</p><p>使用哈希表可以进行非常快速的查找操作，查找时间为 O(1)， 且不需要元素排列有序。 </p><p>尽管最坏的情况下，哈希表中查找一个元素的时间与链表中查找的时间相同，达到了O(n)。但在实际应用中，散列的查找的性能是极好的。在一些合理的假设下，在散列表中查找一个元素的平均时间是 O(1)。</p><h3 id="哈希表实现过程"><a href="#哈希表实现过程" class="headerlink" title="哈希表实现过程"></a>哈希表实现过程</h3><ol><li>存储时，通过哈希函数计算记录的哈希地址，并按此地址存储该记录。</li><li>查找记录时，同样通过哈希函数计算记录的散列地址，按此散列地址访问该记录。</li></ol><p>所以说散列技术既是一种存储方法，也是一种查找方法。它与线性表、树、图等数据结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，而哈希技术之间数据元素不存在逻辑关系，它只与关键字有关系。因此，哈希主要是面向查找的存储结构。</p><h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><p>冲突指不同键经过哈希函数计算得到相同的索引，这样造成索引重复的冲突，即 k1≠k2，而 f(k1)=f(k2)。</p><h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><p>开放定址法就是产生冲突之后去寻找下一个空闲的空间，需要探测出一个尚未被占用的索引。因为需要探测，所以添加一个 key-value 对可能需要更多的时间，但是查找仍是 O(1) 时间复杂度的。</p><h4 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h4><p>散列到同一位置的元素，不是继续往下探测，而是在这个位置是一个链表，这些元素则都放到这一个链表上。</p><h2 id="python-中的哈希"><a href="#python-中的哈希" class="headerlink" title="python 中的哈希"></a>python 中的哈希</h2><p>hash() 用于获取取一个对象（字符串或者数值等）的哈希值，不能直接应用于 list、set、dict。</p><p>在 hash() 对对象使用时，所得的结果不仅和对象的内容有关，还和对象的 id()，也就是内存地址有关。</p><p>hash() 函数的对象字符不管有多长，返回的 hash 值都是固定长度的。</p><h3 id="python-字典"><a href="#python-字典" class="headerlink" title="python 字典"></a>python 字典</h3><p>python 的内建数据类型 dict 字典，就是用哈希表实现的。</p><p>Python 是使用开放寻址法中的二次探查来解决冲突的。然后如果使用的容量超过数组大小的 2/3，就申请更大的容量。数组大小较小的时候 resize 为 * 4，较大的时候 resize * 2。实际上是用左移的形式。</p><h3 id="dict-和-HashMap-区别"><a href="#dict-和-HashMap-区别" class="headerlink" title="dict 和 HashMap 区别"></a>dict 和 HashMap 区别</h3><p>pyhton dict 和 java HashMap 都是采用哈希表实现，不同的是 dict 在发生哈希冲突的时候采用了开放寻址法，而 HashMap 采用了链接法。</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>在 JDK1.8 中，HashMap 底层是用数组 Node&lt;K,V&gt; 数组存储，数组中每个元素用链表存储元素，当元素超过 8 个时，将链表转化成红黑树存储。</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器 Bloom Filter 是一种多哈希函数映射的快速查找算法。通常应用于快速判断一个元素是否属于集合，但是并不是严格要求 100% 正确的场合。 </p><ul><li>优点： 优空间效率和查询时间都远远超过一般的算法</li><li>缺点：有一定的误识别率，但是它只会把不存在集合中的元素误判成存在于集合中，而不会把存在集合中的元素误判成不存在集合中。且不能删除已经插入的关键词，因此该元素的位置会影响其他元素。</li></ul><p>改进： 改进就是 counting Bloom filter，用一个 counter 数组代替位数组，就可以支持删除了</p><h3 id="Bloom-Filter-原理"><a href="#Bloom-Filter-原理" class="headerlink" title="Bloom Filter 原理"></a>Bloom Filter 原理</h3><p>Bloom Filter 实际上是一个很长的二进制向量和一系列随机映射函数，将一个值映射到布隆过滤器中，需要使用多个不同的哈希函数生成多个哈希值，然后在布隆过滤器中，给每个哈希值的 index 置 1。</p><p>判断一个元素是否存在于集合中，使用哈希函数得到多个哈希值，判断每个哈希值的 index 是否为 1，只要有一个是 0，这个元素就不可能存在集合中；但可能会误判，因为不同的元素计算出的哈希值可能是相同的，但在布隆过滤器中都是 1，如果计算出的 k 个位置全部为1，则可能在集合中。</p><h3 id="如何选择哈希函数个数和布隆过滤器长度"><a href="#如何选择哈希函数个数和布隆过滤器长度" class="headerlink" title="如何选择哈希函数个数和布隆过滤器长度"></a>如何选择哈希函数个数和布隆过滤器长度</h3><p>布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p><p>哈希函数的个数越多则布隆过滤器 bit 位置位 1 的速度越快，那么布隆过滤器的效率越低；但是如果太少的话，误报率变高。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，就不用进行后续昂贵的查询请求。</p><p>性能较高的哈希函数有： MurmurHash、Fnv</p><p>【参考文献】<br><a href="https://python123.io/index/topics/data_structure/hash_table" target="_blank" rel="noopener">Python 数据结构入门 - 哈希表（Hash Table）</a><br><a href="#https://harveyqing.gitbooks.io/python-read-and-write/content/python_advance/python_dict_implementation.html">Python字典实现</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> dict </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之红黑树</title>
      <link href="/2019/07/05/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2019/07/05/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>红黑树是平衡搜索树的一种，可以保证在最坏情况下基本动态集合操作的时间复杂度为 O(logn)</p><a id="more"></a><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树（BST），又称二叉排序树、二叉搜索树。叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，为 o(logn)。二叉查找树中序遍历一遍的结果是单调递增的，可以用于二分搜索。</p><ol><li>没有键值相等的节点</li><li>若<strong>左子树</strong>不为空，则左子树上节点值<strong>均小于</strong>根节点的值</li><li>若<strong>右子树</strong>不为空，则右子树上节点值<strong>均大于</strong>根节点的值</li><li>任意节点的左、右子树也是二叉查找树</li></ol><p>二叉排序树的性能取决于二叉树的层数：</p><ul><li>最好的情况是 O(logn)，存在于完全二叉排序树情况下，其访问性能近似于折半查找；</li><li>最差时候会是 O(n)，比如插入的元素是有序的，二叉查找树退化为单链表时，需要遍历全部元素。</li></ul><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1564277685/red-black-tree.png"></div><p>红黑树具有五条性质：</p><ol><li>每个结点要么是红的，要么是黑的。  </li><li>根结点是黑的。  </li><li>每个叶结点（叶结点即指树尾端 NIL 指针或 NULL 结点）是黑的。  </li><li>如果一个结点是红的，那么它的俩个儿子都是黑的。  </li><li>对于任一结点而言，其到叶结点树尾端 NIL 指针的每一条路径都包含相同数目的黑结点。  </li></ol><p>五大性质总结：</p><ol><li>对每个红色节点，子节点只有两种情况：要么都没有，要么都是黑色的。（不然会违反特征四）</li><li>对黑色节点，如果只有一个子节点，那么这个子节点，必定是红色节点。（不然会违反特征五）</li><li>假设从根节点到叶子节点中，黑色节点的个数是 h, 那么树的高度 H 范围 h &lt;= H &lt;= 2H（特征四五决定）， 因此红黑树的查找不会退化到线性查找，时间复杂度为 O(logn)。</li></ol><h3 id="树的旋转"><a href="#树的旋转" class="headerlink" title="树的旋转"></a>树的旋转</h3><p>当对红黑树进行插入或删除操作时，可能会破坏红黑树的结构。为了保持红黑树的性质，可以对结点重新着色，及对树进行旋转操作，修改树中某些结点的颜色及指针结构。</p><p>树的旋转包括左旋和右旋，红黑树左右旋的目的是调整红黑节点结构，转移黑色节点位置，使其在进行插入、删除后仍能保持红黑树的 5 条性质。</p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p>pivot 的左旋是： 把 pivot 变成它右孩子 Y 的左孩子，右孩子 Y 的左孩子变成它的右孩子；左旋是把右子树里的一个节点 (Y) 移动到左子树</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1564278589/left-rotate.jpg"></div><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p>pivot 的右旋是： 把 pivot 变成它左孩子 Y 的右孩子，左孩子 Y 的右孩子变成它的左孩子</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1564278589/right-rotate.jpg"></div><p>对于树的旋转，能保持不变的只有原树的搜索性质，而原树的红黑性质则不能保持，在红黑树的数据插入和删除后可利用旋转和颜色重涂来恢复树的红黑性质。</p><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><ol><li>首先和二叉查找树的插入一样，查找到结点插入的位置、插入</li><li>然后调整结构，保证满足红黑树状态:<ul><li>对结点进行重新着色</li><li>以及对树进行相关的旋转操作</li></ul></li></ol><p>二叉查找树的插入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, root, x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        root = TreeNode(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt; root.val:</span><br><span class="line">            root.left = self.insert(root.left, x) <span class="comment"># 递归的去查找插入点</span></span><br><span class="line">        <span class="keyword">elif</span> x &gt; root.val:</span><br><span class="line">            root.right = self.insert(root.right, x)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>红黑树定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, color=<span class="string">"R"</span>)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.color = color</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>红黑树的插入红黑树的插入在二叉查找树插入的基础上，为了重新恢复平衡，继续做了插入修复操作。插入的节点一般设定为红色然后再调整。</p><ol><li><p>若插入的是根节点，直接变成黑色</p></li><li><p>若插入节点的父节点是黑色，则不调整颜色</p></li><li><p>若插入节点的父节点为红色（违反性质四），且父节点的兄弟节点也为红色。<br>1) 把父节点及其兄弟节点变成黑色，把祖父节点变成红色（使其不违反性质五）。<br>2) 再检查祖父节点是否违反红黑树的性质（一或四）</p></li><li><p>若插入节点的父节点为红色（违反性质四），且父节点的兄弟节点为黑色，且插入节点，父节点，及祖父节点同侧：把父节点变成黑色节点，把祖父节点变成红色节点，同时反向旋转祖父节点（同左则，右旋； 同右则左旋）</p></li><li><p>若插入节点的父节点为红色（违反性质四），且父节点的兄弟节点为黑色，且插入节点，父节点，及祖父节点不同侧：  旋转父节点，使期变成同侧（第 4 种情况），再根据情况 4 来处理。</p></li></ol><p>具体的图解请参考：<a href="https://blog.csdn.net/net_wolf_007/article/details/79706498" target="_blank" rel="noopener">理解红黑树并实现(python3)</a></p><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p>【参考资料】<br><a href="https://blog.csdn.net/net_wolf_007/article/details/79706498" target="_blank" rel="noopener">理解红黑树并实现(python3)</a><br><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="noopener">教你透彻了解红黑树</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 异常处理</title>
      <link href="/2019/04/01/python/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/04/01/python/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>python 使用 try/except/finally 语句块来处理异常。 良好的异常处理可以让程序更加健壮，清晰的错误信息能够帮助快速修复问题。</p><a id="more"></a><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="try-except-finally"><a href="#try-except-finally" class="headerlink" title="try/except/finally"></a>try/except/finally</h3><p>try/except 语句用来检测 try 语句块中的错误，从而让 except 语句能够捕获异常信息并处理，except 可以有多个。 except 后面若不指定异常类型，则默认捕获所有异常，可以通过 logging 或 sys 模块获取当前异常。</p><p>try/finally 语句无论是否发生异常都将执行最后的代码，可以只使用 try/finally, 省略 except</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(a / b)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        print(<span class="string">"Error: b should not be 0 !!"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"Unexpected Error: &#123;&#125;"</span>.format(e))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Run into else only when everything goes well'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'Always run into finally block.'</span>)</span><br><span class="line"></span><br><span class="line">div(<span class="number">2</span>, <span class="number">0</span>) <span class="comment"># Error: b should not be 0 !!</span></span><br><span class="line">div(<span class="number">2</span>, <span class="string">'bad type'</span>) <span class="comment"># Unexpected Error: unsupported operand type(s) for /: 'int' and 'str'</span></span><br><span class="line">div(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 0.5, 并打印 else 里的， finally 语句里的这三个最后都会执行</span></span><br></pre></td></tr></table></figure><h3 id="except-带多种异常类型"><a href="#except-带多种异常类型" class="headerlink" title="except 带多种异常类型"></a>except 带多种异常类型</h3><p>使用同一个 except 语句可以处理多个异常信息，只要发生多个异常中的一个，就执行代码。<br>语法： except(Exception1[, Exception2[,…ExceptionN]]])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(a / b)</span><br><span class="line">    <span class="keyword">except</span> (ZeroDivisionError, TypeError) <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure><h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>raise 关键字用于主动抛出一个异常，raise关键字后面可以指定你要抛出的异常实例，一般来说抛出的异常越详细越好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> NameError(<span class="string">"bad name!"</span>)</span><br></pre></td></tr></table></figure><h3 id="使用内置语法范式代替-try-except"><a href="#使用内置语法范式代替-try-except" class="headerlink" title="使用内置语法范式代替 try/except"></a>使用内置语法范式代替 try/except</h3><ol><li><p>for 语句处理了 StopIteration 异常，可以流畅地写出一个循环。</p></li><li><p>with 语句在打开文件后会自动调用 finally 中的关闭文件操作。 因此用 with open 来代替 try/except/finally</p></li><li><p>访问一个不确定的属性时，可以用 getattr() 方法，而不用再捕获异常 except AttributeError</p></li></ol><h2 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h2><p>python 的异常是一个类，所有的异常类型都继承自 BaseException 这个基类。 python 捕获所有异常时，应该用 Exception，Exception 继承自 BaseException。 可以自定义一个异常，继承自 Exception 类。</p><p>BaseException 除了包含所有的 Exception 外还包含了 SystemExit，KeyboardInterrupt 和 GeneratorExit 三个异常，但这三个属于更高级别的异常，合理的做法是交给 Python 解释器处理。</p><p>python3 中使用 except Exception as e 来获取异常。</p><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><ul><li>BaseException 所有异常的基类</li><li>OverflowError 数值运算超过最大限制</li><li>IOError 输入/输出操作失败</li><li>ImportError 导入模块/对象失败</li><li>RuntimeError 一般运行时错误</li><li>SyntaxError 语法错误</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000007736783" target="_blank" rel="noopener">总结：Python中的异常处理</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值的表示</title>
      <link href="/2019/03/22/%E6%95%B0%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
      <url>/2019/03/22/%E6%95%B0%E5%80%BC%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>任何存储于计算机中的数据，其本质都是以二进制码存储的。计算机中所有的数都以补码形式存在，加减运算都是补码间的加法运算。为何及其要用补码存储，我们需要了解原码、反码和补码的概念。</p><a id="more"></a><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码是符号位加真值的绝对值。有符号的二进制数将最高位作为符号位用来区分正负数。 正数的符号为 0，负数的符号为 1。 </p><p>对于 8 位二进制数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+1 的原码为 0000 0001</span><br><span class="line">-1 的原码为 1000 0001</span><br></pre></td></tr></table></figure><p>使用原码表示数值会出现两个 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+0 的原码为 0000 0000</span><br><span class="line">-0 的原码为 1000 0000</span><br></pre></td></tr></table></figure><p>因此使用原码表示 8 位二进制数的范围就是 [1111 1111, 0111 1111] 也就是 [-127, 127]，里面包括了 +0 和 -0 两个数，总共有 256 个数</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><ul><li>正数的反码与其原码相同</li><li>负数的反码是在其原码的基础上，符号位不变，其余逐位取反。</li></ul><p>那么对于 8 位二进制数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+1 &#x3D; 0000 0001(原码) &#x3D; 0000 0001(反码)</span><br><span class="line">-1 &#x3D; 1000 0001(原码) &#x3D; 1111 1110(反码)</span><br></pre></td></tr></table></figure><p>这样的话也会有两个 0， 0000 0000(+0) 和 1111 1111(-0)</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><ul><li>正数的补码是其本身</li><li>负数的补码是在反码的基础上 +1</li></ul><p>对于 8 位二进制数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+1 &#x3D; 0000 0001(原码) &#x3D; 0000 0001(反码) &#x3D; 0000 0001(补码)</span><br><span class="line">-1 &#x3D; 1000 0001(原码) &#x3D; 1111 1110(反码) &#x3D; 1111 1111(补码)</span><br></pre></td></tr></table></figure><p>在计算机的运算中，只有加法没有减法，减法就相当于加上这个数的相反数，如果我们将符号位参与运算，并且只保留加法运算，对于原码来说，无法得到正确的结果，比如 1-1=0 这个运算。</p><ol><li>用原码进行计算减法，结果是不正确的：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 &#x3D; 1 + (-1) &#x3D; 0000 0001(原) + 1000 0001(原) &#x3D; 1000 0010(原) &#x3D; -2</span><br></pre></td></tr></table></figure><ol start="2"><li>用反码进行计算减法，得到结果的真值是正确的，但是对于 0 这个结果具有特殊性。对于人类理解来说 +0 和 -0 是相同的，但对于机器而言，带有符号的 0 没有意义，且 0 会存在 0000 0000 和 1000 0000 两个编码。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 &#x3D; 1 + (-1) &#x3D; 0000 0001(反) + 1111 1110(反) &#x3D; 1111 1111(反) &#x3D; 1000 0000(原) &#x3D; -0</span><br></pre></td></tr></table></figure><ol start="3"><li>用补码进行计算减法，能够修复原码中 0 的符号正负之分，及存在两个编码的问题。 0 只有一个编码 0000 0000</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 &#x3D; 1 + (-1) &#x3D; 0000 0001(补) + 1111 1111(补) &#x3D; 0000 0000(补) &#x3D; 0000 0000(原) &#x3D; 0</span><br></pre></td></tr></table></figure><p>而且可以用 1000 0000(补) 来表示整数 -128</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 - 127 &#x3D; -1 + (-127) &#x3D; 1000 0000(原) + 1111 1111(原) &#x3D; 1111 1111(补) + 1000 0001(补) &#x3D; 1000 0000(补)</span><br></pre></td></tr></table></figure><p>实际上就是以前的 -0 用来表示 -128， 因此 -128 并没有原码和反码的表示（对 -128 的补码 1000 0001 算出来的原码是 0000 0000 是不正确的）</p><p>在 8 位二进制中：</p><ul><li>使用原码/反码表示的范围为 [-127, +127]， 包含 +0 和 -0 共 256 个数</li><li>使用补码表示的范围为 [-128, +127]， 0 没有符号</li></ul><p>由于机器使用补码，能够多表示一个最低数，那么 8 位的二进制数用原码或反码表示的范围是 [-127, 127], 而用补码表示的范围是 [-128, 127]</p><p>编程中常用到的 32 为 int 类型，能够表示的范围是 [-2^31, 2^31-1]</p><h3 id="INT32"><a href="#INT32" class="headerlink" title="INT32"></a>INT32</h3><p>32 位的二进制数可以用 16 进制来表示：也就是将二进制的每相邻 4 位作为一个二进制数，计算出其值，再用 16 进制来表示。<br>比如 32 位的最大值： 0111 1111 1111 1111 1111 1111 1111 1111 （第一位是符号位）<br>用 16 进制表示就是： 0x7fff ffff （0x 开头表示 16 进制，16 进制的 15 是 f）</p><p>对于有符号的 32 位整数，0x8000 0000 可以表示其最小值<br>其二进制的原码是： 1000 0000 0000 0000 0000 0000 0000 0000 （最左边的 1 是符号位）<br>反码是： 1111 1111 1111 1111 1111 1111 1111 1111 （符号位不变，其他取反）<br>补码是： 1 1000 0000 0000 0000 0000 0000 0000 0000 （反码 +1， 有进位）<br>补码的值为 -2^31</p><p>有符号的 32 位的最大值为 0x7fff ffff<br>有符号的 32 位的最小值为 0x8000 0000</p><h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><p>编程题： 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、* 、/四则运算符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> num2:</span><br><span class="line">            sum = (num1 ^ num2) &amp; <span class="number">0xffffffff</span></span><br><span class="line">            carry = <span class="number">0xffffffff</span> &amp; (num1 &amp; num2) &lt;&lt; <span class="number">1</span></span><br><span class="line">            num1 = sum</span><br><span class="line">            num2 = carry</span><br><span class="line">        <span class="keyword">return</span> num1 <span class="keyword">if</span> num1 &lt;= <span class="number">0x7fffffff</span> <span class="keyword">else</span> ~(num1^<span class="number">0xffffffff</span>) <span class="comment"># ~(num1^0xffffffff) 相当于 num1- 2 ** 32</span></span><br></pre></td></tr></table></figure><p>在 python 中，要解决这道题比较麻烦的一点在于 python 中的位运算需要进行越界检查，要理解这道题的解决方法需要学习一下关键点：</p><ol><li><p>原码、反码、补码</p></li><li><p>越界检查<br>由于 python 的 long 类型可以表示无限位，不存在数值溢出情况，因此要人工设置边界，避免死循环。在编程中常用到的是 32 位整形，因此我们把数值和 0xffffffff 进行按位与操作， 0xffffffff 代表 16 进制下的边界，也就是 32 位整数的边界。</p></li><li><p>正负数判断<br>正数 &amp; 0xffffffff 得到的数仍是其本身<br>负数 &amp; 0xffffffff 得到对应二进制数的真值，得到的值会超过最大值</p></li></ol><p>比如 -15 &amp; 0xff = 1000 1111(原) &amp; 1111 1111 = 1111 0001(补) &amp; 1111 1111 = 1111 0001 = 241<br>而 8 为二进制的最大值为 127，因此 -15 &amp; 0xff 超过了 127，因此我们可以根据结果与最大值比较判断是正数还是负数。</p><p>32 位整数的最大值为 0x7fffffff，如果 num1 &lt;= 0xfffffff，就返回本身；否则，返回原来负数的值，也就是 <code>~(num1^0xffffffff)</code></p><p>参考 <a href="https://blog.csdn.net/lrs1353281004/article/details/87192205" target="_blank" rel="noopener">https://blog.csdn.net/lrs1353281004/article/details/87192205</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 垃圾回收机制</title>
      <link href="/2019/03/11/python/Python-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/03/11/python/Python-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>GC 作为现代编程语言的自动内存管理机制，用于找到内存中无用的垃圾资源，并清除这些垃圾并把内存让出来给其他对象使用。</p><p>python 中的垃圾回收采用以<strong>引用计数机制</strong>为主，<strong>标记-清除</strong>和<strong>分代收集</strong>两种机制为辅的策略。</p><a id="more"></a><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>python 默认的垃圾回收机制是引用计数。</p><p>原理：</p><ol><li>每个对象维护一个 ob_ref 字段，用来记录该对象当前被引用的次数。</li><li>每当新的引用指向该对象时，它的引用计数 ob_ref + 1；每当该对象的引用失效时计数 ob_ref - 1。</li><li>当对象的引用计数为 0，该对象立即被回收，对象占用的内存空间将被释放。</li></ol><p>缺点： 不能解决对象的循环引用问题</p><h3 id="计数器-1-的情况"><a href="#计数器-1-的情况" class="headerlink" title="计数器 +1 的情况"></a>计数器 +1 的情况</h3><ul><li>对象被创建，如 a = 23</li><li>对象被引用，如 b = a</li><li>对象被作为参数，传入到一个函数中，如 func(a)</li><li>对象作为一个元素，存储在容器中，如 list1 = [a,a]</li></ul><h3 id="计数器-1-的情况-1"><a href="#计数器-1-的情况-1" class="headerlink" title="计数器 -1 的情况"></a>计数器 -1 的情况</h3><ul><li>对象的别名被显式销毁，如 del a</li><li>对象的别名被赋予新的对象，如 a = 24</li><li>一个对象离开它的作用域，如 f 函数执行完毕时，func 函数中的局部变量（全局变量不会）</li><li>对象所在的容器被销毁，或从容器中删除对象</li></ul><p>Python 源码中，通过 Py_INCREF 和 Py_DECREF 两个宏来管理对象的引用计数，代码在 object.h</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'object born id:%s'</span> % str(hex(id(self))))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(c)</span>:</span></span><br><span class="line">    print(<span class="string">'obejct refcount is: '</span>,sys.getrefcount(c)) <span class="comment"># getrefcount()方法用于返回对象的引用计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = A() <span class="comment"># 生成对象</span></span><br><span class="line">    func(a)</span><br><span class="line"></span><br><span class="line">    b = a <span class="comment"># 增加引用</span></span><br><span class="line">    func(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> b <span class="comment"># 销毁引用对象b</span></span><br><span class="line">    func(a)</span><br></pre></td></tr></table></figure><p>运行结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object born id:0x2e1694e6eb8</span><br><span class="line">obejct refcount is:  4</span><br><span class="line">obejct refcount is:  5</span><br><span class="line">obejct refcount is:  4</span><br></pre></td></tr></table></figure><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>循环引用是一个对象直接或者间接引用自己本身，引用链形成一个环。</p><p>A 和 B 相互引用，而再没有外部引用 A 与 B 中的任何一个，它们的引用计数虽然都为 1，但显然应该被回收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123; &#125; <span class="comment"># a 的引用计数为 1</span></span><br><span class="line">b = &#123; &#125; <span class="comment"># b 的引用计数为 1</span></span><br><span class="line">a[<span class="string">'b'</span>] = b  <span class="comment"># b 的引用计数 + 1</span></span><br><span class="line">b[<span class="string">'a'</span>] = a  <span class="comment"># a 的引用计数 + 1</span></span><br><span class="line"><span class="keyword">del</span> a <span class="comment"># a 的引用 - 1，最后 a 的引用为 1</span></span><br><span class="line"><span class="keyword">del</span> b <span class="comment"># b 的引用 - 1, 最后 b 的引用为 1</span></span><br></pre></td></tr></table></figure><p>执行完 del 后，a、b 已经没有任何引用指向这两个对象，但是这两个对象各包含一个对方对象的引用，虽然最后两个对象都无法通过其它变量来引用这两个对象了。<br>这对 GC 来说是两个垃圾对象，但是他们的引用计数并没有减少到零。因此用引用计数法，他们不会被回收，会一直驻留在内存中，就会造成了内存泄漏（内存空间在使用完毕后未释放）。</p><p>为了解决对象的循环引用问题，python 引入了标记-清除和分代回收两种 GC 机制。</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>标记清除（Mark—Sweep）算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。</p><p>python 的循环引用一般发生在容器对象（内部可持有对其他对象的引用）之间， 因此标记清除法主要处理的一些容器对象，如 list、dict、tuple，instance 等，python 使用一个双向链表将这些容器对象组织起来。</p><p>两个阶段：</p><ol><li>标记阶段，GC 把所有的活动对象打上标记（垃圾检测）</li><li>将没有标记的对象（即非活动对象）回收</li></ol><p>GC 通过有向连通图来判断活动对象和非活动对象。对象构成有向图的节点，引用关系构成有向图的边，从根对象出发，沿着有向边遍历对象，可达的对象标记为活动对象，不可达的对象即要被清除的非活动对象。根对象是全局变量、调用栈、寄存器。</p><ol><li>对于每一个容器对象, 设置一个 gc_refs 值, 并将其初始化为该对象的引用计数值.</li><li>对于每一个容器对象, 找到所有其引用的对象, 将被引用对象的 gc_refs 值减 1.</li><li>执行完步骤 2 以后所有 gc_refs 值还大于 0 的对象都被非容器对象引用着, 至少存在一个非循环引用. 因此 不能释放这些对象, 将他们放入另一个集合.</li><li>在步骤 3 中不能被释放的对象, 如果他们引用着某个对象, 被引用的对象也是不能被释放的, 因此将这些 对象也放入另一个集合中.</li><li>此时还剩下的对象都是无法到达的对象. 现在可以释放这些对象了.</li></ol><p>缺点：清除非活动的对象前必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>分代回收是以空间换时间的操作方式，是建立在标记清除技术基础之上，也是用于处理容器对象。</p><p>python 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代。 分为 3 “代”： 年轻代（第 0 代）、中年代（第 1 代）、老年代（第 2 代），对应的是 3 个链表，它们的垃圾收集频率根据对象的存活时间的增大而减小。</p><p>新创建的对象都分配在第 0 代，第 0 代链表的总数达到上限时，python 垃圾收集机制就会被触发，把可以被回收的对象回收掉，而不会回收的对象被移到第 2 代去，依此类推，第 3 代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>三种情况会触发垃圾回收：</p><ol><li>import gc 模块，显式调用 gc.collect()</li><li>当 gc 模块的计数器达到垃圾回收的阀值时，自动执行</li><li>程序退出时</li></ol><h3 id="gc-模块"><a href="#gc-模块" class="headerlink" title="gc 模块"></a>gc 模块</h3><p>gc 模块提供一个接口给开发者设置垃圾回收的选项，gc 的一个主要功能就是解决循环引用的问题。</p><p><strong>常用函数：</strong></p><ol><li><p>gc.set_debug(flags)： 设置 gc 的 debug 日志，一般设置为 gc.DEBUG_LEAK</p></li><li><p>gc.collect([generation]) 显式垃圾回收，可以输入参数，0 代表只检查第一代的对象，1 代表检查一，二代的对象，2 代表检查一，二，三代的对象，不指定默认为 2。 返回不可达对象的数目。</p></li><li><p>gc.set_threshold(threshold0[, threshold1[, threshold2]) 设置自动执行垃圾回收的频率。</p></li><li><p>gc.get_count() 获取当前自动执行垃圾回收的计数器，返回一个长度为 3 的列表</p></li></ol><p><strong>注意：</strong><br>如果循环引用中，两个对象都定义了 <code>__del__</code> 方法，gc 模块不会销毁这些不可达对象，因为 gc 模块不知道应该先调用哪个对象的 <code>__del__</code> 方法，所以为了安全起见，gc 模块会把对象放到 gc.garbage 中，但是不会销毁对象，需要显式调用 gc.garbage 里面的对象的 <code>__del__</code> 来打破僵局。</p><h2 id="python-内存泄露"><a href="#python-内存泄露" class="headerlink" title="python 内存泄露"></a>python 内存泄露</h2><p>内存泄露的几种情况：</p><ol><li>存在循环引用，gc 不能释放</li><li>存在全局对象，该对象不断的变大，占据内存</li><li>使用了 c 或者 c++ 扩展，扩展内存溢出了</li></ol><h3 id="查找内存泄露：-使用-gc-、objgraph"><a href="#查找内存泄露：-使用-gc-、objgraph" class="headerlink" title="查找内存泄露： 使用 gc 、objgraph"></a>查找内存泄露： 使用 gc 、objgraph</h3><p>objgraph 的实现调用了 gc 的这几个函数：gc.get_objects(), gc.get_referents(), gc.get_referers()，然后构造出对象之间的引用关系。</p><p>如果我们怀疑一段代码、一个模块可能会导致内存泄露，那么首先调用一次 obj.show_growth()， 然后调用相应的函数，最后再次调用 obj.show_growth()，看看是否有增加的对象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://sutune.me/2018/10/14/python-GC/" target="_blank" rel="noopener">Python 垃圾回收机制</a><br><a href="#https://www.cnblogs.com/xybaby/p/7491656.html">使用gc、objgraph干掉python内存泄露与循环引用！</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 正则表达式</title>
      <link href="/2019/03/07/python/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/03/07/python/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>正则表达式的设计思想是用一种描述性语言来给字符串定义一个规则，凡是符合规则的字符串，就认为是匹配的。</p><a id="more"></a><h2 id="正则表达式原理"><a href="#正则表达式原理" class="headerlink" title="正则表达式原理"></a>正则表达式原理</h2><h3 id="正则表达式引擎"><a href="#正则表达式引擎" class="headerlink" title="正则表达式引擎"></a>正则表达式引擎</h3><p>正则表达式的引擎可以分为两类：</p><ul><li>DFA（Deterministic finite automaton）: 确定型有穷自动机</li><li>NFA（Non-deterministic finite automaton）: 非确定型有穷自动机</li></ul><p>DFA 对于字符串里的每一个字符只扫描一次，速度快，但特性较少，不支持惰性匹配和回溯。 目前使用 DFA 引擎的语言和工具有：awk、egrep 和 lex。</p><p>NFA 需要反复回溯，速度慢，但特性丰富，因此应用广泛，是主要的正则表达式引擎。Perl、Ruby、Python 的 re 模块，java 和 .NET 的 regex 库都是基于 NFA。</p><h4 id="NFA"><a href="#NFA" class="headerlink" title="NFA"></a>NFA</h4><p>传统的 NFA 接收找到的第一个匹配，所以可能会导致其他可能更长的匹配未被发现。</p><p>POSIX NFA 与传统的 NFA 引擎类似，不同的是 POSIX NFA 可以确保在已经找到可能的最长的匹配之前，继续回溯。POSIX NFA 引擎速度慢于传统 NFA 引擎。</p><h3 id="字符串组成"><a href="#字符串组成" class="headerlink" title="字符串组成"></a>字符串组成</h3><p>字符串由字符和位置组成。 如 <code>abc</code> 包括三个字符和四个位置。</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1552202626/rechar.png" width="30%"></div><h3 id="占有字符和零宽度"><a href="#占有字符和零宽度" class="headerlink" title="占有字符和零宽度"></a>占有字符和零宽度</h3><p><strong>占有字符</strong>： 正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的。</p><p><strong>零宽度</strong>： 如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是零宽度的。</p><p>占有字符是互斥的，零宽度是非互斥的。也就是一个字符，同一时间只能由一个子表达式匹配，而一个位置，却可以同时由多个零宽度的子表达式匹配。</p><h3 id="控制权"><a href="#控制权" class="headerlink" title="控制权"></a>控制权</h3><p>正则表达式当开始匹配的时候，一个正则匹配单元获得控制权，从字符串中的某一个位置开始尝试匹配。</p><p>一个正则匹配单元开始尝试匹配的位置，是从前一个正则匹配单元匹配成功的结束位置开始。</p><h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><p>正则表达式的匹配过程，NFA 采用回溯方法，详见 <a href="https://zhuanlan.zhihu.com/p/27417442" target="_blank" rel="noopener">正则表达式回溯法原理</a></p><h2 id="Python-中的正则表达式"><a href="#Python-中的正则表达式" class="headerlink" title="Python 中的正则表达式"></a>Python 中的正则表达式</h2><p>在 Python 中使用正则表达式需要引入 re 模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><p>由于 Python 的字符串本身也用 <code>\</code> 转义，使用 Python 的 <code>r</code> 前缀，可以忽略编程语言中对 <code>\</code> 的转义，只关心正则表达式中的 <code>\</code>。 用法在正则表达式前面加 <code>r</code>， 如 <code>r&#39;\d&#39;</code>。</p><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><p>compile 用于编译正则表达式，生成一个 pattern 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(pattern[, flag])</span><br></pre></td></tr></table></figure><p>flag 表示匹配模式，比如忽略大小写，多行模式等，可以通过 <code>|</code> 选择多种匹配模式。</p><ul><li>re.l 忽略大小写</li><li>re.M 多行模式</li></ul><p>生成 pattern 后，就可以利用 pattern 的一系列方法对文本进行匹配查找。</p><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>match 从字符串的起始位置（也就是 index=0）开始匹配，若起始位置没有匹配成功就返回 None。 match 是一次匹配，只要找到一个匹配结果就返回，匹配成功则返回一个 Match 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string[, flag=<span class="number">0</span>])</span><br><span class="line">pattern.match(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure><p>可选参数：</p><ul><li>flag 为标志位，表示匹配模式 </li><li>pos 和 endpos 指定字符串的起始位置和终止位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(re.match(<span class="string">r'\d+'</span>, <span class="string">'one12twothree34four'</span>))</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = re.compile(<span class="string">r'\d+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(pattern.match(<span class="string">'one12twothree34four'</span>, <span class="number">3</span>))</span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">3</span>, <span class="number">5</span>), match=<span class="string">'12'</span>&gt;</span><br></pre></td></tr></table></figure><p>对于 Match 对象，有几个常用方法：</p><ul><li>group(nums=0) 获取一个或多个分组匹配的字符串，默认是 0</li><li>groups() 返回一个包含所有小组字符串的元组，从 1 开始</li><li>start() 获取分组匹配的子串的起始位置</li><li>end() 获取分组匹配的子串的终止位置</li><li>span() 获取分组匹配的子串的起始位置和终止位置，返回一个元组</li></ul><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>search 查找字符串的任意位置，扫描整个字符串并返回第一个成功的匹配，没有符合的返回 None。 匹配成功，也是返回一个 Match 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, string[, flag=<span class="number">0</span>])</span><br><span class="line">pattern.search(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure><p>注意 search 和 match 的区别，search 是查找字符串任意位置， match 必须要起始位置匹配。</p><h3 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h3><p>替换字符串中的匹配项 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>repl 为替换的字符串，也可以是一个函数; count 为模式匹配替换的最大次数，默认 0 是替换所有。</p><h3 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h3><p>re.match 和 re.search 都是值匹配一次，而 findall 匹配所有，返回列表形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = re.compile(<span class="string">r'\d+'</span>) <span class="comment"># 查找数字</span></span><br><span class="line">res = pattern.findall(string)</span><br></pre></td></tr></table></figure><h3 id="finditer"><a href="#finditer" class="headerlink" title="finditer"></a>finditer</h3><p>与 findall 类似，但将匹配成功的结果作为一个迭代器返回</p><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>按照能够匹配的子串将字符串分割后返回列表，maxsplit 指定最大分割次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(pattern, string[, maxsplit=<span class="number">0</span>[, flags=<span class="number">0</span>]])</span><br></pre></td></tr></table></figure><h2 id="正则表达式的元数据"><a href="#正则表达式的元数据" class="headerlink" title="正则表达式的元数据"></a>正则表达式的元数据</h2><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1552040609/re.jpg"></div><p><code>\&lt;</code> 表示词首，如 <code>\&lt;abc</code> 表示以 abc 为首的词<br><code>\&gt;</code> 表示词尾，如 <code>\&gt;abc</code> 表示以 abc 结尾的词</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.runoob.com/python/python-reg-expressions.html" target="_blank" rel="noopener">[1] Python 正则表达式| 菜鸟教程</a></p><p><a href="https://zhuanlan.zhihu.com/p/27417442" target="_blank" rel="noopener">[2] 正则表达式回溯法原理</a></p><p><a href="https://blog.csdn.net/lxcnn/article/details/4304651" target="_blank" rel="noopener">[3] 正则基础之——NFA引擎匹配原理</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 多进程与多线程</title>
      <link href="/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/03/03/python/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在多核 CPU 时代，使用多进程和多线程能够充分利用 CPU 多核性能来提高程序的执行效率。 本文将着重介绍 Python 多进程和多线程的区别和应用场景选取。</p><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。每个应用程序都有一个自己的进程，提供执行程序所需的所有资源。</p><p>每个进程启动时都会最先产生一个线程，即主线程。然后再由主线程创建其他线程。进程是并行的，即同一时刻可以运行多个进程。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统进行运算调度的最小单位，被包含在进程之中，是进程的实际运作单位。</p><p>一条线程是指进程中一个单一顺序的控制流，一个进程中有多个线程，每条线程并发执行不同的任务。线程是并发的，存在交替执行的情况。</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>一个程序至少有一个进程，一个进程至少有一个线程。</p><ol><li>根本区别：进程是资源分配的基本单位，线程是程序执行的最小单位</li><li>开销方面：每个进程有独立的代码和数据空间，每启动一个进程，系统会为他分配地址空间，进程间的切换有较大开销；同一类线程共享代码和数据空间，切换和创建的开销较小</li><li>线程通信更加方便，同一进程下的线程共享全局变量、静态变量等数据；而进程需要以通信方式(IPC)进行</li><li>由于进程有自己独立的地址空间，因此多进程程序更加健壮；而多线程程序有一个线程挂掉，全部线程都会挂掉</li></ol><h3 id="进程通信与线程通信"><a href="#进程通信与线程通信" class="headerlink" title="进程通信与线程通信"></a>进程通信与线程通信</h3><p>线程通信： 同一进程下的线程共享相同的数据空间，可以直接通信。 需要做好同步/互斥 mutex，保护共享的全局变量。</p><p>进程通信： 需要通过操作系统，以 IPC 方式进行。</p><ol><li>管道： 是半双工通信方式，数据只能单向流动，只能在父子进程或者兄弟进程中使用。 </li><li>命名管道： 是半双工的通信方式，但允许无亲缘关系进程间的通信。 命名管道是一种 FIFO 对象，常用于客户端-服务器通信。</li><li>消息队列： 消息队列是消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号量： 是一个计数器，用于为多个进程提供对共享数据对象的访问。</li><li>共享内存： 映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式。需要使用信号量用来同步对共享存储的访问。</li><li>套接字： 与其它通信机制不同的是，它可用于不同机器间的进程通信</li></ol><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程 Coroutine：又称微线程，纤程。是一种程序组件，协程看上去是子程序（函数），但在执行过程中在子程序内部可以中断，转而执行其他子程序（不是调用），在适当的时候再返回来执行。  </p><p>特点：只有一个线程执行。  </p><p>优势：执行效率高，由于子程序切换不是由线程，而是由程序自身控制，因此没有线程切换的消耗；不需要多线程的锁机制，由于只有一个线程，不存在同时写变量冲突，协程中控制共享资源不加锁。<br>python generator 的 yield 可以在一定程度上实现协程。</p><ul><li>线程由操作系统控制</li><li>协程由程序自身控制</li></ul><h2 id="Python-多线程"><a href="#Python-多线程" class="headerlink" title="Python 多线程"></a>Python 多线程</h2><p>Python 标准库提供了 <code>_thread</code> 和 <code>threading</code> 两个模块进行多线程操作，<code>_thread</code> 是低级模块，<code>threading</code> 是高级模块，对 <code>_thread</code> 进行了封装， 因此一般开发中只需使用 <code>threading</code> 模块。</p><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>启动线程有两种方法</p><ol><li>直接使用 threading.Thread()，把一个函数传入并创建 Thread 实例，然后调用 start() 开始执行。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个函数名可随便定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">    print(<span class="string">'thread %s ended'</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">'thread %s is running...'</span> % threading.current_thread().name)</span><br><span class="line">    t1 = threading.Thread(target=run, args=(<span class="number">1000000</span>,), name=<span class="string">"thread1"</span>)</span><br><span class="line">    t2 = threading.Thread(target=run, args=(<span class="number">10</span>,), name = <span class="string">"thread2"</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># t1.join() # 使主线程在子线程结束后再退出</span></span><br><span class="line">    <span class="comment"># t2.join()</span></span><br><span class="line">    print(<span class="string">'thread %s ended'</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread MainThread is running...</span><br><span class="line">thread thread1 is running...</span><br><span class="line">thread thread2 is running...</span><br><span class="line">thread thread2 ended</span><br><span class="line">thread MainThread ended</span><br><span class="line">thread thread1 ended</span><br></pre></td></tr></table></figure><p>任何进程都会默认启动一个线程，叫做主线程，主线程又可以启动新的线程。 threading 模块中的 <code>current_thread()</code> 方法可以返回当前执行的实例。 主线程实例名字为 <code>MainThread</code>，子线程名字可以在创建时指定。</p><p>我们注意到上面的结果中，主线程 MainThread 结束后，子线程 thread1 仍在运行，可以通过 <code>join()</code> 方法进行线程合并。 join() 函数执行顺序是逐个执行每个线程，执行完毕后继续往下执行，能够使主线程在子线程结果后再退出。</p><ol start="2"><li>继承 threading.Thread 来定义线程类，重写 run 方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        super(MyThread, self).__init__() <span class="comment"># 重构 run() 函数必须写</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"thread %s is running..."</span> %self.n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">"thread1"</span>)</span><br><span class="line">    t1.start()</span><br></pre></td></tr></table></figure><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>由于线程之间数据共享，当有多个线程对同一个共享数据进行操作，就可能把数据改乱，因此需要考虑线程安全问题。 </p><p>threading 模块中定义了 <code>Lock</code> 类，提供<strong>互斥锁</strong>的功能来保证多线程情况下数据的一致性。</p><p>Lock 锁的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock = threading.Lock() <span class="comment"># 创建锁</span></span><br><span class="line">lock.acquire([timeout]) <span class="comment"># 锁定，可以设置 timeout，在超时后通过返回值可以判断是否得到了锁</span></span><br><span class="line">lock.release() <span class="comment"># 释放</span></span><br></pre></td></tr></table></figure><p>定义一个共享变量 balance，初始值为 0，创建两个线程进行操作，理论上结果应该是 0。 但实际上，如果循环的次数多的话，最终结果不一定会是 0。</p><p>原因是: 在操作系统中，高级语言的一条语句在 CPU 中执行其实是若干条语句。<br>就比如 <code>balance = balance + n</code>，会先计算出 balance + n 并将结果存入临时变量中， 再将临时变量的值赋给 balance。 因此，多个线程同时修改 balance 的时候，就可能把它改乱。</p><p>解决方法： 给 change() 加锁，当 thread1 执行 change() 时，该线程获得锁，那么其他线程就不能执行 change()，只能等待锁释放。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">balance = <span class="number">0</span> <span class="comment"># 假设这是存款</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance += n</span><br><span class="line">    balance -= n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            change(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = threading.Thread(target=run, args=(<span class="number">5</span>, ))</span><br><span class="line">    t2 = threading.Thread(target=run, args=(<span class="number">8</span>, ))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure><p>使用锁能够确保某段关键代码只由一个线程从头到尾完整执行，而缺点是阻止了多线程并发执行，效率降低。</p><h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p>对于其他语言，CPU 是多核时可以支持多个线程同时执行，但 python 在设计时有 GIL（Global Interpreter Lock）全局解释锁，导致无论是单核还是多核，只能同时允许一个线程执行，无法利用多线程实现多核任务。GIL 锁只在 Cpython 中存在。</p><p>在一个 python 进程中，GIL 锁只有一个，某个线程想要执行，就必须拿到 GIL。在 python3 中，GIL 使用计时器，当执行时间达到阈值时，当前线程就释放 GIL 锁。</p><p>多核多线程比单核多线程更差，因为在单核下多线程，每次释放 GIL，唤醒的那个线程都能获取到 GIL 锁，能够无缝执行。<br>但多核下，CPU0 释放 GIL 后，其他 CPU 上的线程都会进行竞争，但 GIL 可能会马上又被 CPU0 拿到，导致其他几个 CPU 上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低</p><p>python 可以用多进程实现多核任务，多个 python 进程有各自独立的 GIL 锁，互不影响。</p><h2 id="Python-多进程"><a href="#Python-多进程" class="headerlink" title="Python 多进程"></a>Python 多进程</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><p>在 linux/unix 中，可以使用 fork() 调用实现多进程。fork() 函数通过系统调用创建一个与原来进程几乎完全相同的进程，相当于把当前进程（父进程）复制了一份（子进程）。</p><p>fork() 函数的特性在于： 调用一次，会返回两次，是父进程和子进程在各自的地址空间返回，可能有三种不同的返回值。</p><ol><li>如果成功创建子进程，在父进程中，返回子进程的 ID</li><li>如果成功创建子进程，在子进程中，返回 0</li><li>如果创建失败，返回 -1</li></ol><p>python 的 os 模块封装了 fork() 方法，子进程调用 getppid() 可以得到父进程的 ID, getpid() 是得到当前进程。 要注意的是，在 windows 中没有 fork() 方法.</p><p>子进程是在 fork 之后开始向下执行，而不是从头开始执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(<span class="string">'process %s start.'</span> %os.getpid())</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'I am child process %s, my parent is %s.'</span> %(os.getpid(), os.getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'I am %s, I created a child process %s.'</span> %(os.getpid(),pid))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process 26601 start.</span><br><span class="line">I am 26601, I created a child process 26602.</span><br><span class="line">I am child process 26602, my parent is 26601.</span><br></pre></td></tr></table></figure><h3 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h3><p>要实现跨平台的多进程，可以使用 multiprocessing 模块，提供一个 Process 类来代表一个进程对象。</p><p>Process 类与 Thread 类相似，有两种使用方法：</p><ol><li>直接使用 Process</li></ol><p>创建子进程实例时，只需要传入执行函数和函数参数，start() 方法启动子进程，join() 会等待子进程执行完毕，用于进程同步。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">p = multiprocessing.Process(targte=fun, args=(<span class="number">1</span>,<span class="number">2</span>,))</span><br><span class="line">p.start()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure><ol start="2"><li>继承 Process 来自定义进程类，重写 run 方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">super(MyProcess, self).__init__()</span><br><span class="line">self.name = name</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">print(os.getpid(), self.name)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]:</span><br><span class="line">p = MyProcess(name)</span><br><span class="line">p.start()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure><h3 id="进程池-Pool"><a href="#进程池-Pool" class="headerlink" title="进程池 Pool"></a>进程池 Pool</h3><p>进程池 Pool 可以用来批量创建子进程，对 Pool 对象调用 join() 方法会等待所有子进程执行完毕，之前必须先调用 close() 方法，调用 close() 后就不能再继续添加新进程。</p><p>Pool 常用方法</p><table><thead><tr><th align="left">方法</th><th align="center">含义</th></tr></thead><tbody><tr><td align="left">apply()</td><td align="center">同步执行（串行）</td></tr><tr><td align="left">apply_async()</td><td align="center">异步执行（并行）</td></tr><tr><td align="left">terminate()</td><td align="center">立刻关闭进程池</td></tr><tr><td align="left">close()</td><td align="center">等待所有进程结束后，才关闭进程池</td></tr><tr><td align="left">join()</td><td align="center">主进程等待所有子进程执行完毕，必须在 close() 或 terminate() 之后用</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(arg1, agr2)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">size = multiprocessing.cpu_count()</span><br><span class="line">pool = multiprocessing.Pool(processes = size) <span class="comment"># 不指定的话，pool 的默认大小为 CPU 核数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">pool.apply_async(fun, args=(<span class="number">1</span>, <span class="number">2</span>, ))</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><h3 id="python-中的进程通信"><a href="#python-中的进程通信" class="headerlink" title="python 中的进程通信"></a>python 中的进程通信</h3><p>进程之间不共享数据， 进程间需要通信的话可以使用 multiprocess 的 Queue, Pipes 等方式来交换数据。</p><h4 id="multiprocess-Queue"><a href="#multiprocess-Queue" class="headerlink" title="multiprocess.Queue"></a>multiprocess.Queue</h4><p>Queue 是多进程安全的队列，可以实现多进程之间的数据传递。主要有 put 和 get 两个函数。put() 用于插入数据到队列中，get() 是从队列中读取并删除一个元素。</p><h3 id="子进程-subprocess"><a href="#子进程-subprocess" class="headerlink" title="子进程 subprocess"></a>子进程 subprocess</h3><p>subprocess 能够方便地启动一个子进程，并控制输入输出。可以用于替换 os.system, os.popen 等方法。</p><h4 id="subprocess-Popen-类"><a href="#subprocess-Popen-类" class="headerlink" title="subprocess.Popen 类"></a>subprocess.Popen 类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.Popen(args, stdin=<span class="literal">None</span>, stdout=<span class="literal">None</span>, stderr=<span class="literal">None</span>, shell=<span class="literal">False</span>, executable=<span class="literal">None</span>, ...)</span><br></pre></td></tr></table></figure><p>创建并返回一个子进程，并在子进程中执行制定的程序。</p><ul><li>args： 必填，要执行的命令或可执行文件的路径，及传给程序的参数</li><li>stdin： 子进程的标准输入</li><li>stdout： 子进程的标准输出，可以制定输出到文件</li><li>stderr： 子进程的标准错误输出</li><li>shell： True 则指定使用 shell 运行程序</li><li>executable： 指定子进程在什么 shell 中运行，默认为 /bin/sh</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subporcess</span><br><span class="line">p = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">stdout, stderr = p.communicate()</span><br><span class="line">print(stdout)</span><br></pre></td></tr></table></figure><h4 id="subprocess-PIPE"><a href="#subprocess-PIPE" class="headerlink" title="subprocess.PIPE"></a>subprocess.PIPE</h4><p>可以被用于 Popen 的 stdin, stdout, stderr 三个参数的特殊值，表示需要创建一个新的管道。</p><h4 id="communicate"><a href="#communicate" class="headerlink" title="communicate()"></a>communicate()</h4><p><code>p.communicate(input=None)</code><br>和子进程 p 交流，将 input 的数据发送到子进程的 stdin 中，并同时读取子进程的 stdout 和 stderr。</p><p>需要注意的是： communicate() 只能通过管道和子进程通信，也就是需要设置 subprocess.PIPE； 且 communicate() 会立即阻塞父进程，直至子进程结束。</p><h2 id="选择多进程还是多线程"><a href="#选择多进程还是多线程" class="headerlink" title="选择多进程还是多线程"></a>选择多进程还是多线程</h2><p>应用程序可以分为<code>CPU 密集型</code>和<code>IO 密集型</code>两种，选择多进程还是多线程来执行程序，首先需要看程序属于哪种类型。</p><h3 id="CPU-密集型"><a href="#CPU-密集型" class="headerlink" title="CPU 密集型"></a>CPU 密集型</h3><ul><li>也叫计算密集型任务，特点：需要进行大量判断，主要消耗 CPU 资源，大部分时间用于计算、逻辑判断等 CPU 动作的程序，如计算圆周率、视频高清解码等；  </li><li>python 这种脚本语言不适合计算密集型任务，最好用 C 语言；</li><li>python CPU 密集型任务用多进程模型。</li></ul><h3 id="IO-密集型"><a href="#IO-密集型" class="headerlink" title="IO 密集型"></a>IO 密集型</h3><ul><li>涉及到网络、磁盘 IO 的任务是 IO 密集型任务，特点：CPU 消耗较少，大部分时间在等待 IO 操作完成（IO 操作速度远低于 CPU 和内存的速度）， 如 web 应用、文件处理、爬虫； 线程 A 在进行 IO 等待时可以切换到线程 B 执行，多线程可以利用 IO 阻塞等待时的空闲时间执行其他线程，提升效率。</li><li>IO 密集型任务最合适的语言是开发效率最高（代码量最少）的语言，脚本语言是首选；</li><li>python IO 密集型任务用多线程模型，多线程只使用一个 CPU 核心。</li><li>io 操作不占用 CPU（从硬盘、从网络、从内存读数据都算 io）</li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319272686365ec7ceaeca33428c914edf8f70cca383000" target="_blank" rel="noopener">[1] 进程和线程</a></p><p><a href="https://www.jianshu.com/p/a69dec87e646" target="_blank" rel="noopener">[2] Python 多进程与多线程</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 编码总结</title>
      <link href="/2019/02/25/python/Python-%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/25/python/Python-%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>计算机中存储的信息都是用二进制表示的，现实生活中用的英文、中文等字符需要经过<code>编码</code>转换为二进制才能存储在计算机中，这种转换规则便是<code>字符编码</code>。</p><a id="more"></a><h2 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h2><p>ASCII 字符集只有一种编码方式，采用单字节编码，一个字节是 8 个 bit，因此一个字节可以表示 256 种不同的状态，从 00000000 到 11111111。 但 ASCII 规定第一位为 0，因此 ASCII 共规定 128 个字符的编码。</p><p>然而，要处理中文一个字节是不够的，至少需要两个字节，且不能和 ASCII 码冲突，因此中国制定了 GB2312 来进行中文编码。但由于每个国家有自己的编码标准，在多语言混合的文本中由于冲突问题，会导致乱码显示。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>Unicode 编码把所有语言统一到一套编码中，Unicode 主要有三种编码方式，最常用的 UTF-8 将一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母用 1 个字节，汉字通常是 3 个字节，只有少数生僻字会用到 4-6 个字节编码。 注意： UTF-8 是 Unicode 的实现方式之一。</p><p>目前计算机系统通用的字符编码方式可以总结如下：</p><ol><li>在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或需要传输时，就转化为 UTF-8 编码</li><li>用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存中，编辑完成后，保存的时候再将 Unicode 转化为 UTF-8 保存到文本中。</li></ol><h2 id="Python-字符编码"><a href="#Python-字符编码" class="headerlink" title="Python 字符编码"></a>Python 字符编码</h2><p>Python 的诞生时间比 Unicode 早得多，因此 Python 的默认编码是 ASCII。 在 Python2 文件中若不显式地指定字符编码，会出现语法错误，因此为在源代码中支持非 ASCII 字符，需要在第一行指出编码格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br></pre></td></tr></table></figure><p>或者是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure><blockquote><p>注意： 以下代码都基于 python2。</p></blockquote><p>Python 有两种不同的字符串数据类型： str 和 unicode，都是 basestring 的子类。</p><p>对于同一个汉字 “好”， 用 str 表示和 unicode 表示是不同的。 用 str 表示时，对应的 UTF-8 编码是 “\xe5\xa5\xbd”, 而 Unicode 表示对应的符号是 u’\u597d’，等同于 u’好’。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'\xe5\xa5\xbd'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">u'好'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(b)</span><br><span class="line">&lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">u'\u597d'</span></span><br></pre></td></tr></table></figure><p>str 类型的字符编码具体是 UTF-8 还是其他编码方式，取决于操作系统。 str 用<strong>字节串</strong>表述更加准确，对 str 类型进行迭代，会按照其在内存中的字节序一次迭代。 </p><p>以下是 Python2 中的显示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'好a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> c</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">�</span><br><span class="line">�</span><br><span class="line">�</span><br><span class="line">a</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">u"好a"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> c</span><br><span class="line">...</span><br><span class="line">好</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>而 Python3 的默认编码格式是 Unicode 。</p><h2 id="str-与-Unicode-转换"><a href="#str-与-Unicode-转换" class="headerlink" title="str 与 Unicode 转换"></a>str 与 Unicode 转换</h2><p>str 可以通过 decode 解码成 unicode 字符串。</p><p>unicode 可以通过 encode 编码得到 UTF-8 编码格式的 str 类型的字符串。</p><blockquote><p>str –&gt; decode –&gt; unicode<br>unicode –&gt; encode –&gt; str</p></blockquote><p>如果对 unicode 错误的调用了 decode 方法，其实是会先调用 encode(default_encoding) 进行隐式转换为 str，然后再 decode 为 unicode。 而在 python2 中 default_encoding 是 ASCII，如果 unicode 字符串本身超过了 ASCII 的编码范围就会报错。 对 str 调用 encode 也是如此。 这是初学者可能经常会犯的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = <span class="string">u"好"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/encodings/utf_8.py"</span>, line <span class="number">16</span>, <span class="keyword">in</span> decode</span><br><span class="line">    <span class="keyword">return</span> codecs.utf_8_decode(input, errors, <span class="literal">True</span>)</span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can <span class="keyword">not</span> encode character <span class="string">u'\u597d'</span> <span class="keyword">in</span> position <span class="number">0</span>: ordinal <span class="keyword">not</span> <span class="keyword">in</span> range(<span class="number">128</span>)</span><br></pre></td></tr></table></figure><p>解决方法： 可以通过对 unicode 进行 encode 再 decode 得到 unicode 编码格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = <span class="string">u"好"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u.encode(<span class="string">"utf-8"</span>).decode(<span class="string">"utf-8"</span>)</span><br><span class="line"><span class="string">u'\u597d'</span></span><br></pre></td></tr></table></figure><h2 id="str-和-unicode"><a href="#str-和-unicode" class="headerlink" title="str() 和 unicode()"></a>str() 和 unicode()</h2><p>str(s) 和 unicode(s) 是两个工厂方法，分别返回 str 字符串对象和 unicode 字符串对象。 str(s) 相当于是 s.encode(‘ASCII’) 简写， unicode(s) 相当于 s.decode(‘ASCII’) 的简写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">u"好"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(s)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can <span class="keyword">not</span> encode character <span class="string">u'\u597d'</span> <span class="keyword">in</span> position <span class="number">0</span>: ordinal <span class="keyword">not</span> <span class="keyword">in</span> range(<span class="number">128</span>)</span><br></pre></td></tr></table></figure><p>s 是个 unicode 字符串，str(s) 相当于 s.encode(‘ASCII’)，而汉字 “好” 没有 ASCII 码，因此报错。解决此问题需要制定编码格式，用 s.encode(‘gbk’) 或 s.encode(‘utf-8’)。</p><h2 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h2><p>所有出现乱码的原因都可以归结为： 字符经过不同编码解码，在解码过程中使用的编码格式不一致。</p><p>防止乱码出现的最好方式是始终用同一种编码格式对字符进行编码和解码操作。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>对于形如 unicode 形式的字符串，实际上是 str 类型，将其转化成真正的 unicode 可以使用 s.decode(‘unicode-escape’)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'id\u003d215903184\u0026index\u003d0\u0026st\u003d52\u0026sid\u003d95000\u0026i'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.decode(<span class="string">'unicode-escape'</span>)</span><br><span class="line"><span class="string">u'id=215903184&amp;index=0&amp;st=52&amp;sid=95000&amp;i'</span></span><br></pre></td></tr></table></figure><p><a href="https://my.oschina.net/sallency/blog/1563298" target="_blank" rel="noopener">python2与python3字符串的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 数据结构</title>
      <link href="/2019/01/20/algorithms/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/01/20/algorithms/%E7%AE%97%E6%B3%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>对常用数据结构及 Leetcode 相关练习进行总结，包括栈与队列、哈希表、二叉树、数组、链表五个部分。</p><a id="more"></a><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>栈是一个只能从同一端插入或删除的线性表，是先进后出。插入删除端为栈顶，另一端为栈底。<br>对于栈 [1, 2, 3, 4], 1 是栈底，4 是栈顶。</p><p>队列是一个从一端插入，从另一端删除的线性表，是先进先出。插入端为队尾，删除端队头。<br>对于队列 [4, 3, 2, 1], 1 是队尾，4 是队头。</p><h3 id="用栈实现括号匹配"><a href="#用栈实现括号匹配" class="headerlink" title="用栈实现括号匹配"></a>用栈实现括号匹配</h3><p><a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">Leetcode : 20. Valid Parentheses (Easy)</a></p><p>思路：栈最典型的应用即验证配对情况，对一个有效的括号对，左括号必定在右括号前面，因此可以将所有的左括号入栈，遇到匹配的右括号就将栈顶的括号消除，必定会有至少一对括号在 s 中是相邻的，因此一直消除栈顶，如果遇到不匹配的括号，直接返回 False，但栈为空时，即没有左括号，此时仍有右括号，则返回 False，最后所有字符都遍历完成后，栈为空则返回 True， 栈非空返回 Flase。  </p><p>可以利用 dict 来存储括号对，从而提高代码效率。  </p><p>时间复杂度为 o(n), 空间复杂度为 o(n)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(s)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    dict = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'['</span>: <span class="string">']'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> dict:</span><br><span class="line">            stack.append(c)</span><br><span class="line">        <span class="keyword">elif</span> len(stack) == <span class="number">0</span> <span class="keyword">or</span> dict[stack.pop()] != c:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure><h3 id="Evaluate-Reverse-Polish-Notation"><a href="#Evaluate-Reverse-Polish-Notation" class="headerlink" title="Evaluate Reverse Polish Notation"></a>Evaluate Reverse Polish Notation</h3><p><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/description/" target="_blank" rel="noopener">Leetcode : 150. Evaluate Reverse Polish Notation (Medium)</a></p><p><a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank" rel="noopener">逆波兰式</a></p><p>除法的时候需要注意：python中的 ‘//‘ 除法和 C语言 不太一样。在 python 中，(-1)//2=-1，而在 C语言中，(-1)/2=0。<br>这道题的 oj 是默认的 C语言 中的语法，所以需要在遇到 ‘/‘ 的时候注意一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="keyword">if</span> char != <span class="string">'+'</span> <span class="keyword">and</span> char != <span class="string">'-'</span> <span class="keyword">and</span> char != <span class="string">'*'</span> <span class="keyword">and</span> char != <span class="string">'/'</span>: <span class="comment"># 如果是负数，用 isdigit() 无效</span></span><br><span class="line">            stack.append(int(char))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = stack.pop()</span><br><span class="line">            b = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">'+'</span>:</span><br><span class="line">                stack.append(a+b)</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">'-'</span>:</span><br><span class="line">                stack.append(b-a)</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">'*'</span>:</span><br><span class="line">                stack.append(a*b)</span><br><span class="line">            <span class="keyword">if</span> char == <span class="string">'/'</span>:</span><br><span class="line">                <span class="keyword">if</span> a*b &lt; <span class="number">0</span>:</span><br><span class="line">                    stack.append(-((-b)//a))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(b//a)</span><br><span class="line">    <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure><p>判断是否为整数，若为负数时，可以用 if char.lstrip(‘-‘).isdigit()</p><h3 id="最小值栈"><a href="#最小值栈" class="headerlink" title="最小值栈"></a>最小值栈</h3><p><a href="https://leetcode.com/problems/min-stack/description/" target="_blank" rel="noopener">Leetcode : 155. Min Stack (Easy)</a></p><p>问题描述：题目要求得到最小值的时间复杂度为 o(1)，因此需要以空间换时间，可以使用两个栈来实现，一个栈存储原始数据，另一个栈存储最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack, self.minstack = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minstack <span class="keyword">or</span> x &lt;= self.minstack[<span class="number">-1</span>]:  <span class="comment">#1</span></span><br><span class="line">            self.minstack.append(x)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.minstack <span class="keyword">and</span> self.minstack[<span class="number">-1</span>] == self.top():</span><br><span class="line">            self.minstack.pop()</span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.minstack[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>备注： 1. 必须要是 x &lt;= self.minstack[-1]，重复元素也应该加到 minstack 中，否则在删除时会删除唯一的 min 值。</p><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/" target="_blank" rel="noopener">Leetcode : 232. Implement Queue using Stacks (Easy)</a></p><p>问题描述：用栈来实现队列，假设队列 q = [1, 2, 3, 4]，那么其在栈里面的顺序是 s = [4, 3, 2, 1]。push() 要在队列 q 的队尾增加一个元素， 则在栈 s 中应该在栈顶增加一个元素，变为 s = [x, 4, 3, 2, 1]，可以使用两个栈来实现，一个只进行入栈 push 操作，一个只进行出栈 pop 操作，因此只需要在 instack 中追加元素 x 即可实现；pop() 删除队头元素 1，而在栈 s 中 1 是先进后出，因此可以将其全部 push 到 outstack 中，再取出栈顶元素即可。  </p><p>push() 时间复杂度 o(1)<br>pop(), peek() 时间复杂度 o(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.instack, self.outstack = [],[]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.instack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.in2out()</span><br><span class="line">        self.outstack.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.in2out()</span><br><span class="line">        <span class="keyword">return</span> self.outstack[<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.instack <span class="keyword">and</span> <span class="keyword">not</span> self.outstack</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in2out</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.outstack:</span><br><span class="line">            <span class="keyword">while</span> self.instack:</span><br><span class="line">                self.outstack.append(self.instack.pop())</span><br></pre></td></tr></table></figure><h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p><a href="https://leetcode.com/problems/implement-stack-using-queues/description/" target="_blank" rel="noopener">Leetcode : 225. Implement Stack using Queues (Easy)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue = [] </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.queue.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.queue) - <span class="number">1</span>):</span><br><span class="line">            self.queue.append(self.queue.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> self.queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.queue) - <span class="number">1</span>):</span><br><span class="line">            self.queue.append(self.queue.pop(<span class="number">0</span>))</span><br><span class="line">        result = self.queue[<span class="number">0</span>]</span><br><span class="line">        self.queue.append(self.queue.pop(<span class="number">0</span>)) <span class="comment"># 恢复原样</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.queue</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>python 的内建数据类型字典是用哈希表来实现的，使用哈希表可以快速查找一个元素是否存在，但需要一定的存储空间。因此在优先考虑时间复杂度的情况下，可以使用哈希表来以空间换时间。  </p><blockquote><p><strong>字典 dict 的遍历</strong><br>遍历 key 值：for key in dict<br>遍历 value 值：for value in dict.values()<br>遍历字典项：for kv in dict.items()<br>遍历 key 和 value 值 : for key, value in dict.items()  </p><p>dict.get(key) : 返回指定键的值，不存在则返回 None<br>dict.has_key(key) : 键在字典中返回 true，否则 false<br>dict.pop(key) ：删除该 key 和 value</p></blockquote><h3 id="两数之和-Two-Sum"><a href="#两数之和-Two-Sum" class="headerlink" title="两数之和 Two Sum"></a>两数之和 Two Sum</h3><p><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">Leetcode : 1. Two Sum (Easy)</a></p><p>思路：使用字典来存储数组元素和索引的映射，将 nums[i] 和 i 存储到 dict 中，遍历一遍数组，若 target - nums[i] 在 dict 中，则直接返回两个数的下标。  </p><p>时间复杂度为 o(n)，空间复杂度为 o(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> false</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        tmp = target - nums[i]</span><br><span class="line">        <span class="keyword">if</span> tmp <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">return</span> [dic[tmp], i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dic[nums[i]] = i</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串-Longest-Substring-Without-Repeating-Characters"><a href="#无重复字符的最长子串-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="无重复字符的最长子串 Longest Substring Without Repeating Characters"></a>无重复字符的最长子串 Longest Substring Without Repeating Characters</h3><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">Leetcode : 3. Longest Substring Without Repeating Characters(Medium)</a></p><p>思路：使用哈希表来记录字符及其位置，当遇到重复字符时，应该从该字符的下一个字符开始重新计数，并且更新该字符在哈希表中的位置值。记录计数的起始位置为 start，当前字符位置为 i，则子串的长度为 i-start+1，不断更新最大长度得到最终结果。  </p><p>注意：start &lt;= dict[s[i]] 也就是要小于等于重复字符的上一个位置市才重新开始计数，否则就加上该字符。  </p><p>时间复杂度为 o(n), 空间复杂度为 o(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        maxlength = start = <span class="number">0</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> dict <span class="keyword">and</span> start &lt;= dict[s[i]]:</span><br><span class="line">                start = dict[s[i]] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxlength = max(maxlength, i-start+<span class="number">1</span>)</span><br><span class="line">            dict[s[i]] = i</span><br><span class="line">        <span class="keyword">return</span> maxlength</span><br></pre></td></tr></table></figure><h3 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a>Single Number</h3><p><a href="https://leetcode.com/problems/single-number/description/" target="_blank" rel="noopener">Leetocde : 136. 137. Single Number(Easy)</a></p><p>思路：用哈希表来记录数字及其出现的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(nums)</span>:</span></span><br><span class="line">    cnt = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> cnt:</span><br><span class="line">            cnt[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cnt[num] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> num, count <span class="keyword">in</span> cnt.items():</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><h3 id="Repeated-DNA-Sequences"><a href="#Repeated-DNA-Sequences" class="headerlink" title="Repeated DNA Sequences"></a>Repeated DNA Sequences</h3><p><a href="https://leetcode.com/problems/repeated-dna-sequences/description/" target="_blank" rel="noopener">Leetocde : 187. Repeated DNA Sequences (Medium)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRepeatedDnaSequences</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-9</span>):</span><br><span class="line">        key = s[i:i+<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">            dic[key] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                res.append(key)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="同构字符串-Isomorphic-Strings"><a href="#同构字符串-Isomorphic-Strings" class="headerlink" title="同构字符串 Isomorphic Strings"></a>同构字符串 Isomorphic Strings</h3><p><a href="https://leetcode.com/problems/isomorphic-strings/description/" target="_blank" rel="noopener">Leetcode : 205. Isomorphic Strings (Easy)</a></p><p>问题描述：判断两个字符串是否是同构字符串，如果一个字符串 s 中的字符可以替换成别的字符，从而得到另一个字符串 t，则 s 和 t 是同构字符串。并且 s 中的所有相同字符都要被替换，保持原来的顺序，两个不同的字符不可以替换成相同的字符，字符也可以不替换。  </p><p>思路：用字典来存储 s[i] 和 t[i]，将第一个字符串 s 的字符作为 key，第二个字符串 t 的字符作为 value，遍历一遍数组，有两种情况：  </p><ol><li>当 s[i] 在 dic 中时，s[i] 的 value 不等于 t[i] 时，则直接返回 False，相等则继续遍历。  </li><li>当 s[i] 不在 dic 中时，若此时对应的 t[i] 却在 dic 的 values 中，则表明已经有一个 key 对应了这个 t[i]，现在 s[i] 对应的字符也是 t[i]，由于不能有两个不同的字符对应同一个字符，因此返回 False；否则将这一对 s[i] 作为 key，t[i] 作为 value 存入 dic 中。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">if</span> t[i] != dic[s[i]]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> t[i] <span class="keyword">in</span> dic.values():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dic[s[i]] = t[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="最长和谐序列-Longest-Harmonious-Subsequence"><a href="#最长和谐序列-Longest-Harmonious-Subsequence" class="headerlink" title="最长和谐序列 Longest Harmonious Subsequence"></a>最长和谐序列 Longest Harmonious Subsequence</h3><p><a href="https://leetcode.com/problems/longest-harmonious-subsequence/description/" target="_blank" rel="noopener">Leetcode : 594. Longest Harmonious Subsequence (Easy)</a></p><p>问题描述：找出数组中的最长和谐序列，其最大数和最小数之间只相差 1。  </p><p>思路：在最长和谐序列中，只可能出现两种数字，这两个数字之间相差 1，因此可以先对 nums 进行计数，得到 nums[i]：count[i] 的一个字典，遍历该字典，对每个 key 判断 key+1 是否在其中，并返回次数和的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_LHS</span><span class="params">(nums)</span>:</span></span><br><span class="line">    dict = collections.Counter(nums)</span><br><span class="line">    output = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> dict:</span><br><span class="line">        <span class="keyword">if</span> key + <span class="number">1</span> <span class="keyword">in</span> dict:</span><br><span class="line">           output = max(output, dict[key] + dict[key+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><blockquote><p>备注：python 标准库 collections 模块中的 Counter 类，用于跟踪值出现的次数，以字典的键对值形式进行存储，元素作为 key，其计数作为 value。</p></blockquote><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树（Binary Tree）是 n 个节点的有限集合，该集合可以为空集（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。   </p><ul><li>满二叉树的第 i 层有 2<sup>i-1</sup> 个节点， 总共有 2<sup>i</sup>-1 个节点，总节点数一定是奇数。  </li><li>若二叉树有 n 个节点，则该二叉树的高度为 h=log<sub>2</sub>(n+1)。</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>二叉树是一种递归结构，很多问题可以使用递归解决。  </p><p>下面各题中对于二叉树的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h4 id="相同树"><a href="#相同树" class="headerlink" title="相同树"></a>相同树</h4><p><a href="https://leetcode.com/problems/same-tree/description/" target="_blank" rel="noopener">Leetcode : 100. Same Tree (Easy)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> p <span class="keyword">and</span> q) <span class="keyword">or</span> (<span class="keyword">not</span> q <span class="keyword">and</span> p):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure><h4 id="对称树"><a href="#对称树" class="headerlink" title="对称树"></a>对称树</h4><p><a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener">Leetcode : 101. Symmetric Tree (Easy)</a></p><p>思路： 由于输入只有 root，而判断对称树需要比较左右节点是否相等，因此可以构造一个辅助函数 symmetric 来比较左右节点的值。  </p><ol><li>终止条件是已经到了叶子节点，即 left == None and right == None  </li><li>当左右节点的值相等时，继续递归比较左节点的左子树与右节点的右子树是否相等，以及左节点的右子树与右节点的左子树是否相等。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># 空树为对称树</span></span><br><span class="line">        <span class="keyword">return</span> self.symmetric(root.left, root.right)</span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">symmetric</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right <span class="keyword">and</span> left.val == right.val:</span><br><span class="line">            <span class="keyword">return</span> self.symmetric(left.left, right.right) <span class="keyword">and</span> self.symmetric(left.right, right.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="二叉树的高度"><a href="#二叉树的高度" class="headerlink" title="二叉树的高度"></a>二叉树的高度</h4><p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 104. Maximum Depth of Binary Tree (Easy)</a></p><p>问题描述： 求二叉树的高度，利用递归计算，返回左子树和右子树中较大的深度，再加上 1 作为原二叉树的深度。  </p><p>时间复杂度为 o(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 110. Balanced Binary Tree (Easy)</a></p><p>思路：平衡二叉树是二叉树的任意节点的两颗子树之间的高度差小于等于 1。对于平衡二叉树，其左子树和右子树也是平衡二叉树，因此可以递归判断。需要构造一个函数来求二叉树的高度，可以用之前的 maxDepth。  </p><ol><li>终止条件：当左子树和右子树的最大高度相差 1 时，返回 False  </li><li>继续递归调用 isBalanced, 判断 root.left 和 root.right 是不是平衡二叉树。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> abs(self.maxDepth(root.left) - self.maxDepth(root.right)) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="二叉树的最小高度"><a href="#二叉树的最小高度" class="headerlink" title="二叉树的最小高度"></a>二叉树的最小高度</h4><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 111. Minimum Depth of Binary Tree (Easy)</a></p><p>思路：简单思考有四种情况</p><ol><li>空树，返回 0</li><li>只有右子树，返回右子树高度</li><li>只有左子树，返回左子树高度</li><li>左右子树都有，返回左右子树高度的较小值</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> self.minDepth(root.right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.left:</span><br><span class="line">            <span class="keyword">return</span> self.minDepth(root.left) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="路径和"><a href="#路径和" class="headerlink" title="路径和"></a>路径和</h4><p><a href="https://leetcode.com/problems/path-sum/description/" target="_blank" rel="noopener">Leetcdoe : 112. Path Sum (Easy)</a></p><p>思路：利用递归实现，如果根节点为空，则直接返回 False，如果到最后都没有出现 sum == 0 的情况时，再进行一轮递归，则 root == None， 因此也返回 False。必须要注意的是最后的返回一定是递归的结果，当 sum == 0 并且该节点为叶子节点时才返回 True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        sum -= root.val</span><br><span class="line">        <span class="keyword">if</span> sum == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, sum) <span class="keyword">or</span> self.hasPathSum(root.right, sum)</span><br></pre></td></tr></table></figure><h4 id="Path-Sum-II"><a href="#Path-Sum-II" class="headerlink" title="Path Sum II"></a>Path Sum II</h4><p><a href="https://leetcode.com/problems/path-sum-ii/description/" target="_blank" rel="noopener">Leetcdoe : 113. Path Sum II (Medium)</a></p><p>需要返回路径和等于 target 的所有路径集合。<br>思路： 与上一题类似，但需要保存符合要求的节点集合，需要注意的是递归的时候不要用 append 去追加元素到 path 中，会变为全局修改。在递归时，需要判断左右子树是否存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type sum: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.findPath([], sum, root)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPath</span><span class="params">(self, path, sum, root)</span>:</span></span><br><span class="line">        path = path + [root.val]</span><br><span class="line">        sum = sum - root.val</span><br><span class="line">        <span class="keyword">if</span> sum == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            self.res.append(path)</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.findPath(path, sum, root.left)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.findPath(path, sum, root.right)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h4 id="Populating-Next-Right-Pointers-in-Each-Node"><a href="#Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="Populating Next Right Pointers in Each Node"></a>Populating Next Right Pointers in Each Node</h4><p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/description/" target="_blank" rel="noopener">Leetcode : 116. Populating Next Right Pointers in Each Node(Medium)</a></p><p>思路：将二叉树的每个节点都加上一个 next 属性，指向其右边的节点。假设每个父节点都有两个子节点。<br>因此可以如果该节点有左孩子，则必定有右孩子，此时 左孩子.next 指向 右孩子；<br>如果将节点的 next 不是 None，name说明该节点必定不是最右边的节点，则 右孩子.next = 该节点.next.left；<br>否则，该节点是最右边的节点，此时 该节点.right.next = None。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param root, a tree link node</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> root.left:</span><br><span class="line">            root.left.next = root.right</span><br><span class="line">            <span class="keyword">if</span> root.next:</span><br><span class="line">                root.right.next = root.next.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.right.next = <span class="literal">None</span></span><br><span class="line">            self.connect(root.left)</span><br><span class="line">            self.connect(root.right)</span><br></pre></td></tr></table></figure><h4 id="Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="Populating Next Right Pointers in Each Node II"></a>Populating Next Right Pointers in Each Node II</h4><p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/" target="_blank" rel="noopener">Leetcode : 117. Populating Next Right Pointers in Each Node II (Medium)</a></p><h4 id="Sum-Root-to-Leaf-Numbers"><a href="#Sum-Root-to-Leaf-Numbers" class="headerlink" title="Sum Root to Leaf Numbers"></a>Sum Root to Leaf Numbers</h4><p><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/description/" target="_blank" rel="noopener">Leetcode : 129. Sum Root to Leaf Numbers (Medium)</a></p><p>计算所有路径组成的数的和。<br>思路： 用 pre 来存储该节点 root 之前的路径组成的数，则加上该节点后的数为 pre = pre * 10 + root.val<br>然后返回左右子树相加递归的结果。 当遇到叶子节点时，该条路径遍历完，则返回 pre。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self, root, pre)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre = pre*<span class="number">10</span> + root.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line">        <span class="keyword">return</span> self.sum(root.left, pre) + self.sum(root.right, pre)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.sum(root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>DFS 解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sum = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, num)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                self.sum += num*<span class="number">10</span> + root.val</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                dfs(root.left, num*<span class="number">10</span>+root.val)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                dfs(root.right, num*<span class="number">10</span>+root.val)</span><br><span class="line">            </span><br><span class="line">        dfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.sum</span><br></pre></td></tr></table></figure><h4 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h4><p><a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 226. Invert Binary Tree (Easy)</a></p><p>思路：反转二叉树，对于一个节点 root 而言，只需要将其左孩子和右孩子交换即可实现反转，递归调用即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line"></span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)        </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="归并二叉树"><a href="#归并二叉树" class="headerlink" title="归并二叉树"></a>归并二叉树</h4><p><a href="https://leetcode.com/problems/merge-two-binary-trees/description/" target="_blank" rel="noopener">Leetcode : 617. Merge Two Binary Trees (Easy)</a></p><p>思路：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1, t2)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">and</span> <span class="keyword">not</span> t2:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> t1:</span><br><span class="line">        <span class="keyword">return</span> t2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> t2:</span><br><span class="line">        <span class="keyword">return</span> t1</span><br><span class="line">    root = TreeNode(t1.val + t2.val)</span><br><span class="line">    root.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">    root.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \   \</span><br><span class="line">4   5   6</span><br></pre></td></tr></table></figure><ol><li>层次遍历，[1, 2, 3, 4, 5, 6]</li><li>前序遍历（根左右），[1, 2, 4, 5, 3, 6]</li><li>中序遍历（左根右），[4, 2, 5, 1, 3, 6]</li><li>后序遍历（左右根），[4, 5, 2, 6, 3, 1]<br>层次遍历使用 <strong>广度优先搜索 BFS</strong> 实现，<br>前中后序遍历使用 <strong>深度优先搜索 DFS</strong> 实现。</li></ol><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 144. Binary Tree Preorder Traversal (Medium)</a></p><p>递归实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.result.append(root.val)</span><br><span class="line">            self.preorderTraversal(root.left)</span><br><span class="line">            self.preorderTraversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br></pre></td></tr></table></figure><p>非递归实现：<br>利用堆栈，用迭代来实现二叉树的前序遍历，一直将左子树进栈，root-&gt;left-&gt;right</p><ol><li>当根节点存在时，保存根节点的值，并将根节点入栈</li><li>将根节点指向左子树</li><li>当根节点不存在时（即没有左子树），栈顶元素出栈，并将根节点指向栈顶元素的右子树</li><li>循环 123 步</li></ol><blockquote><p>总结：<br>非空：访问，进栈，向左走<br>空：出栈，向右走</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 94. Binary Tree Inorder Traversal (Medium)</a></p><p>非递归实现：<br>中序遍历同样利用堆栈实现，堆栈定义与前序遍历相同。left-&gt;root-&gt;right</p><ol><li>当根节点存在时，将根节点入栈，并将根节点指向左子树</li><li>当根节点不存在时（即没有左子树），栈顶元素出栈，保存栈顶元素的值（第一次即最左节点），并将根节点指向栈顶元素的右子树</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 145. Binary Tree Postorder Traversal (Hard)</a></p><p>非递归实现：<br>后序遍历同样利用堆栈实现，left-&gt;right-&gt;root，可以通过 root-&gt;right-&gt;left 的结果逆序输出得到，即与前序遍历相似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                root = node.left</span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">Leetcode : 102. Binary Tree Level Order Traversal (Medium)</a></p><p>思路：层次遍历利用队列的先进先出特性，将先进入队列的元素 pop 出来。<br>题中需要按照层次来打印出遍历结果，可以用一个临时列表存储二叉树一层的所有节点。即用 queue 来存储当前层元素， tmp 存储下一层元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            result.append([node.val <span class="keyword">for</span> node <span class="keyword">in</span> queue])</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">Leetcode : 107. Binary Tree Level Order Traversal II (Easy)</a></p><p>层次遍历，倒序输出遍历结果; 直接翻转102的结果，return result[::-1]</p><h4 id="Binary-Tree-Right-Side-View"><a href="#Binary-Tree-Right-Side-View" class="headerlink" title="Binary Tree Right Side View"></a>Binary Tree Right Side View</h4><p><a href="https://leetcode.com/problems/binary-tree-right-side-view/description/" target="_blank" rel="noopener">Leetcode : 199. Binary Tree Right Side View (Medium)</a></p><p>复用层次遍历的代码即可，用 queue 存储当前层的节点， tmp 存储下一层的节点，输出每一层 queue 最后一个节点的值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        res.append(queue[<span class="number">-1</span>].val)</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                tmp.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                tmp.append(node.right)</span><br><span class="line">        queue = tmp</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="得到左下角节点值"><a href="#得到左下角节点值" class="headerlink" title="得到左下角节点值"></a>得到左下角节点值</h4><p><a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/" target="_blank" rel="noopener">Leetcode : 513. Find Bottom Left Tree Value (Medium)</a></p><p>思路：利用层次遍历，记录下每一层的元素，返回最后一层的第一个元素即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBottomLeftValue</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        result = root</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            result = queue[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            queue = tmp</span><br><span class="line">        <span class="keyword">return</span> result.val</span><br></pre></td></tr></table></figure><h4 id="二叉树每层节点的平均值"><a href="#二叉树每层节点的平均值" class="headerlink" title="二叉树每层节点的平均值"></a>二叉树每层节点的平均值</h4><p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/description/" target="_blank" rel="noopener">637. Average of Levels in Binary Tree (Easy)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmp = []</span><br><span class="line">            sum = <span class="number">0.0</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">                sum += node.val</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            result.append(sum/len(queue))</span><br><span class="line">            queue = tmp</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="Zigzag遍历"><a href="#Zigzag遍历" class="headerlink" title="Zigzag遍历"></a>Zigzag遍历</h4><p><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/" target="_blank" rel="noopener">Leetcode : 103. Binary Tree Zigzag Level Order Traversal (Medium)</a></p><p>思路： 之字形遍历二叉树，奇数行从左往右，偶数行从右往左，…<br>可以修改层次遍历的代码，通过判断 res 的长度，来判断当前行是奇数行还是偶数行，若是偶数行，则将结果翻转即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        nodes = [node.val <span class="keyword">for</span> node <span class="keyword">in</span> queue]</span><br><span class="line">        <span class="keyword">if</span> len(res) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            res.append(nodes)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(nodes[::<span class="number">-1</span>])</span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                tmp.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                tmp.append(node.right)</span><br><span class="line">        queue = tmp</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="通过前序和中序遍历构造二叉树"><a href="#通过前序和中序遍历构造二叉树" class="headerlink" title="通过前序和中序遍历构造二叉树"></a>通过前序和中序遍历构造二叉树</h4><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</a></p><p>思路： 前序遍历的第一个元素必定是 root，在中序遍历中 root 左边的是左子树，右边是右子树，因此只要找到 root 在 inorder 中的位置，就分割成了左右子树，之后再根据左右子树的前序遍历和中序遍历进行递归构造二叉树即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">    index = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">    root.left = self.buildTree(preorder[<span class="number">1</span>:index+<span class="number">1</span>], inorder[:index])</span><br><span class="line">    root.right = self.buildTree(preorder[index+<span class="number">1</span>:], inorder[index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="通过中序和后序遍历构造二叉树"><a href="#通过中序和后序遍历构造二叉树" class="headerlink" title="通过中序和后序遍历构造二叉树"></a>通过中序和后序遍历构造二叉树</h4><p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" target="_blank" rel="noopener">Leetcode : 106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</a></p><p>与上一题类似，需要注意的是 array 切片的边界问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder, postorder)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root = TreeNode(postorder[<span class="number">-1</span>])</span><br><span class="line">    index = inorder.index(root.val)</span><br><span class="line">    root.left = self.buildTree(inorder[:index], postorder[:index])</span><br><span class="line">    root.right = self.buildTree(inorder[index+<span class="number">1</span>:], postorder[index:<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉查找树（BST），又称二叉排序树、二叉搜索树。</p><ol><li>没有键值相等的节点</li><li>若<strong>左子树</strong>不为空，则左子树上节点值<strong>均小于</strong>根节点的值</li><li>若<strong>右子树</strong>不为空，则右子树上节点值<strong>均大于</strong>根节点的值</li><li>任意节点的左、右子树也是二叉查找树</li></ol><p>二叉查找树中序遍历一遍的结果是单调递增的，可以用于二分搜索。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，为 o(logn)，但当二叉查找树退化为单链表时，查找效率最低，最低为 o(n)。</p><h4 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a>Unique Binary Search Trees</h4><p><a href="https://leetcode.com/problems/unique-binary-search-trees/description/" target="_blank" rel="noopener">Leetcode : 96. Unique Binary Search Trees (Medium)</a></p><p>思路： 给定条件，求有多少种解，一般都是用动态规划，此时只要求解的数量。<br>序列从 1 到 n，当使用 1…n 中的每个数 i 作为根节点时，则 1…i-1 组成左子树，i+1…n 组成右子树，之后再递归构造左右子树，由于根节点唯一，则这样构造的二叉树都是唯一的。  </p><p>使用两个变量来记录：<br>G(n)： 长度为 n 的序列组成的 unique BST 数量<br>F(i,n)： 以 i 为根节点的，长度为 n 的序列组成的 unique BST 数量<br>那么 G(n) = F(1,n) + F(2,n) + … + F(n,n), 有 G(0) = 1, G(1) = 1<br>F(i,n) = G(i-1) * G(n-i)，即左子树有 i-1 个节点能构造的 BST 数与右子树有 n-i 个节点能构造的 BST 数之积。 </p><p>因此有 G(n) = G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0)  <strong>【卡特兰数】</strong></p><p>但是需要注意的是： 直接递归会超时。因此用动态规划解决。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">            dp[i] += dp[j]*dp[i-j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h4 id="Unique-Binary-Search-Trees-II"><a href="#Unique-Binary-Search-Trees-II" class="headerlink" title="Unique Binary Search Trees II"></a>Unique Binary Search Trees II</h4><p><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/description/" target="_blank" rel="noopener">Leetcode : 95. Unique Binary Search Trees II (Medium)</a></p><p><strong>此题不理解</strong></p><p>输出上一题的所有结果，需要枚举，考虑 DFS。  </p><p>根据 BST 的性质，1…i-1 构成左子树，i+1…n 构成右子树。<br>当 begin &gt; end 时，返回 [None]； 当 begin &lt;= end 时，用 left 和 right 来递归构造左右子树。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: List[TreeNode] # 返回一个根节点的list即可</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> self.dfs(<span class="number">1</span>, n)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, begin, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> begin &gt; end:</span><br><span class="line">        <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(begin, end+<span class="number">1</span>):</span><br><span class="line">        left = self.dfs(begin, i<span class="number">-1</span>)</span><br><span class="line">        right = self.dfs(i+<span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                root = TreeNode(i)</span><br><span class="line">                root.left = l</span><br><span class="line">                root.right = r</span><br><span class="line">                res.append(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="验证二叉查找树"><a href="#验证二叉查找树" class="headerlink" title="验证二叉查找树"></a>验证二叉查找树</h4><p><a href="https://leetcode.com/problems/validate-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 98. Validate Binary Search Tree (Medium)</a></p><p>思路：利用 BST 中序遍历是有序数组的特点来求解，只要当前节点的值小于或等于上一个节点的值，则直接返回 False，当遍历完成后返回 True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> (<span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        stack = []</span><br><span class="line">        pre_val = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> node.val &lt;= pre_val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                pre_val = node.val</span><br><span class="line">                root = node.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="有序数组构造二叉查找树"><a href="#有序数组构造二叉查找树" class="headerlink" title="有序数组构造二叉查找树"></a>有序数组构造二叉查找树</h4><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 108. Convert Sorted Array to Binary Search Tree (Easy)</a></p><p>思路：BST 二叉查找树即 left &lt; root &lt; right，因此利用有序数组构造 BST，且需要满足平衡二叉树的定义，注意到题中只要求给出一种解法，因此可以利用数组中间的数来作为 root，该数左边的用来构造左子树，右边的构造右子树，即将数组分成三个部分， [0, mid-1], mid, [mid+1, len(nums)-1]，再递归产生左右子树即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.toBST(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toBST</span><span class="params">(self, nums, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span> </span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = self.toBST(nums, start, mid - <span class="number">1</span>)</span><br><span class="line">        root.right = self.toBST(nums, mid + <span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>直接使用中间点来构造，一直二分，可以保证是平衡二叉树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    i = len(nums) // <span class="number">2</span></span><br><span class="line">    root = TreeNode(nums[i])</span><br><span class="line">    root.left = self.sortedArrayToBST(nums[:i])</span><br><span class="line">    root.right = self.sortedArrayToBST(nums[i+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="有序链表构造二叉查找树"><a href="#有序链表构造二叉查找树" class="headerlink" title="有序链表构造二叉查找树"></a>有序链表构造二叉查找树</h4><p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 109. Convert Sorted List to Binary Search Tree (Medium)</a></p><p>直接将链表转为数组，再调用上一题的代码即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.sortedArrayToBST(arr, <span class="number">0</span>, len(arr)<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, arr, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(arr[mid])</span><br><span class="line">        root.left = self.sortedArrayToBST(arr, start, mid<span class="number">-1</span>)</span><br><span class="line">        root.right = self.sortedArrayToBST(arr, mid+<span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="二叉查找树中第k小的数"><a href="#二叉查找树中第k小的数" class="headerlink" title="二叉查找树中第k小的数"></a>二叉查找树中第k小的数</h4><p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/" target="_blank" rel="noopener">Leetcode : 230. Kth Smallest Element in a BST (Medium)</a></p><p>思路：利用中序遍历，当遍历到第 k 个数时返回当前节点的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        stack =[]</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count == k:</span><br><span class="line">                    <span class="keyword">return</span> node.val</span><br><span class="line">                root = node.right</span><br></pre></td></tr></table></figure><h4 id="二叉查找树的最近公共祖先"><a href="#二叉查找树的最近公共祖先" class="headerlink" title="二叉查找树的最近公共祖先"></a>二叉查找树的最近公共祖先</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree (Easy)</a></p><p>思路：由于二叉查找树的左子树节点的值小于根节点，右子树节点的值大于根节点，因此可以从根节点出发递归判断。</p><ol><li>若 root 的值大于 p 和 q 的值，则 LCA 在左子树</li><li>若 root 的值小于 p 和 q 的值，则 LCA 在右子树</li><li>若 root 的值介于 p 和 q 之间，则 root 就是 LCA</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 236. Lowest Common Ancestor of a Binary Tree (Medium) </a></p><p>思路：重点在于找到节点 p 和 q 在左子树还是右子树</p><ol><li>若当前结点为空或者与 p 和 q 一致，则返回该节点</li><li>递归寻找 p 和 q 在左、右子树的位置</li><li>若 p 和 q 分别在左、右子树上，则返回 root，否则就在左、右子树上</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p ,q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。<br>除了最后一层之外，其余层的结点都是满的，且最后一层结点靠左对其。</p><h4 id="Count-Complete-Tree-Nodes"><a href="#Count-Complete-Tree-Nodes" class="headerlink" title="Count Complete Tree Nodes"></a>Count Complete Tree Nodes</h4><p><a href="https://leetcode.com/problems/count-complete-tree-nodes/description/" target="_blank" rel="noopener">Leetcode : 222. Count Complete Tree Nodes (Medium)</a></p><p>求完全二叉树的节点数。<br>思路： 简单做法为直接遍历，返回 len(res)，但没意义，会超时。  </p><p>对于完全二叉树：</p><ul><li>若左子树高度等于右子树高度，则左子树为满二叉树，右子树可能是完全二叉树也可能是满二叉树</li><li>若左子树高度大于右子树高度，则右子树为满二叉树，左子树为完全二叉树或满二叉树</li></ul><p>因此，可以通过求左右子树的高度来计算节点，高度只需要遍历最左边的节点即可。</p><ul><li>构造 get_height(root) 来得到树高</li><li>若左右子树高度相等，则返回节点数为 2<sup>left_height</sup>-1 + 1 + self.countNodes(root.right), 即左子树节点数+root节点+右子树节点数。</li><li>若左子树高度大于右子树高度，则返回节点数为 2<sup>right_height</sup>-1 + 1 + self.countNodes(root.left)。  </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        left_height = self.get_height(root.left)</span><br><span class="line">        right_height = self.get_height(root.right)</span><br><span class="line">        <span class="keyword">if</span> left_height == right_height:</span><br><span class="line">            count = <span class="number">2</span> ** left_height + self.countNodes(root.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = <span class="number">2</span> ** right_height + self.countNodes(root.left)</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_height</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        height = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            height += <span class="number">1</span></span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">return</span> height</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="二叉树转链表-Flatten-Binary-Tree-to-Linked-List"><a href="#二叉树转链表-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="二叉树转链表 Flatten Binary Tree to Linked List"></a>二叉树转链表 Flatten Binary Tree to Linked List</h4><p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/" target="_blank" rel="noopener">Leetcode : 114. Flatten Binary Tree to Linked List (Medium)</a></p><p>问题描述：将一个二叉树变为一个链表。</p><p>思路：变平后的链表实际上是二叉树前序遍历的结果，因此先对二叉树进行前序遍历，得到结果，再重新组织该二叉树，注意需要的是原地操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: void Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    res = []    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrderTraversal</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        res.append(root)</span><br><span class="line">        preOrderTraversal(root.left)</span><br><span class="line">        preOrderTraversal(root.right)</span><br><span class="line">    preOrderTraversal(root)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(res)):</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        root.right = res[i]</span><br><span class="line">        root = root.right</span><br></pre></td></tr></table></figure><h4 id="Binary-Search-Tree-Iterator"><a href="#Binary-Search-Tree-Iterator" class="headerlink" title="Binary Search Tree Iterator"></a>Binary Search Tree Iterator</h4><p><a href="https://leetcode.com/problems/binary-search-tree-iterator/description/" target="_blank" rel="noopener">Leetcode : 173. Binary Search Tree Iterator (Medium)</a></p><p>实现 BST 的 hasNext() 和 next() 方法。 next() 输出下一个最小的值。<br>简单做法： BST 中序遍历结果是递增的，直接先对 BST 进行中序遍历，再 pop(0) 删除第一个元素来输出。<br>可以用递归和非递归方法来进行中序遍历，该题中用递归的速度会更快一些。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.inorderTraversal(root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.inorderTraversal(root.left)</span><br><span class="line">            self.stack.append(root.val)</span><br><span class="line">            self.inorderTraversal(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="前缀树Trie"><a href="#前缀树Trie" class="headerlink" title="前缀树Trie"></a>前缀树Trie</h3><p>Trie，又称前缀树或字典树，是一种有序树状的数据结构，用于保存关联数组，其中的键通常是字符串。</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1552209599/trie.jpg"></div><p>基本性质：</p><ol><li>根节点不包含字符，根节点外每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符串不相同。</li></ol><h4 id="实现Trie"><a href="#实现Trie" class="headerlink" title="实现Trie"></a>实现Trie</h4><p><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">Leetcode : 208. Implement Trie (Prefix Tree) (Medium)</a></p><blockquote><p>Implement a trie with insert, search, and startsWith methods.<br>Note:<br>You may assume that all inputs are consist of lowercase letters a-z.</p></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="两个有序数组的中位数-Median-of-Two-Sorted-Arrays"><a href="#两个有序数组的中位数-Median-of-Two-Sorted-Arrays" class="headerlink" title="两个有序数组的中位数 Median of Two Sorted Arrays"></a>两个有序数组的中位数 Median of Two Sorted Arrays</h3><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">Leetcode : 4. Median of Two Sorted Arrays (Hard)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">    nums = nums1 + nums2</span><br><span class="line">    nums.sort()</span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> float(<span class="string">'%.1f'</span> %((nums[n//<span class="number">2</span><span class="number">-1</span>] + nums[n//<span class="number">2</span>])/<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> float(<span class="string">'%.1f'</span> %(nums[(n<span class="number">-1</span>)//<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><h3 id="Remove-Duplicates-from-Sorted-Array"><a href="#Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Remove Duplicates from Sorted Array"></a>Remove Duplicates from Sorted Array</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">Leetcode : 26. Remove Duplicates from Sorted Array(Easy)</a></p><p>思路：数组有序，则重复元素必定相邻。使用两个下标，i 记录当前元素位置，j 记录新数组的元素位置，当 nums[i] != nums[i-1] 时，就将这个重复元素放到新数组中（注意这里是 in-place 操作）。<br>时间复杂度 o(n), 空间复杂度 o(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[i<span class="number">-1</span>]:</span><br><span class="line">            nums[j] = nums[i]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><h3 id="Remove-Duplicates-from-Sorted-Array-II"><a href="#Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="Remove Duplicates from Sorted Array II"></a>Remove Duplicates from Sorted Array II</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/" target="_blank" rel="noopener">Leetcode : 80. Remove Duplicates from Sorted Array II (Medium)</a></p><p>思路: 计算数字出现的次数，当次数为 1 或 2 时，就把其加到新数组中。 要注意的是题中需要 in-place 操作，因此直接覆盖 nums 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">1</span> <span class="keyword">or</span> count == <span class="number">2</span>:</span><br><span class="line">            nums[j] = nums[i]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><h3 id="Remove-Element"><a href="#Remove-Element" class="headerlink" title="Remove Element"></a>Remove Element</h3><p><a href="https://leetcode.com/problems/remove-element/description/" target="_blank" rel="noopener">Leetcode : 27. Remove Element(Easy)</a></p><p>思路：与上一题相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(nums, val)</span>:</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">            nums[j] = nums[i]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><h3 id="Next-Permutation"><a href="#Next-Permutation" class="headerlink" title="Next Permutation"></a>Next Permutation</h3><p><a href="https://leetcode.com/problems/next-permutation/description/" target="_blank" rel="noopener">Leetcode : 31. Next Permutation (Medium)</a></p><p>思路：</p><ol><li>从后往前扫描，寻找两个相邻的升序元素，nums[i] &lt; nums[i+1]；</li><li>从后往前扫描，找到第一个比 nums[i] 更大的元素， nums[j]；</li><li>交换 nums[i] 和 nums[j]，并对 i 之后的元素进行升序排列。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>, i, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[i]:</span><br><span class="line">                    nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                    nums[i+<span class="number">1</span>:] = sorted(nums[i+<span class="number">1</span>:])</span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">        nums.sort() <span class="comment"># nums[:] = sorted(nums[:])</span></span><br></pre></td></tr></table></figure><h3 id="Merge-Intervals"><a href="#Merge-Intervals" class="headerlink" title="Merge Intervals"></a>Merge Intervals</h3><p><a href="https://leetcode.com/problems/merge-intervals/description/" target="_blank" rel="noopener">Leetcode : 56. Merge Intervals (Medium)</a></p><p>思路：首先对 intervals 进行排序，然后选 i=0 的数的 start 和 end 作为比较基准，当下一个数的 start 小于前一个数的 end 时，则表明两个 inteval 可以合并，并将新的 end 置为两者之间的较大者。 当不能合并时，就前一个数添加到 res 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type intervals: List[Interval]</span></span><br><span class="line"><span class="string">    :rtype: List[Interval]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(intervals) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> intervals</span><br><span class="line">    res = []</span><br><span class="line">    intervals = sorted(intervals, key=<span class="keyword">lambda</span> x: (x.start, x.end))</span><br><span class="line">    left = intervals[<span class="number">0</span>].start</span><br><span class="line">    right = intervals[<span class="number">0</span>].end</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(intervals)):</span><br><span class="line">        <span class="keyword">if</span> right &gt;= intervals[i].start:</span><br><span class="line">            right = max(right, intervals[i].end)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            interval = Interval(left, right)</span><br><span class="line">            res.append(interval)</span><br><span class="line">            left = intervals[i].start</span><br><span class="line">            right = intervals[i].end</span><br><span class="line">    interval = Interval(left, right)</span><br><span class="line">    res.append(interval)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a>Insert Interval</h3><p><a href="https://leetcode.com/problems/insert-interval/description/" target="_blank" rel="noopener">Leetcode : 57. Insert Interval (Hard)</a></p><p>将 newInterval 插入到 intervals 中，再复用上一题的代码即可，但效率不高。</p><h3 id="归并两个有序数组-Merge-Sorted-Array"><a href="#归并两个有序数组-Merge-Sorted-Array" class="headerlink" title="归并两个有序数组 Merge Sorted Array"></a>归并两个有序数组 Merge Sorted Array</h3><p><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">Leetcode : 88. Merge Sorted Array (Easy)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span> </span><br><span class="line">    <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> nums1[m<span class="number">-1</span>] &gt;= nums2[n<span class="number">-1</span>]:</span><br><span class="line">            nums1[m+n<span class="number">-1</span>] = nums1[m<span class="number">-1</span>]</span><br><span class="line">            m -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums1[m+n<span class="number">-1</span>] = nums2[n<span class="number">-1</span>]</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure><p>投机做法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums1, m, nums2, n)</span>:</span></span><br><span class="line">    nums1[m:] = nums2[:n]</span><br><span class="line">    nums1.sort()</span><br></pre></td></tr></table></figure><h3 id="Pascal’s-Triangle"><a href="#Pascal’s-Triangle" class="headerlink" title="Pascal’s Triangle"></a>Pascal’s Triangle</h3><p><a href="https://leetcode.com/problems/pascals-triangle/description/" target="_blank" rel="noopener">Leetcode : 118. Pascal’s Triangle (Easy)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</span><br><span class="line">        <span class="keyword">if</span> i &lt;= <span class="number">1</span>:</span><br><span class="line">            res.append([<span class="number">1</span>]*(i+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            row = [<span class="number">1</span>] + [<span class="number">0</span>] * (i<span class="number">-1</span>) + [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">                row[j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>] + res[i<span class="number">-1</span>][j]</span><br><span class="line">            res.append(row)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Pascal’s-Triangle-II"><a href="#Pascal’s-Triangle-II" class="headerlink" title="Pascal’s Triangle II"></a>Pascal’s Triangle II</h3><p><a href="https://leetcode.com/problems/pascals-triangle-ii/description/" target="_blank" rel="noopener">Leetcode : 119. Pascal’s Triangle II (Easy)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(rowIndex+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt;= <span class="number">1</span>:</span><br><span class="line">            res = [<span class="number">1</span>] * (i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>):</span><br><span class="line">                tmp.append(res[j] + res[j+<span class="number">1</span>])</span><br><span class="line">            res = [<span class="number">1</span>] + tmp + [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="旋转数组-Rotate-Array"><a href="#旋转数组-Rotate-Array" class="headerlink" title="旋转数组 Rotate Array"></a>旋转数组 Rotate Array</h3><p><a href="https://leetcode.com/problems/rotate-array/description/" target="_blank" rel="noopener">Leetcode : 189. Rotate Array(Easy)</a></p><p>思路: 要注意 k 可能会比 len(nums) 更大，因此先要取余数，除尽的部分相当于 nums 没改变<br>要求原地操作，切片是一个原地操作<br>时间复杂度 o(n)， 空间复杂度 o(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k = k % len(nums)</span><br><span class="line">        nums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]</span><br></pre></td></tr></table></figure><p>要求时间复杂度 O(1)，对于 [1,2,3,4,5,6,7], k=3<br>[1,2,3,4] -&gt; [4,3,2,1]; [5,6,7] -&gt; [7,6,5]; [4,3,2,1,7,6,5] -&gt; [5,6,7,1,2,3,4]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        k = k % len(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, n-k<span class="number">-1</span>) <span class="comment"># 必须要传入 nums，如果传入切片无法修改 nums</span></span><br><span class="line">        self.reverse(nums, n-k, n<span class="number">-1</span>)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Contains-Duplicate"><a href="#Contains-Duplicate" class="headerlink" title="Contains Duplicate"></a>Contains Duplicate</h3><p><a href="https://leetcode.com/problems/contains-duplicate/description/" target="_blank" rel="noopener">Leetcode : 217. Contains Duplicate (Easy)</a></p><p>若直接暴力解决，遍历数组，用 arr 存储遍历过的值，若后面出现过相同的数，则返回 True，该方法会超时。</p><p>思路一：将 nums 转为 set，这样 set 中都是不重复的数字，若 set 与 nums 长度不同，则说明有重复数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    s = set(nums)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> len(s) != len(nums) <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>思路二： 先将 nums 排序，再判断前后是否有相同数字即可。</p><h3 id="Contains-Duplicate-II"><a href="#Contains-Duplicate-II" class="headerlink" title="Contains Duplicate II"></a>Contains Duplicate II</h3><p><a href="https://leetcode.com/problems/contains-duplicate-ii/description/" target="_blank" rel="noopener">Leetcode : 219. Contains Duplicate II (Easy)</a></p><p>思路： 利用字典来存储某个元素上一次出现的位置，当再次出现该元素时，计算两个重复元素之间的距离是否 &lt;= k，是的话就 return True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> dic:</span><br><span class="line">            j = dic[nums[i]]</span><br><span class="line">            <span class="keyword">if</span> i - j &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        dic[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="Contains-Duplicate-III"><a href="#Contains-Duplicate-III" class="headerlink" title="Contains Duplicate III"></a>Contains Duplicate III</h3><p><a href="https://leetcode.com/problems/contains-duplicate-iii/description/" target="_blank" rel="noopener">Leetcode : 220. Contains Duplicate III (Medium)</a></p><h3 id="Majority-Element"><a href="#Majority-Element" class="headerlink" title="Majority Element"></a>Majority Element</h3><p><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">Leetcode : 169. Majority Element (Easy)</a></p><p>摩尔投票法：快速的计算出一个数组中出现次数过半的数，应用同加异减的思想。设置一个计数器，在遍历数组的时候，如果是这个数，则计数器加 1，否则减 1，当计数器为 0 时，则重置 major 和 cnt。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    major = nums[<span class="number">0</span>]</span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] == major:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i] != major:</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">            major = nums[i]</span><br><span class="line">            cnt = <span class="number">1</span>        </span><br><span class="line">    <span class="keyword">return</span> major</span><br></pre></td></tr></table></figure><h3 id="Majority-Element-II"><a href="#Majority-Element-II" class="headerlink" title="Majority Element II"></a>Majority Element II</h3><p><a href="https://leetcode.com/problems/majority-element-ii/description/" target="_blank" rel="noopener">Leetcode : 229. Majority Element II (Medium)</a></p><p>要求时间复杂度为 O(n)， 空间复杂度为 O(1)</p><p>出现次数超过 1/3 数组长的数，最多只有两个。改进摩尔投票法，设置两个计数器，和两个候选数字：</p><ol><li>若是两个候选数字之一，则将对应的计数器加一；</li><li>不是两个候选数字任意一个，则两个计数器都减一；</li><li>若某个计数器为 0， 则重置计数器和候选数字；</li><li>最后得到两个候选数字，还需要检查出现的次数是否都超过了 1/3。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="comment"># if len(nums) &lt;= 1:</span></span><br><span class="line">    <span class="comment">#     return nums</span></span><br><span class="line">    cnt1, cnt2, can1, can2 = <span class="number">0</span>, <span class="number">0</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num == can1:</span><br><span class="line">            cnt1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> num == can2:</span><br><span class="line">            cnt2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> cnt1 == <span class="number">0</span>:</span><br><span class="line">            can1, cnt1 = num, <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> cnt2 == <span class="number">0</span>:</span><br><span class="line">            can2, cnt2 = num, <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cnt1 -= <span class="number">1</span></span><br><span class="line">            cnt2 -= <span class="number">1</span></span><br><span class="line">    res = [n <span class="keyword">for</span> n <span class="keyword">in</span> (can1, can2) <span class="keyword">if</span> nums.count(n) &gt; len(nums)//<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Product-of-Array-Except-Self"><a href="#Product-of-Array-Except-Self" class="headerlink" title="Product of Array Except Self"></a>Product of Array Except Self</h3><p><a href="https://leetcode.com/problems/product-of-array-except-self/description/" target="_blank" rel="noopener">Leetcode : 238. Product of Array Except Self (Medium)</a></p><p>要求时间复杂度为 O(n)，并且不能使用除法。</p><p>思路： 先从左往右计算一次，再从右往左计算一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    product = [<span class="number">1</span>] * n</span><br><span class="line">    tmp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        product[i] = tmp</span><br><span class="line">        tmp *= nums[i]</span><br><span class="line">    tmp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        product[i] *= tmp</span><br><span class="line">        tmp *= nums[i]</span><br><span class="line">    <span class="keyword">return</span> product</span><br></pre></td></tr></table></figure><h3 id="Move-Zeroes"><a href="#Move-Zeroes" class="headerlink" title="Move Zeroes"></a>Move Zeroes</h3><p><a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">Leetcode : 283. Move Zeroes (Medium)</a></p><p>问题描述：题目要求 in-place 操作，即<strong>原位操作</strong>，不允许移动和使用临时变量，也就是要原地覆盖掉之前的值。<br>对于本题：只要遇到该数不等于 0，则直接从第一个数开始覆盖掉，遍历完一遍后，前面的数都是不为 0 的，再把后面的数全部填充为 0 即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> x != <span class="number">0</span>:</span><br><span class="line">            nums[i] = x</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nums):</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="Valid-Sudoku"><a href="#Valid-Sudoku" class="headerlink" title="Valid Sudoku"></a>Valid Sudoku</h3><p><a href="https://leetcode.com/problems/valid-sudoku/description/" target="_blank" rel="noopener">Leetcode : 36. Valid Sudoku (Medium)</a></p><p>验证数独板是否有效，每一行每一列，每个九宫格内都只能是 1-9 的数字，且不能重复。</p><p>思路：直接将每一行、每一列和每个九宫格进行验证。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            row = board[i]</span><br><span class="line">            col = [r[i] <span class="keyword">for</span> r <span class="keyword">in</span> board]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.valid(row) <span class="keyword">or</span> <span class="keyword">not</span> self.valid(col):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]:</span><br><span class="line">                nine = [board[row][col] <span class="keyword">for</span> row <span class="keyword">in</span> [i, i+<span class="number">1</span>, i+<span class="number">2</span>] <span class="keyword">for</span> col <span class="keyword">in</span> [j, j+<span class="number">1</span>, j+<span class="number">2</span>]]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.valid(nine):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> char.isdigit():</span><br><span class="line">                <span class="keyword">if</span> char <span class="keyword">in</span> dic:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic[char] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="旋转图像-Rotate-Image"><a href="#旋转图像-Rotate-Image" class="headerlink" title="旋转图像 Rotate Image"></a>旋转图像 Rotate Image</h3><p><a href="https://leetcode.com/problems/rotate-image/description/" target="_blank" rel="noopener">Leetcode : 48. Rotate Image (Medium)</a></p><p>矩阵的翻转方式有： 左右翻转、上下翻转、左上到右下的对角线（转置）翻转。</p><p>将矩阵翻转 90 度，相当于先转置数组，再左右翻转数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">    n = len(matrix)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n//<span class="number">2</span>):</span><br><span class="line">            matrix[i][j], matrix[i][n-j<span class="number">-1</span>] = matrix[i][n-j<span class="number">-1</span>], matrix[i][j]</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵-Spiral-Matrix"><a href="#螺旋矩阵-Spiral-Matrix" class="headerlink" title="螺旋矩阵 Spiral Matrix"></a>螺旋矩阵 Spiral Matrix</h3><p><a href="https://leetcode.com/problems/spiral-matrix/description/" target="_blank" rel="noopener">Leetcode : 54. Spiral Matrix(Medium)</a></p><p>思路：向右，向下，向左，向上，四个方向遍历输出，但要注意终止条件，输出数组的大小等于矩阵所有元素数量则终止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    up = <span class="number">0</span></span><br><span class="line">    down = len(matrix) - <span class="number">1</span></span><br><span class="line">    size = (right+<span class="number">1</span>) * (down+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> len(res)&lt; size:</span><br><span class="line">                res.append(matrix[up][i])</span><br><span class="line">        up += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(up, down+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> len(res)&lt; size:</span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(right, left<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> len(res)&lt; size:</span><br><span class="line">                res.append(matrix[down][i])</span><br><span class="line">        down -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(down, up<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> len(res)&lt; size:</span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵-Spiral-Matrix-II"><a href="#螺旋矩阵-Spiral-Matrix-II" class="headerlink" title="螺旋矩阵 Spiral Matrix II"></a>螺旋矩阵 Spiral Matrix II</h3><p><a href="https://leetcode.com/problems/spiral-matrix-ii/description/" target="_blank" rel="noopener">Leetcode : 59. Spiral Matrix II(Medium)</a></p><p>备注： 需要注意矩阵初始化的格式，可以用 matrix = [[0] * n for i in range(0, n)] 或 matrix = [[0 for col in range(n)] for row in range(n)]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    matrix = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(n)] <span class="keyword">for</span> row <span class="keyword">in</span> range(n)]</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = n<span class="number">-1</span></span><br><span class="line">    up = <span class="number">0</span></span><br><span class="line">    down = n<span class="number">-1</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> up &lt;= down:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left, right+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= n*n:</span><br><span class="line">                matrix[up][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">        up += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(up, down+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= n*n:</span><br><span class="line">                matrix[i][right] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">        right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(right, left<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= n*n:</span><br><span class="line">                matrix[down][i] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">        down -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(down, up<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= n*n:</span><br><span class="line">                matrix[i][left] = num</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure><h3 id="Set-Matrix-Zeroes"><a href="#Set-Matrix-Zeroes" class="headerlink" title="Set Matrix Zeroes"></a>Set Matrix Zeroes</h3><p><a href="https://leetcode.com/problems/set-matrix-zeroes/description/" target="_blank" rel="noopener">Leetocde : 73. Set Matrix Zeroes (Medium)</a></p><p>暴力法：两次遍历，第一次遍历存储需要置零的行和列，第二次遍历置零。此法时间复杂度为 O(n * m) , 空间复杂度为 O(n+m)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        rows = []</span><br><span class="line">        cols = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    rows.append(i)</span><br><span class="line">                    cols.append(j)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> rows <span class="keyword">or</span> j <span class="keyword">in</span> cols:</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>想要空间复杂度为 O(1)， 可以将需要置零的行号和列号记录在 第一列 和 第一行，但这会使第一行和第一列的原始元素丢失，因此只需要设置一个额外的变量来保存第一行或第一列是否需要置零。在更新 matrix 的时候，从下往上遍历，则不会破坏第一行或第一列的原始数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">    m = len(matrix)</span><br><span class="line">    n = len(matrix[<span class="number">0</span>])</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            flag = <span class="number">1</span> <span class="comment"># 说明第 0 列中是有 0 的</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>): <span class="comment"># 第 0 列额外判断</span></span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">or</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>         </span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="有序矩阵的第k小元素-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#有序矩阵的第k小元素-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="有序矩阵的第k小元素 Kth Smallest Element in a Sorted Matrix"></a>有序矩阵的第k小元素 Kth Smallest Element in a Sorted Matrix</h3><p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="noopener">Leetcode : 378. Kth Smallest Element in a Sorted Matrix ((Medium))</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">return 13.</span><br></pre></td></tr></table></figure><p>思路：对于该有序矩阵，左上角元素最小，右下角元素最大，因此矩阵中的数一定处于这两者之间，可以用这两个数来做一个 range，二分查找出 kth Smallest。<br>对于数 mid，找到 matrix 中有多少个数小于 mid，然后与 k 进行比较，从而更新二分查找的上下界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix, k)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    low = matrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    high = matrix[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high - <span class="number">1</span>):  <span class="comment">#1</span></span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">        cnt = self.count_num(matrix, mid)</span><br><span class="line">        <span class="keyword">if</span> cnt &lt; k:</span><br><span class="line">            low = mid  <span class="comment">#2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid</span><br><span class="line">    <span class="keyword">return</span> low <span class="keyword">if</span> self.count_num(matrix, low) &gt;= k <span class="keyword">else</span> high</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_num</span><span class="params">(self, matrix, mid)</span>:</span></span><br><span class="line">    n = len(matrix)</span><br><span class="line">    row = <span class="number">0</span></span><br><span class="line">    col = n - <span class="number">1</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(row &lt; n <span class="keyword">and</span> col &gt;= <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">if</span> matrix[row][col] &lt;= mid:</span><br><span class="line">            cnt = cnt + col + <span class="number">1</span></span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            col -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p>备注：</p><ol><li>注意边界条件是 low &lt; high - 1，最后有两个备选项。若是 low &lt;= high，那么可能会出现死循环，因为前一个数字 low 的计数永远小于 cnt，low 就不会更新。</li><li>注意此处 low = mid 和 high = mid</li></ol><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>单链表</strong>的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h3><p>快慢指针中的快慢指的是移动的步长，即每次向前移动速度的快慢。例如可以让快指针每次沿链表向前移动 2，慢指针每次向前移动 1 次。  </p><p><strong>应用一</strong>：判断环形链表<br>让快慢指针从链表头开始遍历，快指针向前移动两个位置，慢指针向前移动一个位置;如果快指针到达 NULL，说明链表以 NULL 为结尾，不是循环链表。如果 快指针追上慢指针，则表示出现了循环。  </p><p><strong>应用二</strong>：在有序链表中寻找中位数<br>该方法在不借助计数器变量实现寻找中位数的功能。原理是：快指针的移动速度是慢指针移动速度的 2 倍，因此当快指针到达链表尾时，慢指针到达中点。程序还要考虑链表结点个数的奇偶数因素，当快指针移动 x 次后到达表尾（1+2x），说明链表有奇数个结点，直接返回慢指针指向的数据即可。如果快指针是倒数第二个结点，说明链表结点个数是偶数，这时可以根据“规则”返回上中位数或下中位数或（上中位数+下中位数）的一半。</p><h3 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a>Add Two Numbers</h3><p><a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">Leetcode : 2. Add Two Numbers(Medium)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        num1 = num2 = <span class="number">0</span></span><br><span class="line">        tens = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                num1 = num1 + l1.val * tens</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                num2 = num2 + l2.val * tens</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            tens = tens * <span class="number">10</span></span><br><span class="line">      </span><br><span class="line">        sum = num1 + num2</span><br><span class="line">        </span><br><span class="line">        p = head = ListNode(sum%<span class="number">10</span>)</span><br><span class="line">        sum = sum // <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> sum:</span><br><span class="line">            node = ListNode(sum%<span class="number">10</span>)</span><br><span class="line">            p.next = node</span><br><span class="line">            p = node</span><br><span class="line">            sum = sum // <span class="number">10</span>            </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="Remove-Nth-Node-From-End-of-List"><a href="#Remove-Nth-Node-From-End-of-List" class="headerlink" title="Remove Nth Node From End of List"></a>Remove Nth Node From End of List</h3><p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">Leetcode : 19. Remove Nth Node From End of List (Medium)</a></p><p>思路： 由于可能会改变链表表头，因此添加一个辅助节点 dummy。然后用两个指针，fast 先走 n 步，然后 slow 再和 fast 同步走，当 fast 走到终点时，slow 位于要删除的节点的前面。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    dummy.next = head</span><br><span class="line">    fast = head</span><br><span class="line">    slow = dummy <span class="comment"># 此处需要注意，slow不能是head，因为head有可能要被删除。</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">while</span> fast: </span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next</span><br><span class="line">    slow.next = slow.next.next</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h3 id="归并两个有序链表-Merge-Two-Sorted-Lists"><a href="#归并两个有序链表-Merge-Two-Sorted-Lists" class="headerlink" title="归并两个有序链表 Merge Two Sorted Lists"></a>归并两个有序链表 Merge Two Sorted Lists</h3><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">Leetcode : 21. Merge Two Sorted Lists (Easy)</a></p><p>思路：链表与树类似，可以用递归方式来定义，这与归并两颗二叉树类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val):</span><br><span class="line">            p = l1</span><br><span class="line">            p.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = l2</span><br><span class="line">            p.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h3 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h3><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">Leetcode : 24. Swap Nodes in Pairs (Medium)</a></p><p>思路： 由于每次要交换相邻节点，因此可以两个节点作为一个单位进行处理。 用 cur 记录当前节点，pre 记录上一个节点，然后进行交换操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    dummy = pre = ListNode(<span class="number">0</span>)</span><br><span class="line">    dummy.next = head.next</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = tmp.next</span><br><span class="line">        tmp.next = cur</span><br><span class="line">        pre.next = tmp</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = cur.next</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h3 id="旋转链表-Rotate-List"><a href="#旋转链表-Rotate-List" class="headerlink" title="旋转链表 Rotate List"></a>旋转链表 Rotate List</h3><p><a href="https://leetcode.com/problems/rotate-list/description/" target="_blank" rel="noopener">Leetcode : 61. Rotate List (Medium)</a></p><p>思路： 先计算链表的长度，用 k%size 得到 rotate 的节点的数量，即 rotate 后面 k%size 个节点到前面去。<br>因此，用双指针， fast 先走 k 步，之后 slow 和 fast 同步，这时候 fast 已经走到最后，则将其指向 head，而此时 slow.next 是翻转之后的 head，并且要将 slow.next 置为 None，否则一直无法停止。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    node = head</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        size += <span class="number">1</span> <span class="comment"># 链表的长度</span></span><br><span class="line">        node = node.next</span><br><span class="line">    k = k % size <span class="comment"># 将后面 k 个数 rotate 到前面</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    slow, fast = head, head</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(k):</span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">while</span> fast.next:</span><br><span class="line">        fast = fast.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">    fast.next = head</span><br><span class="line">    head = slow.next </span><br><span class="line">    slow.next = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="删除有序链表的重复节点-Remove-Duplicates-from-Sorted-List"><a href="#删除有序链表的重复节点-Remove-Duplicates-from-Sorted-List" class="headerlink" title="删除有序链表的重复节点 Remove Duplicates from Sorted List"></a>删除有序链表的重复节点 Remove Duplicates from Sorted List</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="noopener">Leetcode : 83. Remove Duplicates from Sorted List (Easy)</a></p><p>思路：由于链表是有序链表，则重复元素必定相邻</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        cur = head.next</span><br><span class="line">        pre = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> pre.val == cur.val:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre.next = cur</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = pre.next</span><br><span class="line">        pre.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="删除有序链表的重复节点II"><a href="#删除有序链表的重复节点II" class="headerlink" title="删除有序链表的重复节点II"></a>删除有序链表的重复节点II</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/" target="_blank" rel="noopener">Leetcode : 82. Remove Duplicates from Sorted List II (Medium)</a></p><p>思路：一般情况下，需要修改链表表头时，会用到辅助指针，即此处在表头添加一个节点 dummy。<br>使用 is_repeated 来标记是否有重复的节点，当存在重复节点时，则将 pre 指针指向 cur.next，这样就过滤掉了所有的重复节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line"></span><br><span class="line">        pre = dummy</span><br><span class="line">        cur = dummy.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            is_repeated = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> pre.next.val == cur.next.val:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                is_repeated = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> is_repeated:</span><br><span class="line">                pre.next = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = pre.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h3 id="Partition-List"><a href="#Partition-List" class="headerlink" title="Partition List"></a>Partition List</h3><p><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">Leetcode : 86. Partition List (Medium)</a></p><p>思路： 用到两个额外的链表，遍历一个原始链表，将比 x 小的节点构建 p1，比 x 大的节点构建 p2，这样能保证节点的相对位置不发生改变。 然后将两个链表相连。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head, x)</span>:</span></span><br><span class="line">    dummy1, dummy2 = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>)</span><br><span class="line">    p1, p2 = dummy1, dummy2</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">            p1.next = head</span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p2.next = head</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        head = head.next</span><br><span class="line">    p2.next = <span class="literal">None</span></span><br><span class="line">    p1.next = dummy2.next</span><br><span class="line">    <span class="keyword">return</span> dummy1.next</span><br></pre></td></tr></table></figure><h3 id="反转链表-Reverse-Linked-List"><a href="#反转链表-Reverse-Linked-List" class="headerlink" title="反转链表 Reverse Linked List"></a>反转链表 Reverse Linked List</h3><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="noopener">Leetcode : 92. Reverse Linked List II (Medium)</a></p><p>思路：将链表分成三部分，前面一部分，需要反转的部分，以及最后面一部分。需要注意的是当 m = 1 的时候，没有第一部分，因此需要额外进行讨论。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next <span class="keyword">or</span> m == n:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        cur = head</span><br><span class="line">        end = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m<span class="number">-1</span>):</span><br><span class="line">            end = cur</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        rend = end <span class="keyword">if</span> m == <span class="number">1</span> <span class="keyword">else</span> cur</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n-m+<span class="number">1</span>):</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> m != <span class="number">1</span>:</span><br><span class="line">            end.next = pre            </span><br><span class="line">        rend.next = cur </span><br><span class="line">        <span class="keyword">return</span> head <span class="keyword">if</span> m != <span class="number">1</span> <span class="keyword">else</span> pre</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">Leetcode : 206. Reverse Linked List (Easy)</a></p><p>思路：采用循环方式，遍历一遍链表，并将当前元素的指针指向前一个元素，要注意的是必须先使用中间变量保存当前元素的下一个元素，否则在下一次循环时 cur.next 会是前一个元素，会造成死循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h3 id="Copy-List-with-Random-Pointer"><a href="#Copy-List-with-Random-Pointer" class="headerlink" title="Copy List with Random Pointer"></a>Copy List with Random Pointer</h3><p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/description/" target="_blank" rel="noopener">Leetcode : 138. Copy List with Random Pointer (Medium)</a></p><p>思路：</p><ol><li>在原链表的每个节点后面都插入一个新节点，新节点的 label 与原节点一样</li><li>用 tmp 指向原节点，则新节点指向的 random 为 tmp.next.random = tmp.random.next</li><li>将新链表从下图的链表中拆分出来</li></ol><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1552209599/138.jpg"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    tmp = head</span><br><span class="line">    <span class="keyword">while</span> tmp:</span><br><span class="line">        new_node = RandomListNode(tmp.label)</span><br><span class="line">        new_node.next = tmp.next</span><br><span class="line">        tmp.next = new_node</span><br><span class="line">        tmp = tmp.next.next</span><br><span class="line">    tmp = head</span><br><span class="line">    <span class="keyword">while</span> tmp:</span><br><span class="line">        <span class="keyword">if</span> tmp.random:</span><br><span class="line">            tmp.next.random = tmp.random.next</span><br><span class="line">        tmp = tmp.next.next</span><br><span class="line">    </span><br><span class="line">    new_head = head.next</span><br><span class="line">    pold = head</span><br><span class="line">    pnew = new_head</span><br><span class="line">    <span class="keyword">while</span> pnew.next:</span><br><span class="line">        pold.next = pnew.next</span><br><span class="line">        pnew.next = pnew.next.next</span><br><span class="line">        pold = pold.next</span><br><span class="line">        pnew = pnew.next</span><br><span class="line">    pold.next = <span class="literal">None</span></span><br><span class="line">    pnew.next = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure><h3 id="环形链表-Linked-List-Cycle"><a href="#环形链表-Linked-List-Cycle" class="headerlink" title="环形链表 Linked List Cycle"></a>环形链表 Linked List Cycle</h3><p><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">Leetcode : 141. Linked List Cycle (Easy)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="Linked-List-Cycle-II"><a href="#Linked-List-Cycle-II" class="headerlink" title="Linked List Cycle II"></a>Linked List Cycle II</h3><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">Leetcode : 142. Linked List Cycle II (Medium)</a></p><p>问题描述： 如果链表存在环路，那么返回环路的起始节点。</p><p>思路: 利用快慢指针法来判断是否存在环路，假设两个指针 slow 和 fast 的路径如下图，在 Z 点相遇。</p><div><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1552209599/142.png"></div>此时，fast 走过的路径为：a+b+c+b； slow 走过的路径为：a+b。  由于 fast 速度比 slow 快两倍，因此有： 2*(a+b) = a+b+c+b，则 a=c。  因此，当两个指针相遇后，令 slow 回到 head，fast 不变，然后两个指针同速度开始走，一次走一步，则两个指针会在 Y 点 相遇，也就是环路的起始节点。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    slow = fast = head</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span> slow == fast:</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span> <span class="comment"># 必须要break，否则死循环</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag: <span class="comment"># 不是环形就返回None，提高效率。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">    </span><br><span class="line">    slow = head</span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h3 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a>Reorder List</h3><p><a href="https://leetcode.com/problems/reorder-list/description/" target="_blank" rel="noopener">Leetcode : 143. Reorder List (Medium)</a></p><p>思路： 将链表拆分为两个链表；再将第二个链表 reverse；最后交叉归并两个链表。<br>用快慢指针法找到需要拆分的地方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next <span class="keyword">or</span> <span class="keyword">not</span> head.next.next:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="comment"># 快慢指针法拆分链表</span></span><br><span class="line">    slow = fast = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">    head1 = head</span><br><span class="line">    head2 = slow.next</span><br><span class="line">    slow.next = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 反转链表</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head2</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    head2 = pre</span><br><span class="line">    <span class="comment"># 将第二个链表插入到第一个链表中</span></span><br><span class="line">    p1 = head1</span><br><span class="line">    p2 = head2</span><br><span class="line">    <span class="keyword">while</span> p2:</span><br><span class="line">        tmp1 = p1.next</span><br><span class="line">        p1.next = p2</span><br><span class="line">        tmp2 = p2.next</span><br><span class="line">        p2.next = tmp1</span><br><span class="line">        p1 = tmp1</span><br><span class="line">        p2 = tmp2</span><br></pre></td></tr></table></figure><h3 id="两个链表的交点-Intersection-of-Two-Linked-Lists"><a href="#两个链表的交点-Intersection-of-Two-Linked-Lists" class="headerlink" title="两个链表的交点 Intersection of Two Linked Lists"></a>两个链表的交点 Intersection of Two Linked Lists</h3><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">Leetcode : 160. Intersection of Two Linked Lists (Easy)</a></p><p>思路：对于链表 A 和 B，相交于公共部分 C，设两个链表的公共部分长度为 c，那么 A 的长度为 a + c，B 的长度为 b + c，那么有 a + c + b = b + c +a。  </p><p>当链表 A 访问到尾部时，则从链表 B 的头部开始访问 B；<br>当链表 B 访问到尾部时，则从链表 A 的头部开始访问 A。<br>这样可以控制访问 A 和 B 的指针同时访问到交点，若 A 和 B 没有交点，则两个指针同时为空，返回 None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        p = headA</span><br><span class="line">        q = headB</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> p != q:</span><br><span class="line">            p = p.next <span class="keyword">if</span> p <span class="keyword">else</span> headB</span><br><span class="line">            q = q.next <span class="keyword">if</span> q <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h3 id="回文链表-Palindrome-Linked-List"><a href="#回文链表-Palindrome-Linked-List" class="headerlink" title="回文链表 Palindrome Linked List"></a>回文链表 Palindrome Linked List</h3><p><a href="https://leetcode.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">Leetcode : 234. Palindrome Linked List (Easy)</a></p><p>方法一：<br>将链表的值存到数组中，然后再判断是否为回文数组。<br>时间复杂度 o(n), 空间复杂度 o(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[i] != arr[len(arr)<span class="number">-1</span>-i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>方法二：<br>将后半段链表反转，再与前半段进行比较从而判断。<br>时间复杂度 o(n), 空间复杂度 o(1)  </p><p>利用<strong>快慢指针法</strong>找到单链表的中点，注意边界条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        fast = slow = head</span><br><span class="line">        rhead = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        </span><br><span class="line">        rhead = self.reverseList(slow.next)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> rhead:</span><br><span class="line">            <span class="keyword">if</span> rhead.val != head.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            rhead = rhead.next</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        cur = head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h3 id="Delete-Node-in-a-Linked-List"><a href="#Delete-Node-in-a-Linked-List" class="headerlink" title="Delete Node in a Linked List"></a>Delete Node in a Linked List</h3><p><a href="#https://leetcode.com/problems/delete-node-in-a-linked-list/description/">Leetcode : 237. Delete Node in a Linked List (Easy)</a></p><p>本题需要删除链表中的一个节点 node，一般删除一个节点会通过保留上一个节点来操作，但该题中只给了当前节点，因此可以将下一个节点的值赋给当前节点，然后将当前节点指向下下个节点，这样就相当于删除了当前节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    node.val = node.next.val</span><br><span class="line">    node.next = node.next.next</span><br></pre></td></tr></table></figure><h3 id="奇偶链表-Odd-Even-Linked-List"><a href="#奇偶链表-Odd-Even-Linked-List" class="headerlink" title="奇偶链表 Odd Even Linked List"></a>奇偶链表 Odd Even Linked List</h3><p><a href="https://leetcode.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener">Leetcode : 328. Odd Even Linked List (Medium)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        even_head = head.next</span><br><span class="line">        odd = head</span><br><span class="line">        even = even_head</span><br><span class="line">        <span class="keyword">while</span> even <span class="keyword">and</span> even.next:</span><br><span class="line">            odd.next = odd.next.next</span><br><span class="line">            odd = odd.next</span><br><span class="line">            even.next = even.next.next</span><br><span class="line">            even = even.next</span><br><span class="line">        odd.next = even_head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 搜索算法</title>
      <link href="/2019/01/04/algorithms/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2/"/>
      <url>/2019/01/04/algorithms/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>在图的基本算法中，最初需要接触的就是图的遍历算法，根据访问节点的顺序，可分为广度优先搜索（BFS）和深度优先搜索（DFS）。</p><a id="more"></a><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1552209599/BFS.jpg"></div><p>BFS 广度优先搜索的搜索过程是一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。  </p><p>第一层：<br>0 -&gt; {6,2,1,5};  </p><p>第二层：<br>6 -&gt; {4}<br>2 -&gt; {}<br>1 -&gt; {}<br>5 -&gt; {3}  </p><p>第三层：<br>4 -&gt; {}<br>3 -&gt; {}  </p><p>上述过程可知：是反复从新节点出发进行遍历操作。  </p><p>每一轮遍历的节点都与根节点路径长度相同。设 d<sub>i</sub> 表示第 i 个节点与根节点的路径长度，可以推导出结论：对于先遍历的节点 i 与后遍历的节点 j，有 d<sub>i</sub>&lt;=d<sub>j</sub>。<br>利用上述结论，可以求解最短路径  <strong>最优解</strong>  问题：第一次遍历到目的节点，其所经过的路径为最短路径，如果继续遍历，之后再遍历到目的节点，所经过的路径就不是最短路径。  </p><p>在程序实现 BFS 时需要考虑以下问题：</p><ul><li>队列：用来存储每一轮遍历的节点。</li><li>标记：对于已经遍历的节点，需要标记，避免重复遍历。</li></ul><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1552209599/DFS.png"></div><p>深度优先搜索在得到一个新节点时立马对新节点进行遍历：<br>从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；<br>如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。  </p><p>从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解 <strong>可达性</strong> 问题。  </p><p>在程序实现 DFS 时需要考虑以下问题：  </p><ul><li>栈：用来存储当前节点信息，当遍历新节点返回时能够继续遍历当前节点。也可以使用递归栈。</li><li>标记：对已经遍历过的节点进行标记。</li></ul><h2 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h2><p>回溯法属于 DFS ，主要用于求解 <strong>排列组合</strong> 问题。<br>在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><p>因为 Backtracking 不是立即就返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p><ul><li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li><li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。  </li></ul><p><strong>一般看到所有的组合问题，则用回溯法</strong></p><h3 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a>Letter Combinations of a Phone Number</h3><p><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener">Leetcode : 17. Letter Combinations of a Phone Number(Medium)</a></p><p>思路：运用 DFS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    dict = &#123;<span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">            <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">            <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">            <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">            <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">            <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">            <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">            <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(d, string)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">            res.append(string)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        num = d[<span class="number">0</span>]</span><br><span class="line">        rest_num = d[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> dict[num]:</span><br><span class="line">            dfs(rest_num, string+char)</span><br><span class="line">            </span><br><span class="line">    res = []</span><br><span class="line">    dfs(digits, <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a>Generate Parentheses</h3><p><a href="https://leetcode.com/problems/generate-parentheses/description/" target="_blank" rel="noopener">Leetcode : 22. Generate Parentheses(Medium)</a></p><p>思路：括号的长度是 2n，在 [1, 2n] 之间，左括号的数量必定是小于等于右括号的数量，但右括号的数量小于左括号的数量时，则终止递归。<br>因此用 DFS， left 代表左括号的数量，right 代表右括号的数量，如果左括号有剩余，就在结果上 + ‘(‘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(left, right, string)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">            res.append(string)</span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="number">0</span>:</span><br><span class="line">            dfs(left<span class="number">-1</span>, right, string + <span class="string">'('</span>)</span><br><span class="line">        <span class="keyword">if</span> right &gt; <span class="number">0</span>:</span><br><span class="line">            dfs(left, right<span class="number">-1</span>, string + <span class="string">')'</span>)</span><br><span class="line">    dfs(n, n, <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Combination-Sum"><a href="#Combination-Sum" class="headerlink" title="Combination Sum"></a>Combination Sum</h3><p><a href="https://leetcode.com/problems/combination-sum/description/" target="_blank" rel="noopener">Leetcode : 39. Combination Sum(Medium)</a></p><p>思路：用 DFS，要注意的是每次循环遍历需要从当前位置之后开始遍历，否则会出现重复计算。<br>且 arr 不能用 arr.append, 会造成两种问题：</p><ul><li>若在 dfs 的参数中用 arr.append, 相当于是 arr = arr.append, 执行后发现 arr 的类型变为了 NoneType。 因为 append 会修改 arr 本身，并且返回 None，不能把返回值再赋值给 a。</li><li>若在调用 dfs 之前，单独用 arr.append(cans[i])，会一直往 arr 里面加元素。<br>因此需要用 arr+[cans[i]] 来追加元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cans, tar, start, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tar &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> tar == <span class="number">0</span>:</span><br><span class="line">            res.append(arr)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(cans)):</span><br><span class="line">            <span class="keyword">if</span> cans[i] &lt;= tar:</span><br><span class="line">                dfs(cans, tar-cans[i], i, arr+[cans[i]])</span><br><span class="line">    </span><br><span class="line">    dfs(candidates, target, <span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Combination-Sum-II"><a href="#Combination-Sum-II" class="headerlink" title="Combination Sum II"></a>Combination Sum II</h3><p><a href="https://leetcode.com/problems/combination-sum-ii/description/" target="_blank" rel="noopener">Leetcode : 40. Combination Sum II(Medium)</a></p><p>思路：由于一个数字用多次，因此递归时要从 cans[i+1:] 开始</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(cans, tar, start, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tar &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> tar == <span class="number">0</span> <span class="keyword">and</span> arr <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res.append(arr)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cans)):</span><br><span class="line">            <span class="keyword">if</span> cans[i] &lt;= tar:</span><br><span class="line">                dfs(cans[i+<span class="number">1</span>:], tar-cans[i], i+<span class="number">1</span>, arr+[cans[i]])</span><br><span class="line">    candidates = sorted(candidates)</span><br><span class="line">    dfs(candidates, target, <span class="number">0</span>, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Combination-Sum-III"><a href="#Combination-Sum-III" class="headerlink" title="Combination Sum III"></a>Combination Sum III</h3><p><a href="https://leetcode.com/problems/combination-sum-iii/description/" target="_blank" rel="noopener">Leetcode : 216. Combination Sum III(Medium)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(nums, target, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span> <span class="keyword">and</span> len(arr) == k <span class="keyword">and</span> sorted(nums) <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res.append(arr)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            dfs(nums[i+<span class="number">1</span>:], target-nums[i], arr + [nums[i]])</span><br><span class="line">    </span><br><span class="line">    dfs(nums, n, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Permutations"><a href="#Permutations" class="headerlink" title="Permutations"></a>Permutations</h3><p><a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener">Leetcode : 46. Permutations(Medium)</a></p><p>数组元素不重复，排列组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(n, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            res.append(arr)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(n)):</span><br><span class="line">            dfs(n[:i]+n[i+<span class="number">1</span>:], arr+[n[i]])</span><br><span class="line">        </span><br><span class="line">    dfs(nums, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>备注：不要用 pop()，会改变原数组，导致最后数组为空，直接 n[:i]+n[i+1:] 表示删除第 i 个数</p><h3 id="Permutations-II"><a href="#Permutations-II" class="headerlink" title="Permutations II"></a>Permutations II</h3><p><a href="https://leetcode.com/problems/permutations-ii/description/" target="_blank" rel="noopener">Leetcode : 47. Permutations II(Medium)</a></p><p>数组元素重复，排列组合。  </p><p>直接在上一题的基础上添加条件 if not n and arr not in res，会超时。<br>为了提交效率，可以先对 nums 排序，那么相同的元素会在一起，在遍历时，如果遇到相同的元素，其结果会和之前的元素相同，就不要重复递归了。由于添加了元素是否重复的判断，那么得到的 arr 便也不会重复了，因此 if not n 后面不用再接着判断 arr 是否存在于 res 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span>=</span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(n, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            res.append(arr)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(n)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> n[i] == n[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dfs(n[:i]+n[i+<span class="number">1</span>:], arr+[n[i]])</span><br><span class="line">            </span><br><span class="line">    nums.sort()</span><br><span class="line">    dfs(nums, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="N-Queens"><a href="#N-Queens" class="headerlink" title="N-Queens"></a>N-Queens</h3><p><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener">Leetcode : 51. N-Queens(Hard)</a></p><blockquote><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other<br>Given an integer n, return all distinct solutions to the n-queens puzzle.<br>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.  </p></blockquote><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1552209599/n-queens.png"></div><p>N 皇后问题，需要使得任意两个皇后不能处于同一行、同一列或同一斜线上，打印出所有的解法。<br>思路：可以一行一行的，从左到右尝试皇后的摆放，若有冲突，则回溯。<br>可以使用一维数组简化摆放，例 a[0] = 2，表示第 1 行的第 2 列摆放皇后，这样可以无需判断两个皇后是否会处于同一行。<br>需要定义一个 check(i, j) 函数来判断 (i, j) 是否可以摆放皇后。</p><ul><li>不在同一列</li><li>不在同一斜线，即若有两个皇后的位置为 (i1, j1) 和 (i2, j2), 不能有 (i1-i2) == (j1-j2) 的情况</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(i, j)</span>:</span> <span class="comment"># 判断第 i 个皇后能否放在第 j 列，由于是一行一行的放置，因此也就是能否放在第 i 行的第 j 列</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(i): <span class="comment"># 与前 i-1 行进行比较 </span></span><br><span class="line">            <span class="keyword">if</span> board[k] == j <span class="keyword">or</span> abs(k-i) == abs(board[k]-j): <span class="comment"># 判断是否会和第 k 行的皇后在同一列或同一对角线</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(col, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> col == n:</span><br><span class="line">            res.append(arr)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n): <span class="comment"># 一行行的放皇后，每行的每列开始尝试</span></span><br><span class="line">            <span class="keyword">if</span> check(col, j): <span class="comment"># 如果第 col 行的 第 j 列可以放置</span></span><br><span class="line">                board[col] = j</span><br><span class="line">                s = <span class="string">'.'</span> * n <span class="comment"># 初始化需要打印的结果</span></span><br><span class="line">                dfs(col+<span class="number">1</span>, arr+[s[:j]+<span class="string">'Q'</span>+s[j+<span class="number">1</span>:]])</span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    board = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="comment"># 初始化棋盘</span></span><br><span class="line">    dfs(<span class="number">0</span>, []) <span class="comment"># 从第 0 行开始摆放棋子</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="N-Queens-II"><a href="#N-Queens-II" class="headerlink" title="N-Queens II"></a>N-Queens II</h3><p><a href="https://leetcode.com/problems/n-queens-ii/description/" target="_blank" rel="noopener">Leetcode : 52. N-Queens II(Hard)</a></p><blockquote><p>上一题是输出所有的解决方案，该题只需要输出解决方案的个数</p></blockquote><p>直接调用上一题的结果，输出长度即可。或者把 res 直接变为计数，提高效率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(i, j)</span>:</span></span><br><span class="line">           <span class="keyword">for</span> k <span class="keyword">in</span> range(i):</span><br><span class="line">               <span class="keyword">if</span> board[k] == j <span class="keyword">or</span> abs(board[k]-j) == abs(k-i):</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(col)</span>:</span></span><br><span class="line">           <span class="keyword">if</span> col == n:</span><br><span class="line">               self.res += <span class="number">1</span></span><br><span class="line">               <span class="keyword">return</span> </span><br><span class="line">           <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">               <span class="keyword">if</span> check(col, j):</span><br><span class="line">                   board[col] = j</span><br><span class="line">                   dfs(col+<span class="number">1</span>)</span><br><span class="line">       </span><br><span class="line">       self.res = <span class="number">0</span></span><br><span class="line">       board = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">       dfs(<span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h3 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a>Combinations</h3><p><a href="https://leetcode.com/problems/combinations/description/" target="_blank" rel="noopener">Leetcode : 77. Combinations(Medium)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(nums, k, arr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) == k <span class="keyword">and</span> sorted(arr) <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            res.append(arr)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            dfs(nums[i+<span class="number">1</span>:], k, arr+[nums[i]])</span><br><span class="line">            </span><br><span class="line">    dfs(nums, k, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Subsets"><a href="#Subsets" class="headerlink" title="Subsets"></a>Subsets</h3><p><a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener">Leetcode : 78. Subsets(Medium)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(nums, arr)</span>:</span></span><br><span class="line">        res.append(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            dfs(nums[i+<span class="number">1</span>:], arr+[nums[i]])</span><br><span class="line">    </span><br><span class="line">    dfs(sorted(nums), [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Subsets-II"><a href="#Subsets-II" class="headerlink" title="Subsets II"></a>Subsets II</h3><p><a href="https://leetcode.com/problems/subsets-ii/description/" target="_blank" rel="noopener">Leetcode : 90. Subsets II(Medium)</a></p><p>nums 变为包含重复数字，其余与上题一样。<br>只需要在 res.append(arr) 之前添加判断条件 if arr not in res 即可。</p><h3 id="Word-Search"><a href="#Word-Search" class="headerlink" title="Word Search"></a>Word Search</h3><p><a href="https://leetcode.com/problems/word-search/description/" target="_blank" rel="noopener">Leetcode : 79. Word Search(Medium)</a></p><p>思路： 先找到第一个字母的位置，再从此位置<strong>上下左右</strong> 去 DFS，要注意的是已经访问过的节点需要标记，否则之后会再访问到该节点。并且在遍历完之后需要把该节点改回原来的值，不然可能有其他的路径到达 word，board 的节点值不能改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type board: List[List[str]]</span></span><br><span class="line"><span class="string">    :type word: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    n = len(board)</span><br><span class="line">    m = len(board[<span class="number">0</span>])</span><br><span class="line">    visited = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, k)</span>:</span> <span class="comment"># 找第 k 个字母</span></span><br><span class="line">        <span class="keyword">if</span> k == len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i<span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[i<span class="number">-1</span>][j] <span class="keyword">and</span> board[i<span class="number">-1</span>][j] == word[k]: <span class="comment"># 向上</span></span><br><span class="line">            visited[i<span class="number">-1</span>][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> dfs(i<span class="number">-1</span>, j, k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            visited[i<span class="number">-1</span>][j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> j<span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> visited[i][j<span class="number">-1</span>] <span class="keyword">and</span> board[i][j<span class="number">-1</span>] == word[k]: <span class="comment"># 向左</span></span><br><span class="line">            visited[i][j<span class="number">-1</span>] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> dfs(i, j<span class="number">-1</span>, k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            visited[i][j<span class="number">-1</span>] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &lt; n <span class="keyword">and</span> <span class="keyword">not</span> visited[i+<span class="number">1</span>][j] <span class="keyword">and</span> board[i+<span class="number">1</span>][j] == word[k]: <span class="comment"># 向下</span></span><br><span class="line">            visited[i+<span class="number">1</span>][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> dfs(i+<span class="number">1</span>, j, k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            visited[i+<span class="number">1</span>][j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt; m <span class="keyword">and</span> <span class="keyword">not</span> visited[i][j+<span class="number">1</span>] <span class="keyword">and</span> board[i][j+<span class="number">1</span>] == word[k]: <span class="comment"># 向右</span></span><br><span class="line">            visited[i][j+<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> dfs(i, j+<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            visited[i][j+<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">                 </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>]:</span><br><span class="line">                visited[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                visited[i][j] = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="Restore-IP-Addresses"><a href="#Restore-IP-Addresses" class="headerlink" title="Restore IP Addresses"></a>Restore IP Addresses</h3><p><a href="https://leetcode.com/problems/restore-ip-addresses/description/" target="_blank" rel="noopener">Leetcode : 93. Restore IP Addresses(Medium)</a></p><blockquote><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.<br>Input: “25525511135”<br>Output: [“255.255.11.135”, “255.255.111.35”]</p></blockquote><p>思路：合法 IP 地址分为四部分，每个部分的长度为 1-3 位， 大小为 0-255 之间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(s) &gt; <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(s, ip)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> len(ip) == <span class="number">4</span>:</span><br><span class="line">            res.append(<span class="string">'.'</span>.join(ip)) </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>): </span><br><span class="line">            <span class="keyword">if</span> i &lt;= len(s):</span><br><span class="line">                number = int(s[:i]) <span class="comment"># 此处为了防止出现两位数以上，0 开头的情况。</span></span><br><span class="line">                <span class="keyword">if</span> number &lt;= <span class="number">255</span> <span class="keyword">and</span> str(number) == s[:i]:</span><br><span class="line">                    dfs(s[i:], ip+[s[:i]])</span><br><span class="line">    dfs(s, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="Palindrome-Partitioning"><a href="#Palindrome-Partitioning" class="headerlink" title="Palindrome Partitioning"></a>Palindrome Partitioning</h3><p><a href="https://leetcode.com/problems/palindrome-partitioning/description/" target="_blank" rel="noopener">Leetcode : 131. Palindrome Partitioning (Medium)</a></p><p>所有可能的结果：回溯法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    self.is_palindorm = <span class="keyword">lambda</span> s : s == s[::<span class="number">-1</span>]</span><br><span class="line">    res = []        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(s, palindorm)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:        </span><br><span class="line">            res.append(palindorm)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> self.is_palindorm(s[:i+<span class="number">1</span>]):</span><br><span class="line">                dfs(s[i+<span class="number">1</span>:], palindorm + [s[:i+<span class="number">1</span>]])</span><br><span class="line">    dfs(s, [])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="搜索练习"><a href="#搜索练习" class="headerlink" title="搜索练习"></a>搜索练习</h2><h3 id="Word-Ladder"><a href="#Word-Ladder" class="headerlink" title="Word Ladder"></a>Word Ladder</h3><p><a href="https://leetcode.com/problems/word-ladder/description/" target="_blank" rel="noopener">Leetcode : 127. Word Ladder (Medium)</a></p><p>思路： 用队列保存每个能够有效变换的字符串，再遍历这个字符串的每个字符，将其每个字符变为 26 个字母中的任意一个，并保证新生成的 newWord ！= 原来的 word，如果 newWord 在 wordList 中，就把该 newWord 从 wordSet 中删除，并将 queue 的长度 +1, 最后的终止条件是有一个 word == endWord，此时返回长度，若到最后都没有找到这个 word，则返回 0。  </p><p>使用到队列 queue 是因为需要先进先出，先变换到的词应该要先进行下一次变换，若 pop() 最后一个，可能会是新加进去的元素，这个时候已经进行了新的改变。</p><p>改进：</p><ol><li>若直接用 wordList 会超时，而 set 比 list 快很多，因此将 wordList 转为 set。  </li><li>替换字母时不需要用到 26个字母，只需要用到 wordList 中包含的字母即可，先得到所有不同的字母 alphas = set(‘’.join(wordList))</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> wordList <span class="keyword">or</span> <span class="keyword">not</span> wordList:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    wordSet = set(wordList)</span><br><span class="line">    alphas = set(<span class="string">''</span>.join(wordSet))</span><br><span class="line">    queue = [[beginWord, <span class="number">1</span>]]</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        word, length = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> word == endWord:</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> alphas:</span><br><span class="line">                newWord = word[:i] + c + word[i+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> newWord <span class="keyword">in</span> wordSet <span class="keyword">and</span> newWord != word:</span><br><span class="line">                    wordSet.remove(newWord)</span><br><span class="line">                    queue.append([newWord, length+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Surrounded-Regions"><a href="#Surrounded-Regions" class="headerlink" title="Surrounded Regions"></a>Surrounded Regions</h3><p><a href="https://leetcode.com/problems/surrounded-regions/description/" target="_blank" rel="noopener">Leetcode : 130. Surrounded Regions (Medium)</a></p><p>思路：从边缘开始搜索，即搜索第一行和最后一行，第一列和最后一列，遇到 ‘O’，就搜索 ‘O’ 周围每条边的元素，并将 ‘O’ 置换为 ‘D’，这样的话边缘上的 ‘O’ 及与边缘相连的 ‘O’ 都会被置换为 ‘D’， 而内部被围住的 ‘O’ 并没有发生改变。 再遍历一遍 board，将 ‘O’ 全部变为 ‘X’，将 ‘D’ 全部变为 ‘O’。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    n = len(board)</span><br><span class="line">    m = len(board[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= m <span class="keyword">or</span> board[i][j] != <span class="string">'O'</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        board[i][j] = <span class="string">'D'</span></span><br><span class="line">        dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        dfs(i<span class="number">-1</span>, j)</span><br><span class="line">        dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        dfs(i, j<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m): <span class="comment"># 第0行和最后一行</span></span><br><span class="line">        <span class="keyword">if</span> board[<span class="number">0</span>][j] == <span class="string">'O'</span>:</span><br><span class="line">            dfs(<span class="number">0</span>, j)</span><br><span class="line">        <span class="keyword">if</span> board[n<span class="number">-1</span>][j] == <span class="string">'O'</span>:</span><br><span class="line">            dfs(n<span class="number">-1</span>, j)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n): <span class="comment"># 第0列和最后一列</span></span><br><span class="line">        <span class="keyword">if</span> board[i][<span class="number">0</span>] == <span class="string">'O'</span>:</span><br><span class="line">            dfs(i, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> board[i][m<span class="number">-1</span>] == <span class="string">'O'</span>:</span><br><span class="line">            dfs(i, m<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == <span class="string">'D'</span>:</span><br><span class="line">                board[i][j] = <span class="string">'O'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                board[i][j] = <span class="string">'X'</span></span><br></pre></td></tr></table></figure><h3 id="Clone-Graph"><a href="#Clone-Graph" class="headerlink" title="Clone Graph"></a>Clone Graph</h3><p><a href="https://leetcode.com/problems/clone-graph/description/" target="_blank" rel="noopener">Leetcode : 133. Clone Graph (Medium)</a></p><h3 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a>Number of Islands</h3><p><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">Leetcode : 200. Number of Islands (Medium)</a></p><p>思路： 和 130 类似，遍历一遍矩阵，遇到 ‘1’ 之后，就搜索 ‘1’ 周围的元素，并将 ‘1’ 变为 ‘0’，主函数中每调用一次 dfs，说明出现了一个新的 island，则让 cnt+1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    n = len(grid)</span><br><span class="line">    m = len(grid[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= n <span class="keyword">or</span> j &lt; <span class="number">0</span>  <span class="keyword">or</span> j &gt;= m <span class="keyword">or</span> grid[i][j] != <span class="string">'1'</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        grid[i][j] = <span class="string">'0'</span></span><br><span class="line">        dfs(i<span class="number">-1</span>, j)</span><br><span class="line">        dfs(i+<span class="number">1</span>, j)</span><br><span class="line">        dfs(i, j+<span class="number">1</span>)</span><br><span class="line">        dfs(i, j<span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                dfs(i, j)</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h3 id="Course-Schedule"><a href="#Course-Schedule" class="headerlink" title="Course Schedule"></a>Course Schedule</h3><p><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">Leetcode : 207. Course Schedule (Medium)</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 动态规划总结</title>
      <link href="/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>动态规划 Dynamic Programming 是分阶段求解问题，具有最优子结构、边界和状态转移公式三个要素。</p><p>一般来说，给定一个规则，让我们求任意状态下的解，都是用动态规划。</p><a id="more"></a><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="台阶问题"><a href="#台阶问题" class="headerlink" title="台阶问题"></a>台阶问题</h3><p><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">Leetcode : 70. Climbing Stairs (Easy)</a></p><blockquote><p>You are climbing a stair case. It takes n steps to reach to the top.<br>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p></blockquote><p>问题描述：分解为子问题，F(n) = F(n-1) + F(n-2),是一个斐波那契数列，可以直接用递归求解，但递归的时间复杂度是指数级别的 o(n<sup>2</sup>) ，会出现参数被重复计算的问题。</p><p>利用动态规划求解：F(n-1) 和 F(n-2) 是 F(n) 的最优子结构，F(1) 和 F(2) 是问题边界（可以直接得出结果，不需要继续简化），F(n) = F(n-1) + F(n-2) 即状态转移公式。</p><p>自底向上对该问题进行求解，由于 F(n) 只依赖于 F(n-1) 和 F(n-2)，因此可以使用中间变量将其进行保存，从 1-n 依次迭代。此时时间复杂度为 o(n),空间复杂度为 o(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climb_stairs</span><span class="params">(n)</span>:</span></span><br><span class="line">    a = b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        cur = a + b</span><br><span class="line">        a = b</span><br><span class="line">        b = cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><p>备注：</p><ol><li>python 中无需关心其实际含义的变量可用 _ 代替，仅需要循环，不需要计数  </li><li>a 表示到 i-2 台阶的方法数，b 表示到 i-1 台阶的方法数，cur 表示到当前台阶的方法数</li></ol><h3 id="爬楼梯的最低成本"><a href="#爬楼梯的最低成本" class="headerlink" title="爬楼梯的最低成本"></a>爬楼梯的最低成本</h3><p><a href="https://leetcode.com/problems/min-cost-climbing-stairs/description/" target="_blank" rel="noopener">Leetcode : 746. Min Cost Climbing Stairs (Easy)</a></p><p>问题描述：爬楼梯，每次可以走一层或者两层，每层都有一个花费 cost[i]， 求到顶点时的最小花费。  </p><p><strong>方法一：</strong><br>可以用一个列表 dp[i] 来表示到达第 i 层的花费(到达第 i 层时不需要加上 cost[i])，则我们要求的到顶点的花费即为 dp[len(cost)]， dp[] 的长度比 cost[] 的长度更大 1。<br>因此到达第 i 层时，可能是从 i-1 层跳上来，也可能是从 i-2 层跳上来，需要求这两种情况下的最小值。</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i]=min(dp[i-2]&plus;cost[i-2],dp[i-1]&plus;cost[i-1])"></div><p>该方法的时间复杂度为 o(n)，空间复杂度为 o(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_cost_climb_stairs</span><span class="params">(cost)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(cost)+<span class="number">1</span>):</span><br><span class="line">        dp.append(min(dp[i<span class="number">-2</span>] + cost[i<span class="number">-2</span>], dp[i<span class="number">-1</span>] + cost[i<span class="number">-1</span>]))</span><br><span class="line">    <span class="keyword">return</span> dp[len(cost)]</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong><br>由于 dp[i] 只与 dp[i-2] 和 dp[i-1] 以及 cost 有关，因此用三个变量即可。用 pre1 代表 dp[i-1]，用 pre2 代表 dp[i-2]， 用 cur 代表 dp[i]。<br>该方法的时间复杂度为 o(n)，空间复杂度为 o(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_cost_climb_stairs</span><span class="params">(cost)</span>:</span></span><br><span class="line">    pre1, pre2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(cost) + <span class="number">1</span>):</span><br><span class="line">        cur = min(pre2 + cost[i<span class="number">-2</span>], pre1 + cost[i<span class="number">-1</span>])</span><br><span class="line">        pre2 = pre1</span><br><span class="line">        pre1 = cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><h3 id="强盗抢劫房子"><a href="#强盗抢劫房子" class="headerlink" title="强盗抢劫房子"></a>强盗抢劫房子</h3><p><a href="https://leetcode.com/problems/house-robber/description/" target="_blank" rel="noopener">Leetcode : 198. House Robber (Easy)</a></p><p>问题描述：抢劫一排住户，不能抢相邻的，求最大的抢劫金额。与上一题相似。  </p><p>抢劫到第 i 个住户时最大的抢劫量为 dp[i]，由于不能抢 i-1 的住户，因此此时只能抢 i-2 或 i-3 的住户，因此 dp[i] 依赖于 dp[i-2] 和 dp[i-3] 的值；</p><div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=max(dp[i-2],dp[i-3])+nums[i]"/></div><p>方法一：采用<strong>备忘录算法</strong>，该解法的时间复杂度为 o(n),空间复杂度为 o(n)，使用列表 dp[] 来记录下抢劫到第 i 个房子时最大的抢劫量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(nums)</span>:</span></span><br><span class="line">    size = len(nums)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    dp = []</span><br><span class="line">    dp.append(nums[<span class="number">0</span>])</span><br><span class="line">    dp.append(max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]))</span><br><span class="line">    dp.append(max(nums[<span class="number">0</span>]+nums[<span class="number">2</span>], nums[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, size):</span><br><span class="line">        dp.append(max(dp[i<span class="number">-2</span>], dp[i<span class="number">-3</span>]) + nums[i])</span><br><span class="line">    <span class="keyword">return</span> max(dp[size<span class="number">-1</span>], dp[size<span class="number">-2</span>])</span><br></pre></td></tr></table></figure><p>方法二：改进算法，空间复杂度 o(1) 实现。由于 dp[i] 依赖于 dp[i-2] 和 dp[i-3] 的值，因此需要记录下这两个的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    pre1 = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    pre2 = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">        cur = max(pre1, pre2+nums[i])</span><br><span class="line">        pre2 = pre1</span><br><span class="line">        pre1 = cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><h3 id="强盗抢劫房子II"><a href="#强盗抢劫房子II" class="headerlink" title="强盗抢劫房子II"></a>强盗抢劫房子II</h3><p><a href="https://leetcode.com/problems/house-robber-ii/description/" target="_blank" rel="noopener">Leetcode : 213. House Robber II (Medium)</a></p><p>问题描述：房子的分布变为环形，即第一个和最后一个相邻，可以分别求去掉第一个的最大值，和去掉最后一个的最大值，然后比较两者的大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    size = len(nums)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br><span class="line">    <span class="keyword">return</span> max(self.rob2(nums[<span class="number">1</span>:]), self.rob2(nums[:size<span class="number">-1</span>]))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob2</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    pre1 = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    pre2 = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">        cur = max(pre2+nums[i], pre1)</span><br><span class="line">        pre2 = pre1</span><br><span class="line">        pre1 = cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p>0-1 背包问题是在 M 件物品取出若干件放在空间为 N 的背包里，每种物品有且只有一个，并且有体积 w 和价值 v 两个属性。  </p><p>定义二维数组 dp 来存储最大价值，dp[i][j] 表示体积为 j 的背包，前 i 件物品能够达到的最大价值。对于第 i 件物品，有两种情况：  </p><ol><li>不放入第 i 件物品，则能够达到的最大价值为放入前 i-1 件物品的最大价值，即 dp[i][j] = dp[i-1][j]；  </li><li>放入第 i 件物品，则能够达到的最大价值为放入前 i-1 件物品的最大价值加上第 i 件物品的价值，即 dp[i][j] = dp[i-1][j-w[i]] + v[i]。  </li></ol><p>选出上述两种情况下的最大价值，则为空间为 j 的背包能够放下的物品的最大价值。因此，可以得到状态转移方程为：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]&plus;v[i])"></div> <br><p><strong>方法一</strong>：以填充格子的形式求解，返回最后一个格子即得到最大价值。<br>该方法的时间复杂度为 o(NM), 空间复杂度为 o(NM)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bag_01</span><span class="params">(M, N, weights, values)</span>:</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(N+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(M)] <span class="comment"># 初始化二维数组，物品数 M 为行，背包容量 N 为列</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(N+<span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = values[<span class="number">0</span>] <span class="keyword">if</span> j &gt;= weights[<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span> <span class="comment"># 填充边界</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j &gt;= weights[i]:</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weights[i]] + values[i])</span><br><span class="line">    <span class="keyword">return</span> dp[M<span class="number">-1</span>][N]</span><br></pre></td></tr></table></figure><p>填完表格后，仅能得到最优解，但不知道最优解由哪些元素组成，通过最优解回溯，可以找到选择的物品。  </p><ol><li>当 dp[i][j] = dp[i-1][j] 时，说明第 i 件物品没有被选择， 则回到 dp[i-1][j]  </li><li>当 dp[i][j] = dp[i-1][j-weights[i]] + values[i], 说明选择了第 i 件物品，然后再回到装该物品之前的状态，即 dp[i-1][j-weights[i]] 时  </li><li>遍历到 i=0 时，找到组成最优解的商品  </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bag_res</span><span class="params">(dp, N, M, weights, values)</span>:</span></span><br><span class="line">    j = N</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> dp[i][j] == dp[i<span class="number">-1</span>][j-weights[i]] + values[i]:</span><br><span class="line">            res.append(i+<span class="number">1</span>)</span><br><span class="line">            j = j - weights[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong>优化空间。由状态转移公式可知，前 i 件物品的状态只与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，用 dp[j] 来表示 dp[i][j] 和 dp[i-1][j]。此时的状态转移方程为：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=max(dp[j],dp[j-weights[i]]&plus;values[i])"></div><p>此时时间复杂度为 o(M * N), 空间复杂度为 o(N)  </p><p>需要注意的是：dp[] 填充时，必须要从右到左进行填充，也就是 j 应该倒序循环求解。否则，前一项的值即 dp[j-weights[i]] 改变了，dp[j] 无法求得正确的结果。  </p><p>但使用该方法，由于之前的数据被覆盖掉，只能够得到最后的最大价值，无法知道最优解由哪些元素组成，两种方法各有利弊。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bag01</span><span class="params">(M, N, weights, values)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[j] &lt;= dp[j-weights[i]] + values[i] <span class="keyword">and</span> j-weights[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[j] = dp[j-weights[i]] + values[i]</span><br><span class="line">    <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>与 0-1 背包的条件基本一致，但每种物品都有若干件。<br>思路：  </p><ol><li>用 dp[i][j] 表示前 i 种物品放入若干件时到空间为 j 的背包中的最大价值。  </li><li>根据第 i 种物品放入的件数进行决策，对于空间 j，物品 i 能够放入的最大件数为 j/weights[i]，将其转化为 0-1背包求解。</li></ol><p>转为转移公式为, k 表示件数，(0 &lt;= k * weights[i] &lt;= j)：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*weights[i]]&plus;k*values[i])"></div><p>此时时间复杂度为 o(NM∑(j/weights[i]))</p><p><strong>优化一：</strong><br>直接对放与不放第 i 件物品进行决策。  </p><ol><li>不放第 i 件物品，则 dp[i][j] = dp[i-1][j]  </li><li>放第 i 件物品，则 dp[i][j] 中至少会出现一件物品 i，我们认为之前已经最大限度地放置了物品 i，如果能够放进去就放最后一件 i， 则此时 dp[i][j] = <strong>dp[i][j-weights[i]]</strong> + values[i]， <strong>注意此处与 0-1背包的区别</strong>。</li></ol><p>此时的状态转移公式为：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i][j]=max(dp[i-1][j],dp[i][j-weights[i]]&plus;values[i])"></div><p><strong>优化二：</strong><br>使用一维数组进行存储，状态转移公式与 01背包 的一维数组解法相同：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=max(dp[j],dp[j-weight[i]]&plus;values[i])"></div><p>此时要注意的是，完全背包与 01背包 的一维数组解法的遍历顺序不同：<br>01背包遍历 j 时需要逆序遍历，使得 dp[j-weights[i]] 存储的值为 dp[i-1][j-weights[i]] 的值，每个物品只使用一次；<br>而完全背包遍历 j 时需要正序遍历，此时 dp[j-weights[i]] 存储的值为 dp[i][j-weights[i]]的值，每个物品可以使用多次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complete_bag</span><span class="params">(M, N, weights, values)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(weights[i], N+<span class="number">1</span>): <span class="comment">#1</span></span><br><span class="line">            <span class="keyword">if</span> dp[j] &lt;= dp[j - weights[i]] + values[i] <span class="keyword">and</span> j - weights[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[j] = dp[j - weights[i]] + values[i]</span><br><span class="line">        print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure><p>备注： 1. 唯一不同的地方在于对 j 的遍历。<strong>此处从 weights[i] 到 N+1</strong></p><h3 id="二维费用的背包"><a href="#二维费用的背包" class="headerlink" title="二维费用的背包"></a>二维费用的背包</h3><p>二维费用的背包是：对每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对每种费用都有一个可付出的最大值，即背包容量。  </p><p>设第 i 件物品所需的两种费用分别为 weights1[i] 和 weights2[i], 两种费用可付出的最大值为 N1 和 N2，物品的价值为 values[i]。</p><p>由于费用增加一维，则此时状态转移公式也需要增加一维，变为 dp[i][j][k]，用来表示前 i 件物品付出两种费用为 j 和 k 时可以获得的最大价值。此时的状态转移公式为：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?\dpi{200}&space;\tiny&space;dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-weights1[i]][k-weights2[i]]&plus;values[i])"></div><p>优化空间，使用二维形式表示：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j][k]=max(dp[j][k],dp[j-weights1[i]][k-weights2[i]]&plus;values[i])"></div><p>时间复杂度为 o(N1N2M), 空间复杂度为 o(N1N2)</p><p>注意：</p><ol><li>若每件物品只能取 1 次，即 01背包，则变量 j,k 逆序循环。</li><li>若每件物品可以取多次，即完全背包，则变量 j,k 顺序循环。</li></ol><h3 id="背包问题练习"><a href="#背包问题练习" class="headerlink" title="背包问题练习"></a>背包问题练习</h3><h4 id="按单词列表分割字符串"><a href="#按单词列表分割字符串" class="headerlink" title="按单词列表分割字符串"></a>按单词列表分割字符串</h4><p><a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="noopener">Leetcode : 139. Word Break (Medium)</a></p><p>问题描述：按照单词列表来分割字符串，若是分隔的字符串都在 word_dict 中，则返回 True。</p><p>用 dp[i] 来表示到第 i 个字符时是否可以被正确分割。对于上述的例子，有 dp[0] == True; dp[4] == True; dp[8] == True。当最后一个 dp[len(s)] == True 时，则表明整个字符串都可以被分割。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word_break</span><span class="params">(s, word_dict)</span>:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    dp = [<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> word_dict:</span><br><span class="line">            <span class="keyword">if</span> dp[i-len(word)] <span class="keyword">and</span> s[i-len(word):i] == word:</span><br><span class="line">                dp[i] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h4 id="找零钱"><a href="#找零钱" class="headerlink" title="找零钱"></a>找零钱</h4><p><a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="noopener">Leetcode : 322. Coin Change (Medium)</a></p><p>思路：显然这是一个完全背包问题，不同的是要寻找最少的硬币数来组成总额 amount，因此可以用 dp[] 来表示最少的硬币数，dp[] 的初始化应为无穷大。</p><p>状态转移公式为：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=min(dp[j],dp[j-coins[i]&plus;1])"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coin_change</span><span class="params">(coins, amount)</span>:</span></span><br><span class="line">    INF = float(<span class="string">"inf"</span>)  <span class="comment">#1</span></span><br><span class="line">    dp = [<span class="number">0</span>] + [INF] * amount </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(coins)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i], amount + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[j - coins[i]] != INF:</span><br><span class="line">                dp[j] = min(dp[j], dp[j - coins[i]] + <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != INF <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>备注：1. 注意 python 中无穷大可以用 float(“inf”) 来表示， 也可以写成 INF = 0x7ffffffe</p><h4 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h4><p><a href="https://leetcode.com/problems/combination-sum-iv/description/" target="_blank" rel="noopener">Leetcode : 377. Combination Sum IV (Medium)</a></p><p>问题描述：组合 nums 中的数使它们的和为 target。  </p><p>思路：用 dp[i] 表示 target 为 i 时，nums[] 可以组合的总数，那么对于上述的 dp[4]，遍历一遍 nums[], dp[4] = dp[3] + dp[2] + dp[1] （3，2，1三个数字），因此状态转移公式为：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i]=sum(dp[i-num])"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    dp = [<span class="number">1</span>] + [<span class="number">0</span>] * target  <span class="comment">#1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &lt;= i:</span><br><span class="line">                dp[i] += dp[i - num]</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><p>备注：<br>1.这里 dp[0] = 1 是因为当正好 nums[] 中有数字能组成 i 时，比如 3 一个数字就可以组成 dp[3]，那么 dp[3] += dp[0]，有一种解法。<br>2. dp[i-num] 表示能组成 i-num 的解法数，在这些解法的末尾加入 num，则得到 dp[i] 的解法，遍历一遍nums，所有 dp[i] 的解法数相加则得到最终结果，不会产生重复和缺失的问题。</p><h4 id="划分数组为和相等的两部分"><a href="#划分数组为和相等的两部分" class="headerlink" title="划分数组为和相等的两部分"></a>划分数组为和相等的两部分</h4><p><a href="https://leetcode.com/problems/partition-equal-subset-sum/description/" target="_blank" rel="noopener">Leetcode : 416. Partition Equal Subset Sum (Medium)</a></p><p>问题描述：将一个数组划分为和相等的两部分。可以看成是一个背包大小为 sum/2 的 0-1背包问题，且这个背包必须要被填满。可以用一个一维数组进行求解，将每个数字所占空间和价值都用 nums[i] 来表示。由题意得到的状态转移公式为：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=max(dp[j],dp[j-nums[i]]&plus;nums[i])"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">can_partition</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    V = sum(nums) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span> * V != sum(nums):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (V + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[j] &lt;= dp[j - nums[i]] + nums[i] <span class="keyword">and</span> j - nums[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[j] = dp[j - nums[i]] + nums[i]</span><br><span class="line">                <span class="keyword">if</span> dp[j] == V:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="用0-1组成最多的字符串"><a href="#用0-1组成最多的字符串" class="headerlink" title="用0-1组成最多的字符串"></a>用0-1组成最多的字符串</h4><p><a href="https://leetcode.com/problems/ones-and-zeroes/description/" target="_blank" rel="noopener">Leetcode : 474. Ones and Zeroes (Medium)</a></p><p>思路：该问题为二维费用的 01背包问题，有两个费用，0 的数量和 1 的数量，其为背包的最大容量。组成每一个 strs[i] 都需要花费一些 0 和 1，将每个 strs[i] 的价值看做 1。<br>时间复杂度为 o(mnl), 空间复杂度为 o(mn)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_form</span><span class="params">(strs, m, n)</span>:</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strs)):</span><br><span class="line">        ones = strs[i].count(<span class="string">'1'</span>)</span><br><span class="line">        zeros = strs[i].count(<span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n, ones<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(m, zeros<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[j][k] = max(dp[j][k], dp[j - ones][k - zeros] + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> dp[n][m]</span><br></pre></td></tr></table></figure><h4 id="得到目标和"><a href="#得到目标和" class="headerlink" title="得到目标和"></a>得到目标和</h4><p><a href="https://leetcode.com/problems/target-sum/description/" target="_blank" rel="noopener">Leetcode : 494. Target Sum (Medium)</a></p><p>问题描述：给定一个数组 nums[] 和一个目标数字 s, 数组中的数可以是给定 + 或 -，求其和能组成 s 的方法的总数。  </p><p>可以将 nums[]中的数看成两部分，要给 + 的数字为放入数组 P 中，要给 - 的数字放入数组 N 中，因此可以得到：  </p><blockquote><p>sum(P) - sum(N) = target<br>sum(p) + sum(N) = sum(nums)  </p></blockquote><p>由上式可以得到 sum(p) = (target + sum(nums)) // 2<br>因此该问题可以看成一个 0-1背包问题，从给定的 nums[] 中选出一个子集，如果其和等于 (target + sum(nums)) // 2, 则这个子集符合题意，找到有多少个这样的自己即得到所有的方法。  </p><p>因此可以用 dp[i][j] 表示前 i 个数的和为 j 的方法总数。第 i 个数可以选择放入背包或者不放入，则状态转移公式为：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i][j]=dp[i-1][j]&plus;dp[i-1][j-nums[i]]"></div>空间优化后的状态转移公式为：<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=dp[j]&plus;dp[j-nums[i]]"></div>  <p>时间复杂度为 o(n<sup>2</sup>), 空间复杂度为 o(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_target_sum_ways</span><span class="params">(nums, S)</span>:</span></span><br><span class="line">    nsum = sum(nums)</span><br><span class="line">    target = (nsum + S) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nsum &lt; S <span class="keyword">or</span> (nsum + S) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(target, nums[i] - <span class="number">1</span>, <span class="number">-1</span>): <span class="comment">#1</span></span><br><span class="line">            dp[j] = dp[j] + dp[j - nums[i]]</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><p>备注：1.此处的遍历从 target 到 num[i]-1，从而减少遍历的次数， 需要注意的是 range 的区间为左闭右开，即 [traget, nums[i]-1)</p><h2 id="分割整数"><a href="#分割整数" class="headerlink" title="分割整数"></a>分割整数</h2><h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a>解码方法</h3><p><a href="https://leetcode.com/problems/decode-ways/description/" target="_blank" rel="noopener">Leetcode : 91. Decode Ways (Medium)</a></p><p>问题描述：按照编码规则来将信息中的字母编码，给定编码，返回解码的方法总数。  </p><p>思路：用 dp[i] 来表示前 i 个字符的解码总数，由于数字只有处于 1-26 之间时才可以解码，因此可以分为三种情况。</p><ol><li>dp[i] = dp[i-2] + dp[i-1], (10 &lt; int(s[i-2 : i]) &lt;= 26 and int(s[i-2 : i]) != 20)  </li><li>dp[i] = dp[i-2], (int(s[i-2 : i]) == 20 or int(s[i-2 : i]) == 10)  </li><li>dp[i] = dp[i-1], (s[i-1] != ‘0’)  </li></ol><p>必须要注意的时，0 只有和 10，20 才可以解码成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    size = len(s)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'0'</span>: <span class="comment">#1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">1</span>,<span class="number">1</span>] + [<span class="number">0</span>] * (size - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, size + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">10</span> &lt; int(s[i<span class="number">-2</span> : i]) &lt;= <span class="number">26</span> <span class="keyword">and</span> int(s[i<span class="number">-2</span> : i]) != <span class="number">20</span>:</span><br><span class="line">            dp[i] = dp[i<span class="number">-2</span>] + dp[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">elif</span> int(s[i<span class="number">-2</span> : i]) == <span class="number">20</span> <span class="keyword">or</span> int(s[i<span class="number">-2</span> : i]) == <span class="number">10</span>:</span><br><span class="line">            dp[i] = dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">elif</span> s[i<span class="number">-1</span>] != <span class="string">'0'</span>:</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> dp[size]</span><br></pre></td></tr></table></figure><p>备注：1. 必须先判断 size，再判断 s[0]，否则空字符串会造成数组越界。</p><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p><a href="https://leetcode.com/problems/perfect-squares/description/" target="_blank" rel="noopener">Leetcode : 279. Perfect Squares(Medium)</a></p><p>问题描述：按完全平方数来分割整数，将一个数 n 分割成 1,4,9,16…… 的和。  </p><p>思路：用 dp[i] 来存储组成数字 i 的完全平方数的最小个数，<br>因为：13 = 1 * 1 + 12， 13 = 2 * 2 + 9，13 = 3 * 3 + 4<br>那么 dp[13] = min(1 + dp[12], 1 + dp[9], 1 + dp[4])<br>状态转移公式为：</p><div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i]=min(dp[i],dp[i-j*j])"></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_squares</span><span class="params">(n)</span>:</span></span><br><span class="line">    INF = float(<span class="string">"inf"</span>)</span><br><span class="line">    dp = [INF] * (n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, int(math.sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">            dp[i] = min(dp[i], dp[i - j * j] + <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h2 id="数组区间"><a href="#数组区间" class="headerlink" title="数组区间"></a>数组区间</h2><h3 id="子数组最大和"><a href="#子数组最大和" class="headerlink" title="子数组最大和"></a>子数组最大和</h3><p><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">Leetcode : 53. Maximum Subarray (Easy)</a></p><p>问题描述：找到一个数组中的连续子数组的最大的和。  </p><p>到第 i 个数时的子数组最大和只可能是 sum[i-1] + nums[i] 或者是 nums[i]自身， 即<br>sum[i] = max(sum[i-1] + nums[i], nums[i])<br>当前 i-1 项的和 sum[i-1] &lt;= 0 时，则 sum[i]<br> = nums[i]， 抛弃之前的子数组，从 i 开始寻找新的最大和的子数组。这样就可以得到每一部分的最大的 sum，最后再从每一部分的最大 sum 中找到整个数组的 max_sum 。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_subArray</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        sum = max(sum + nums[i], nums[i])</span><br><span class="line">        max_sum = max(max_sum, sum)</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><h3 id="Maximum-Product-Subarray"><a href="#Maximum-Product-Subarray" class="headerlink" title="Maximum Product Subarray"></a>Maximum Product Subarray</h3><p><a href="https://leetcode.com/problems/maximum-product-subarray/description/" target="_blank" rel="noopener">Leetcode : 152. Maximum Product Subarray (Medium)</a></p><p>思路： max[i] 表示以 i 结尾的子数组中的最大乘积，若要 O(1) 的空间复杂度，则用 res 记录下 max[i] 中的最大值。<br>但是由于会出现 <strong>负负得正</strong> 的情况，因此还需要记录下最小值 min[i]。<br>最大最小乘积只会在 [max[i-1] * nums[i], min[i-1] * nums[i], nums[i]] 三者之间产生。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    res = maxp = minp = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        lastmax = maxp</span><br><span class="line">        maxp = max(minp*nums[i], lastmax*nums[i], nums[i])</span><br><span class="line">        minp = min(minp*nums[i], lastmax*nums[i], nums[i])</span><br><span class="line">        res = max(res, maxp)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="数组区间和"><a href="#数组区间和" class="headerlink" title="数组区间和"></a>数组区间和</h3><p><a href="https://leetcode.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">Leetcode : 303. Range Sum Query - Immutable (Easy)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        self.dp = nums</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            self.dp[x] = self.dp[x<span class="number">-1</span>] + nums[x]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum_range</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.dp[j] - self.dp[i<span class="number">-1</span>] <span class="keyword">if</span> i !=<span class="number">0</span> <span class="keyword">else</span> self.dp[j]</span><br></pre></td></tr></table></figure><p>备注：必须将前 x 个数的和先存下来，否则会超时；直接令 dp = nums，这样就不用再初始化 dp[0] = nums[0]，简洁高效。</p><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p><strong>子序列</strong>：已知一个序列 {S<sub>1</sub>, S<sub>2</sub>,…,S<sub>n</sub>} ，取出若干数组成新的序列 {S<sub>i1</sub>, S<sub>i2</sub>,…, S<sub>im</sub>}，其中 i1、i2 … im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个子序列。  </p><p><strong>递增子序列</strong>：如果在子序列中，当下标 ix &gt; iy 时，S<sub>ix</sub> &gt; S<sub>iy</sub>，称子序列为原序列的一个递增子序列。  </p><h3 id="最长递增子序列-1"><a href="#最长递增子序列-1" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p><a href="https://leetcode.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="noopener">Leetcode : 300. Longest Increasing Subsequence (Medium)</a></p><blockquote><p>Given an unsorted array of integers, find the length of longest increasing subsequence.  </p><p>For example,<br>Given [10, 9, 2, 5, 3, 7, 101, 18],<br>The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p></blockquote><p>思路：定义数组 dp[i] 表示到第 i 个数的最长递增子序列的长度，则对于一个递增子序列 {S<sub>i1</sub>, S<sub>i2</sub>,…,S<sub>im</sub>}，如果 im &lt; n 并且 S<sub>im</sub> &lt; S<sub>n</sub> ，此时 {S<sub>i1</sub>, S<sub>i2</sub>,…, S<sub>im</sub>, S<sub>n</sub>} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的即是最长递增子序列。<br>因此，状态转移公式为：</p><div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=max\{1,dp[j]+1|nums[i]>nums[j]\&\&i>j\}"/></div> <br><p>对于长度为 n 的序列，最长递增子序列不一定是以 nums[n-1] 结尾，因此 dp[n-1] 不一定是最长递增子序列的长度，应该是 dp[] 数组的最大值。  </p><p>该解法的时间复杂度为 o(n<sup>2</sup>)， 空间复杂度为 o(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_of_LIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dp_max = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                dp_max = max(dp_max, dp[j] + <span class="number">1</span>)</span><br><span class="line">        dp[i] = dp_max</span><br><span class="line">    <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><p><strong>时间优化</strong>：利用二分查找可将时间复杂度优化到 o(nlogn)</p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><h3 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h3><p><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">Leetcode : 5. Longest Palindromic Substring (Medium)</a></p><p>思路：枚举每个回文串的中点，再向左右两边扩展扫描，直到不是回文串为止，存在两种情况。</p><ul><li>回文串长度为奇数，则中点是 s 中的每个字符，有 len(s) 种可能</li><li>回文串长度为偶数，则中点是 s[i]+s[i+1]，有 len(s)-1 种可能<br>对于每个中心往两边扫的时间复杂度为 O(n)，则该方法的时间复杂度为 O((2n-1) * n) = O(n<sup>2</sup>)</li></ul><p>以上思路需要对 s 遍历两边，对其进行改进，逐一遍历 s 中的每一个字符，并比较其与后面一个字符，如果相等的话，则先找到这一对相邻的字符，再向左右扩展，此时把 i 更新为 right 的值，这样也省去了一些重复的计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    res = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        left = right = i</span><br><span class="line">        <span class="keyword">while</span> right &lt; n<span class="number">-1</span> <span class="keyword">and</span> s[right] == s[right+<span class="number">1</span>]:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        i = right</span><br><span class="line">        <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> right &lt; n<span class="number">-1</span> <span class="keyword">and</span> s[left<span class="number">-1</span>] == s[right+<span class="number">1</span>]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right-left+<span class="number">1</span> &gt; len(res):</span><br><span class="line">            res = s[left:right+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="矩阵路径"><a href="#矩阵路径" class="headerlink" title="矩阵路径"></a>矩阵路径</h2><h3 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a>Unique Paths</h3><p><a href="https://leetcode.com/problems/unique-paths/description/" target="_blank" rel="noopener">Leetcode : 62. Unique Paths (Medium)</a></p><p>一开始想将 dp 数组全部置为 0， 然后把第一行和第一列置为 1，实际可以简化为全部置为1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">    dp = [[<span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="Unique-Paths-II"><a href="#Unique-Paths-II" class="headerlink" title="Unique Paths II"></a>Unique Paths II</h3><p><a href="https://leetcode.com/problems/unique-paths-ii/description/" target="_blank" rel="noopener">Leetocde : 63. Unique Paths II (Medium)</a></p><p>在矩阵中设置障碍，用 0 和 1 来表示该格是否有障碍。<br>填充 dp 时需要注意，如果是第一行第一列中出现了障碍，那么该障碍之后的路都走不通，需要全部置为 0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">    n = len(obstacleGrid)</span><br><span class="line">    m = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][j] != <span class="number">1</span>:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a>Minimum Path Sum</h3><p><a href="https://leetcode.com/problems/minimum-path-sum/description/" target="_blank" rel="noopener">Leetcode : 64. Minimum Path Sum (Medium)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">    n = len(grid)</span><br><span class="line">    m = len(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">and</span> m == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j]</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h3><p><a href="https://leetcode.com/problems/triangle/description/" target="_blank" rel="noopener">Leetcode : 120. Triangle (Medium)</a></p><p>若要空间复杂度为 O(n)，则只能用一维数组，此时在遍历 j 的时候必须从后往前遍历，才不会丢失原来的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    dp[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[j] = dp[j] + triangle[i][j]</span><br><span class="line">            <span class="keyword">elif</span> j == i:</span><br><span class="line">                dp[j] = dp[j<span class="number">-1</span>] + triangle[i][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[j] = min(dp[j], dp[j<span class="number">-1</span>]) + triangle[i][j]</span><br><span class="line">    <span class="keyword">return</span> min(dp)</span><br></pre></td></tr></table></figure><h3 id="Dungeon-Game"><a href="#Dungeon-Game" class="headerlink" title="Dungeon Game"></a>Dungeon Game</h3><p><a href="https://leetcode.com/problems/dungeon-game/description/" target="_blank" rel="noopener">Leetcode : 174. Dungeon Game (Hard)</a><br>由题意，当其实的能量 HP &lt;= 0 时则游戏结束，所以需要保证其实到每一个格子的时候，都有 HP &gt;= 1。  </p><p>思路：</p><ol><li>从右下角向上填充格子，用 dp[i][j] 表示进入到 i,j 格子前需要的最小 HP 数，因此对于最后一个格子， dp[-1][-1] = max(1, -dungeon[-1][-1]+1)</li><li>在每一个格子 i,j ，骑士可能向下走或者向右走， 当 i=m-1 时，不能向下，只能向右走；当 j=n-1 时，只能向下走；当 i &lt; m-1 and j &lt; n-1 时，可能向下也可能向右，因此需要选择一条消耗能量最小的路径，dp[i][j] = min(down, right)</li><li>在每一个格子 i,j, 若骑士向下走，进入到 (i,j) 前需要的最少能量为 down = max(1, dp[i+1][j]-dungeon[i][j]); 若骑士向右走，进入到 (i,j) 前需要的最少能量为 right = max(1, dp[i][j+1]-dungeon[i][j])</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span><span class="params">(self, dungeon)</span>:</span></span><br><span class="line">    m = len(dungeon)</span><br><span class="line">    n = len(dungeon[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">    dp[<span class="number">-1</span>][<span class="number">-1</span>] = max(<span class="number">1</span>, -dungeon[<span class="number">-1</span>][<span class="number">-1</span>]+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            down = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; m<span class="number">-1</span>:</span><br><span class="line">                down = max(<span class="number">1</span>, dp[i+<span class="number">1</span>][j]-dungeon[i][j])</span><br><span class="line">            right = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; n<span class="number">-1</span>:</span><br><span class="line">                right = max(<span class="number">1</span>, dp[i][j+<span class="number">1</span>]-dungeon[i][j])</span><br><span class="line">            <span class="keyword">if</span> down <span class="keyword">and</span> right:</span><br><span class="line">                dp[i][j] = min(down, right)</span><br><span class="line">            <span class="keyword">elif</span> down:</span><br><span class="line">                dp[i][j] = down</span><br><span class="line">            <span class="keyword">elif</span> right:</span><br><span class="line">                dp[i][j] = right</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="Maximal-Square"><a href="#Maximal-Square" class="headerlink" title="Maximal Square"></a>Maximal Square</h3><p><a href="https://leetcode.com/problems/maximal-square/description/" target="_blank" rel="noopener">Leetcode : 221. Maximal Square (Medium)</a></p><p>思路： 用 dp[i][j] 来存储以点 (i,j) 为右下角的正方形的最大边长。</p><ul><li>当 matrix[i][j] == ‘0’ 时，边长为 0，则 dp[i][j] = 0</li><li>当 matrix[i][j] == ‘1’ 时，则比较 (i,j) 周围的三个点 (i-1,j) (i,j-1) (i-1,j-1) 取其最小值加一则为正方形边长。<br>因此状态转移公式为： dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</li></ul><p>最后要得到边长最大的正方形的面积，则用一个 res 记录下遍历时的最大边长即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = len(matrix)</span><br><span class="line">    m = len(matrix[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dp[i][<span class="number">0</span>] = int(matrix[i][<span class="number">0</span>])</span><br><span class="line">        res = max(res, dp[i][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        dp[<span class="number">0</span>][j] = int(matrix[<span class="number">0</span>][j])</span><br><span class="line">        res = max(res, dp[<span class="number">0</span>][j])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">                res = max(res, dp[i][j])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> res**<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="股票最大收益"><a href="#股票最大收益" class="headerlink" title="股票最大收益"></a>股票最大收益</h3><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">Leetcode : 121. Best Time to Buy and Sell Stock (Easy)</a></p><p>问题描述：只能买入和卖出一次，求股票最大的收益。若是持续下跌，则收益为 0。<br>记录下最小值和最大的收益，遍历一遍，时间 o(n) 空间 o(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_profit</span><span class="params">(prices)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(prices) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    pmin = prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):</span><br><span class="line">        <span class="keyword">if</span> prices[i] &lt; pmin:</span><br><span class="line">            pmin = prices[i]</span><br><span class="line">        <span class="keyword">if</span> prices[i] - pmin &gt; profit:</span><br><span class="line">            profit = prices[i] - pmin</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a>Best Time to Buy and Sell Stock III</h3><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="noopener">Leetcode : 123. Best Time to Buy and Sell Stock III (Hard)</a></p><p>问题描述：允许最多买入卖出 2 次，求最大 profit。  </p><p>该题若将 prices 数组分为两个部分，再复用上题的结果分别计算每个部分的 maxProfit 会超时。  </p><p>思路：考虑用两个数组来存储结果， profit_max1[i] 为前 i 天的最大利润，profit_max2[i] 为 i 天之后的最大利润，注意 profit_max2[i] 需要从后往前计算，而且存的是 pmax，用 pmax-prices[i]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">    n = len(prices)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    profit_max1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    profit_max2 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    </span><br><span class="line">    pmin = prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        profit_max1[i] = max(profit_max1[i<span class="number">-1</span>], prices[i]-pmin)</span><br><span class="line">        pmin = min(pmin, prices[i])</span><br><span class="line">    </span><br><span class="line">    pmax = prices[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        profit_max2[i] = max(profit_max2[i+<span class="number">1</span>], pmax-prices[i])</span><br><span class="line">        pmax = max(pmax, prices[i])</span><br><span class="line">        </span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        profit = max(profit, profit_max1[i]+profit_max2[i])</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure><h3 id="Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="Best Time to Buy and Sell Stock IV"></a>Best Time to Buy and Sell Stock IV</h3><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/" target="_blank" rel="noopener">Leetcode : 188. Best Time to Buy and Sell Stock IV (Hard)</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="/2018/12/18/algorithms/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/18/algorithms/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>排序可以分为比较排序和非比较排序。比较排序有插入排序、希尔排序、选择排序、冒泡排序、快速排序、堆排序和归并排序；非比较排序有桶排序、基数排序和计数排序。  </p><a id="more"></a><p>稳定排序：在排序前有 x<sub>i</sub>=x<sub>j</sub>，且 x<sub>i</sub> 排在 x<sub>j</sub> 前面，在排序后仍然是 x<sub>i</sub> 排在 x<sub>j</sub> 前面，则这种排序算法是稳定的。  </p><p>o(nlogn) 时间复杂度的有：快速排序、堆排序、归并排序。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>顺序地把待排序序列中的各个记录按其关键字的大小，插入到已排序的序列的适当位置。<br>开始排序时，认为序列的第一个记录已排好序，然后将第二个记录与其进行比较交换，则第二个记录插入到已排好序的序列中。<br>之后的 arr[i] 与前 i-1 个记录进行比较，将其插入到比他小的记录的后面。<br>从后往前比较，把所有比当前待排序的记录更大的数都往后移动一位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        tmp = arr[i]</span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> j <span class="keyword">and</span> tmp &lt; arr[j<span class="number">-1</span>]:</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[j] = tmp</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>将第一个记录 arr[0] 与第二个记录 arr[1] 比较，若 arr[0]&gt;arr[1]，则交换，以此类推到最后一个记录，一次冒泡的结果将数组中最大的数排到 arr 末尾。<br>外层 for 控制排序的执行次数，内层 for 控制一次排序中相邻记录的比较和交换，一共要执行 n 次冒泡，每次冒泡比较次数为 n-i ，因此时间复杂度 O(n<sup>2</sup>) 。相邻元素相等时没有发生交换，因此冒泡排序是稳定的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    length = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(length-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]  <span class="comment">#1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>备注：</p><ol><li>python 交换两个元素不需要中间变量  a,b = b,a</li><li>算法改进：<br>优化 1：若某一次遍历没有发生数据交换，则数组已经排好序，无需继续冒泡，设置一个 flag 来标明没有发生交换的时候</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort1</span><span class="params">(arr)</span>:</span></span><br><span class="line">    length = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        flag = <span class="number">1</span> <span class="comment">###</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(length-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">                flag = <span class="number">0</span> <span class="comment">###</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">break</span> <span class="comment"># 已排好序，直接跳出</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>优化 2：记录每次遍历最后发生交换的位置，则该位置后面已经排好序，则下次冒泡只需遍历该位置之前的数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort2</span><span class="params">(arr)</span>:</span></span><br><span class="line">    length = len(arr)</span><br><span class="line">    k = length<span class="number">-1</span> <span class="comment"># j的循环范围</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">                k = j <span class="comment"># 记录最后一次交换的位置</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">break</span> <span class="comment"># 已排好序，直接跳出</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序采用分治思想，以第一个数 arr[0] 作为基准，通过一趟排序将数据分成两部分，比 arr[0] 小的数排在左边，比 arr[0] 大的数排在右边，再对这两个部分进行快排，所有序列长度为1时则序列已排好序。  </p><p>快速排序的时间复杂度为 O(nlogn)，空间复杂度 O(n)<br>首先就一次快速排序使用的空间是O(1)的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据；</p><ul><li>最优的情况下空间复杂度为：O(logn)  ；每一次都平分数组的情况</li><li>最差的情况下空间复杂度为：O( n ) ；退化为冒泡排序的情况</li></ul><p>大小相同的元素可能会交换顺序，因此快速排序是不稳定排序</p><p>快速排序的总体平均效率是最好的，但并不是任何时刻都最优。 最差的情况是如果数组已经排好序，时间复杂度会变为 O(n<sup>2</sup>)。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;=  right:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    low = left</span><br><span class="line">    high = right</span><br><span class="line">    key = arr[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right: </span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] &gt;= key:  <span class="comment">#1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        arr[left] = arr[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt;= key:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        arr[right] = arr[left]</span><br><span class="line">    arr[left] = key</span><br><span class="line">    quick_sort(arr, low, left<span class="number">-1</span>)</span><br><span class="line">    quick_sort(arr, left + <span class="number">1</span>, high)</span><br></pre></td></tr></table></figure><p>备注：1. 必须要再加一层 while left &lt; right，否则没有终止条件，会出现数组越界</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆是以一维数组实现的，可以被看成一个完全二叉树，树上的每个结点对应数组的一个元素。除了最底层外，该树是完全充满的，而且是从左往右填充。  </p><p><strong>最大堆</strong>：除根结点以外的所有结点 i 都满足 a[parent(i)] &gt;= a[i]，即非叶子结点的大于等于左右孩子的值; 即最大堆的最大元素存放在根节点中，用于升序排序。每次取出最大堆的根节点，之后需要调整堆，使得剩下的结点组成一个最大堆。</p><blockquote><p>第 i 个结点 a[i] 的父元素为 a[(i-1)/2]<br>第 i 个结点 a[i] 的左孩子为 a[2i+1]<br>第 i 个结点 a[i] 的右孩子为 a[2i+2]  </p></blockquote><p><strong>调整堆 max_heapify</strong>  </p><ol><li>调整堆是自顶向下，从最后一个非叶子结点开始，从左至右，从上到下依次进行调整，使得子节点不超过父节点的值。  </li><li>比较 i 的根节点与其左右孩子的大小， 当 a[i] &lt; a[2i+1]，则将根节点的值与左孩子的值互换； 当 a[i] &lt; a[2i+2]，则将根节点的值与右孩子的值互换。  </li><li>迭代调用上述过程。</li></ol><p><strong>建立最大堆 build_max_heap</strong>  </p><ol><li>建立最大堆是自底向上，利用 max_heapify() 来将数组转化为最大堆。  </li><li>长度为 n 的数组构建的堆的最后一个非叶子结点下标为 n/2-1，从该结点开始，往前逐步调整堆，直到根节点。  </li></ol><p><strong>堆排序 heap_sort</strong>  </p><ol><li>利用 build_max_heap() 和 max_heapify() 进行操作。首先建立最大堆。  </li><li>将堆的根节点与最后一个结点交换， 将前面的 len-1 个结点做调整堆的过程，直到所有结点取出。对于 n 个结点需要做 n-1 次操作。</li></ol><p>堆排序的时间复杂度为 o(nlogn)，调整堆需要 o(logn) 的时间，一共需要调整 n 次。<br>堆排序的空间复杂度为 o(1)。堆排序是不稳定排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span><span class="params">(heap, heap_size, root)</span>:</span></span><br><span class="line">    left = <span class="number">2</span> * root + <span class="number">1</span></span><br><span class="line">    right = <span class="number">2</span> * root + <span class="number">2</span></span><br><span class="line">    largest = root</span><br><span class="line">    <span class="keyword">if</span> left &lt; heap_size <span class="keyword">and</span> heap[largest] &lt; heap[left]:</span><br><span class="line">        largest = left</span><br><span class="line">    <span class="keyword">if</span> right &lt; heap_size <span class="keyword">and</span> heap[largest] &lt; heap[right]:</span><br><span class="line">        largest = right</span><br><span class="line">    <span class="keyword">if</span> largest != root:</span><br><span class="line">        heap[largest], heap[root] = heap[root], heap[largest]</span><br><span class="line">        max_heapify(heap, heap_size, largest)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_max_heap</span><span class="params">(heap)</span>:</span></span><br><span class="line">    heap_size = len(heap)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((heap_size//<span class="number">2</span>)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        max_heapify(heap, heap_size, i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(heap)</span>:</span></span><br><span class="line">    build_max_heap(heap)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heap)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        heap[<span class="number">0</span>], heap[i] = heap[i], heap[<span class="number">0</span>]</span><br><span class="line">        max_heapify(heap, i, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序：将两个或者两个以上的有序序列合并成一个新的有序序列。</p><p>基本思想：采用分治思想，将原始序列看做 n 个有序的子序列，然后不断合并起来。</p><ol><li>将原始序列分为 n 个长度为 1 的子序列，并把相邻的子序列两两合并为单位为 2 的子序列。</li><li>重复上述操作，按顺序成对进行归并，直到整个序列有序。</li></ol><p>总共进行 logn 次归并，每次归并最多比较 n 次，因此时间复杂度为 O(nlogn), 空间复杂度为 O(n) [复杂度较差]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            res.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    res.extend(left[i:])</span><br><span class="line">    res.extend(right[j:])</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    mid = len(arr) // <span class="number">2</span></span><br><span class="line">    left = merge_sort(arr[:mid]) <span class="comment"># 通过递归将原始序列拆为 n 个长度为 1 的子序列</span></span><br><span class="line">    right = merge_sort(arr[mid:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>暂未总结</p><h2 id="Leetcode-排序相关"><a href="#Leetcode-排序相关" class="headerlink" title="Leetcode 排序相关"></a>Leetcode 排序相关</h2><h3 id="Insertion-Sort-List"><a href="#Insertion-Sort-List" class="headerlink" title="Insertion Sort List"></a>Insertion Sort List</h3><p><a href="https://leetcode.com/problems/insertion-sort-list/description/" target="_blank" rel="noopener">Leetcode : 147. Insertion Sort List (Medium)</a></p><p>用插入排序对链表进行排序。<br>链表不能像数组一样，从后往前遍历，必须要从起始节点往后遍历。</p><p>由于可能会改变链表表头，用 dummy 创建辅助节点，并用在每次遍历时，用 pre 记录下 dummy 节点，表示当前节点 cur 前面的节点。 实际上需要进行操作的节点是 cur.next。</p><p>当 cur.val &gt; cur.next.val 时，说明 cur.next 需要插入到已经排好序的前面的链表中，因此循环一遍前面的链表，当 cur.next.val &lt; pre.next.val 时，说明 cur.next 节点需要插入到 pre 的后面，cur.next.next 的前面。</p><p>要移动的节点需要先保存下来，即 tmp = cur.next, 之后再进行移动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    dummy.next = head</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur.next:</span><br><span class="line">        <span class="keyword">if</span> cur.val &gt; cur.next.val:</span><br><span class="line">            pre = dummy</span><br><span class="line">            <span class="keyword">while</span> cur.next.val &gt;= pre.next.val:</span><br><span class="line">                pre = pre.next</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = cur.next.next</span><br><span class="line">            tmp.next = pre.next</span><br><span class="line">            pre.next = tmp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h3 id="Sort-List"><a href="#Sort-List" class="headerlink" title="Sort List"></a>Sort List</h3><p><a href="https://leetcode.com/problems/sort-list/description/" target="_blank" rel="noopener">Leetcode : 148. Sort List (Medium)</a></p><p>要求时间复杂度为 O(nlogn), 空间复杂度为 O(1)</p><p>用到归并排序，链表排序不需要像数组排序一样开辟一个新的数组用于存储，因此空间复杂度变为 O(1)。<br>利用快慢指针法找到链表的中点，将链表分成两个部分，两个部分排好序后，再将其归并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        right = self.sortList(slow.next)</span><br><span class="line">        slow.next = <span class="literal">None</span></span><br><span class="line">        left = self.sortList(head)</span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val &lt;= right.val:</span><br><span class="line">                cur.next = left</span><br><span class="line">                left = left.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = right</span><br><span class="line">                right = right.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            cur.next = left</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            cur.next = right</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h3 id="Largest-Number"><a href="#Largest-Number" class="headerlink" title="Largest Number"></a>Largest Number</h3><p><a href="https://leetcode.com/problems/largest-number/description/" target="_blank" rel="noopener">Leetcode : 179. Largest Number (Medium)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = [str(x) <span class="keyword">for</span> x <span class="keyword">in</span> nums]</span><br><span class="line">        nums.sort(key = cmp_to_key(<span class="keyword">lambda</span> a, b: <span class="number">1</span> <span class="keyword">if</span> a+b&lt;b+a <span class="keyword">else</span> <span class="number">-1</span>))       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(nums) <span class="keyword">if</span> nums[<span class="number">0</span>] != <span class="string">'0'</span> <span class="keyword">else</span> <span class="string">'0'</span></span><br></pre></td></tr></table></figure><h3 id="Kth-Largest-Element-in-an-Array"><a href="#Kth-Largest-Element-in-an-Array" class="headerlink" title="Kth Largest Element in an Array"></a>Kth Largest Element in an Array</h3><p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">Leetcode : 215. Kth Largest Element in an Array (Medium)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; len(nums) <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = self.quick_sort(nums, left, right)</span><br><span class="line">            <span class="keyword">if</span> mid == len(nums) - k:</span><br><span class="line">                <span class="keyword">return</span> nums[mid]</span><br><span class="line">            <span class="keyword">elif</span> mid &lt; len(nums) - k:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(self, nums, left, right)</span>:</span></span><br><span class="line">        key = nums[left]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt;= key:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt;= key:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            nums[right] = nums[left]</span><br><span class="line">        nums[left] = key</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 二分查找</title>
      <link href="/2018/12/10/algorithms/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/10/algorithms/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>二分查找要求线性表必须采用顺序存储结构，而且表中元素按关键词有序排列。 时间复杂度为 o(log(n))</p><a id="more"></a><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(search_list, search_key)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(search_list) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">        mid = low + (high-low)//<span class="number">2</span>  <span class="comment">#1#2</span></span><br><span class="line">        print(mid)</span><br><span class="line">        <span class="keyword">if</span>(search_key == search_list[mid]):</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span>(search_key &lt; search_list[mid]):</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>需要注意的事项：</p><ol><li>计算 mid 时，使用其它语言（JAVA,C++）编写时，若采用 (low+high)//2 时存在溢出风险，int 最大值为 65535，超过后会变为负值，但 python 中不存在整数溢出问题； </li><li>python3 中除法，/ 为真除法，带小数位，// 取整数位</li></ol><h2 id="二分查找变种"><a href="#二分查找变种" class="headerlink" title="二分查找变种"></a>二分查找变种</h2><ol><li>找第一个，都是返回 left。 找第一个等于，第一个大于等于，判断条件为 if nums[mid] &gt;= target; 第一个大于，判断条件为 if nums[mid] &gt; target</li><li>找最后一个，都是返回 right。 找最后一个等于，最后一个小于等于，判断条件为 if nums[mid] &lt;= target; 最后一个小于，判断条件为 if nums[mid] &lt; target</li><li>注意都需要进行边界判断，找不到返回 -1。 循环终止的时候，left &lt; len(nums), right &gt;= 0, 找相等的时候还需要判断 nums[left] 或 nums[right] 是否会等于 target</li></ol><h3 id="有重复数字，找第一个和最后一个与-target-相等的下标"><a href="#有重复数字，找第一个和最后一个与-target-相等的下标" class="headerlink" title="有重复数字，找第一个和最后一个与 target 相等的下标"></a>有重复数字，找第一个和最后一个与 target 相等的下标</h3><h4 id="Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="Find First and Last Position of Element in Sorted Array"></a>Find First and Last Position of Element in Sorted Array</h4><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/" target="_blank" rel="noopener">Leetcode : 34. Find First and Last Position of Element in Sorted Array (Medium)</a></p><p>时间复杂度为 O(logn)，如果先找到一个 index，再往前往后查找的话，当全部都是一样的数字时，时间会退化为 O(n)<br>因此需要直接用二分查找找出，需要修改条件。跳出条件为 left&lt;=right，到最后 right=left+1, left 可能会越界  </p><ol><li>判断返回 left 还是 right。 当第一个等于 target 的元素，返回 left，找最后一个等于 target 的元素返回 right</li><li>判断 if target ? nums[mid] 这里的符号。 返回第一个等于 target 的元素，需要向左逼近，因此当 target &lt;= nums[mid] 时，让 right = mid - 1</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= target: <span class="comment"># 注意此处的条件</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= len(nums) <span class="keyword">or</span> nums[left] != target: <span class="comment"># 注意此处的条件</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">    l = left</span><br><span class="line"></span><br><span class="line">    right = len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target: <span class="comment"># 注意此处的条件，如果只是单独返回最后一个相等的元素，还是需要判断一下 right &gt;= 0 and nums[right] == target</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [l, right]</span><br></pre></td></tr></table></figure><h3 id="返回第一个大于等于-target-的元素，或返回最后一个小于等于-target-的元素"><a href="#返回第一个大于等于-target-的元素，或返回最后一个小于等于-target-的元素" class="headerlink" title="返回第一个大于等于 target 的元素，或返回最后一个小于等于 target 的元素"></a>返回第一个大于等于 target 的元素，或返回最后一个小于等于 target 的元素</h3><p>第一个大于等于 target：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= target:  <span class="comment"># 若找第一个大于 target 的，只需要改成 &gt;</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">if</span> left &lt; len(nums) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>最后一个小于等于 target：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    left, right = <span class="number">0</span>, len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= target: <span class="comment"># 若找第一个小于 target 的，只需要改成 &lt;</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> right <span class="keyword">if</span> right &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="Leetcode-刷题"><a href="#Leetcode-刷题" class="headerlink" title="Leetcode 刷题"></a>Leetcode 刷题</h2><h3 id="Median-of-Two-Sorted-Arrays"><a href="#Median-of-Two-Sorted-Arrays" class="headerlink" title="Median of Two Sorted Arrays"></a>Median of Two Sorted Arrays</h3><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/description/" target="_blank" rel="noopener">Leetcode : 4. Median of Two Sorted Arrays (Hard)</a></p><h3 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h3><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">Leetcode : 33. Search in Rotated Sorted Array (Medium)</a></p><p>在一个 rotate 的数组中找到目标数字的下标，但不知道 rotate 的位置在哪里，要求时间复杂度为 O(logn)，显然是二分查找。<br>利用二分查找来判断左右两边哪边的序列是有序的，若 nums[mid] 大于 nums[left]，则左边是有序的，若 nums[mid] 小于 nums[right]，则右边是有序的。<br>之后根据有序的半段来判断 num[mid] 是否在该区域中，来调整边界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid= left + (right-left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= nums[left]:</span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[left] <span class="keyword">and</span> target &lt; nums[mid]:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt;= nums[right]:</span><br><span class="line">            <span class="keyword">if</span> target &lt;= nums[right] <span class="keyword">and</span> target &gt; nums[mid]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="Search-in-Rotated-Sorted-Array-II"><a href="#Search-in-Rotated-Sorted-Array-II" class="headerlink" title="Search in Rotated Sorted Array II"></a>Search in Rotated Sorted Array II</h3><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/" target="_blank" rel="noopener">Leetcode : 81. Search in Rotated Sorted Array II (Medium)</a></p><p>与 33 不同的是，该题的数组可能有重复元素。 投机做法： return target in nums<br>该题比 33 多了一种情况，即可能出现 nums[mid] == nums[left], 此时无法判断 target 会在哪一边，因此只能够 left+1 往前走。其余的情况和上一题类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] == nums[left]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; nums[left]:</span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[mid] <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> target &lt; nums[mid] <span class="keyword">and</span> target &gt;= nums[left]:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="Find-First-and-Last-Position-of-Element-in-Sorted-Array-1"><a href="#Find-First-and-Last-Position-of-Element-in-Sorted-Array-1" class="headerlink" title="Find First and Last Position of Element in Sorted Array"></a>Find First and Last Position of Element in Sorted Array</h3><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/" target="_blank" rel="noopener">Leetcode : 34. Find First and Last Position of Element in Sorted Array (Medium)</a></p><p>思路：先二分搜索找到位置，再根据该位置 index，循环判断 nums[index-1] 和 nums[index+1] 是否和 target 相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            index = mid</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> target &gt; nums[mid]:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> index != <span class="number">-1</span>:</span><br><span class="line">        i = index - <span class="number">1</span></span><br><span class="line">        j = index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i] == target:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt;= len(nums)<span class="number">-1</span> <span class="keyword">and</span> nums[j] == target:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [i+<span class="number">1</span>, j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="求开方"><a href="#求开方" class="headerlink" title="求开方"></a>求开方</h3><p><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="noopener">Leetcode : 69. Sqrt(x) (Easy)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sqrt</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x&lt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">elif</span> x&gt;<span class="number">1</span>:</span><br><span class="line">        low = <span class="number">1</span></span><br><span class="line">        high = x</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high):</span><br><span class="line">            mid = low + (high-low)//<span class="number">2</span></span><br><span class="line">            sqrt = x // mid</span><br><span class="line">            <span class="keyword">if</span> sqrt == mid :</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> sqrt &gt; mid:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> high  <span class="comment">#1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>备注：</p><ol><li>一个数 x&gt;1 的开方必定在 1~x 之间，因此可以用二分查找来找到 sqrt</li><li>由于返回的是整数，因此开方包含小数位时，找不到 sqrt==mid ，则返回开方的整数位</li></ol><h3 id="矩阵查找-Search-a-2D-Matrix"><a href="#矩阵查找-Search-a-2D-Matrix" class="headerlink" title="矩阵查找 Search a 2D Matrix"></a>矩阵查找 Search a 2D Matrix</h3><p><a href="https://leetcode.com/problems/search-a-2d-matrix/description/" target="_blank" rel="noopener">Leetocde : 74. Search a 2D Matrix (Medium)</a></p><h3 id="矩阵查找-Search-a-2D-Matrix-II"><a href="#矩阵查找-Search-a-2D-Matrix-II" class="headerlink" title="矩阵查找 Search a 2D Matrix II"></a>矩阵查找 Search a 2D Matrix II</h3><p><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/" target="_blank" rel="noopener">Leetocde : 240. Search a 2D Matrix II (Medium)</a></p><p>这两题的做法是一样的。</p><p>思路：题中要求的有效率的算法，很容易想到二分查找和分治两种方法</p><ol><li>二分查找<br>用二分查找求解需要进行两次二分查找，首先二分查找出 target 所在的行范围，再遍历每一行，二分查找出 target 的位置。最坏情况下的时间复杂度为 o(nlogn)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(matrix, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(matrix)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> low+<span class="number">1</span> &lt; high:</span><br><span class="line">        mid = low + (high-low)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> matrix[mid][<span class="number">0</span>] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> target &gt; matrix[mid][<span class="number">0</span>]:</span><br><span class="line">            low = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">    row = high <span class="keyword">if</span> matrix[high][<span class="number">0</span>] &lt;= target <span class="keyword">else</span> low</span><br><span class="line">    </span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(matrix[<span class="number">0</span>])<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right-left)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> matrix[row][mid] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> target &gt; matrix[row][mid]:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ol start="2"><li>分治法（选择该做法）</li></ol><p>该有序矩阵即按行递增也按列递增，因此可以考虑右上角的数字，若 target &gt; 15，则直接去掉该行，row–；若 target &lt; 15，则去掉该列，column–；此时将原本的二维矩阵变成了更小的矩阵。时间复杂度为 o(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(matrix, target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    row = <span class="number">0</span></span><br><span class="line">    col = len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> row &lt; len(matrix) <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> target == matrix[row][col]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> target &gt; matrix[row][col]:</span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            col -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="Find-Minimum-in-Rotated-Sorted-Array"><a href="#Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Find Minimum in Rotated Sorted Array"></a>Find Minimum in Rotated Sorted Array</h3><p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">Leetcode : 153. Find Minimum in Rotated Sorted Array (Medium)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= nums[right]:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><h3 id="Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="Find Minimum in Rotated Sorted Array II"></a>Find Minimum in Rotated Sorted Array II</h3><p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/" target="_blank" rel="noopener">Leetcode : 154. Find Minimum in Rotated Sorted Array II (Hard)</a></p><ul><li>当 nums[mid] &gt; nums[right]，则 min 肯定是右半部分，而且不可能是 mid， 所以让 left = mid + 1</li><li>当 nums[mid] &lt; nums[right]，则 min 可能是 mid 也可能在左半部分，所以让 right = mid</li><li>当 nums[mid] = nums[right]，可能出现 0111 和 7111 这两种情况，此时让 right-1 总是正确的<br>终止条件是 left=right，因此返回 nums[left] 即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right-left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == nums[right]:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; nums[right]:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><h3 id="Find-Peak-Element"><a href="#Find-Peak-Element" class="headerlink" title="Find Peak Element"></a>Find Peak Element</h3><p><a href="https://leetcode.com/problems/find-peak-element/description/" target="_blank" rel="noopener">Leetcode : 162. Find Peak Element (Medium)</a></p><p>要求时间复杂度为 O(logn)，因此用二分查找。 当 nums[mid] &lt; nums[mid+1] 时，峰值在 mid 右边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid = left + (right-left)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; nums[mid+<span class="number">1</span>]:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h3 id="Find-the-Duplicate-Number"><a href="#Find-the-Duplicate-Number" class="headerlink" title="Find the Duplicate Number"></a>Find the Duplicate Number</h3><p><a href="https://leetcode.com/problems/find-the-duplicate-number/description/" target="_blank" rel="noopener">Leetcode : 287. Find the Duplicate Number (Medium)</a></p><p>问题描述：由题意，不能修改数组，即限制了不能对数组进行排序；要求空间复杂度为 o(1), 则不可以用字典实现；要求时间复杂度 &lt; o(n<sup>2</sup>) 则不能暴力嵌套两次循环求解，想到只能有 o(nlogn) 的时间复杂度，则需要利用二分查找。  </p><p>思路：按照抽屉原理，如果有 n+1 只袜子要放入 n 个抽屉中，那必定有至少一个抽屉中有至少两只袜子。</p><ol><li>对于 1-n 中的数，必定有一个数出现了至少两次，我们可以先用二分查找选取 n/2</li><li>再遍历数组中小于等于 n/2 的数的个数 count，若 count &gt; n/2 大，那么可以说明重复出现的数在 0-n/2 这个区间，否则在 n/2-n 这个区间。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">        mid = low + (high-low) // <span class="number">2</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= mid:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; mid:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure><h3 id="放置硬币"><a href="#放置硬币" class="headerlink" title="放置硬币"></a>放置硬币</h3><p><a href="https://leetcode.com/problems/arranging-coins/description/" target="_blank" rel="noopener">Leetcode : 441. Arranging Coins (Easy)</a></p><p>问题描述：1+2+…+x = n,则 x 为可以摆的层数，最后一层无法摆满时，不能计数。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arrange_coins</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = n</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high):</span><br><span class="line">        mid = low + (high-low)//<span class="number">2</span></span><br><span class="line">        sum = mid * (<span class="number">1</span>+mid) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> sum &lt;= n <span class="keyword">and</span> sum &gt; n-mid:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> sum &gt; n:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="有序数组的Single-Element"><a href="#有序数组的Single-Element" class="headerlink" title="有序数组的Single Element"></a>有序数组的Single Element</h3><p><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/description/" target="_blank" rel="noopener">Leetcode : 540. Single Element in a Sorted Array (Medium)</a></p><p>问题描述：</p><ol><li>分三种情况，mid 刚好是 single；</li><li>single 在左侧，mid 是奇数，则 mid 左右均有奇数个数，若 nums[mid]==nums[mid+1]，右侧还有两个数，single 在左侧；mid 是偶数，则mid 左右均有偶数个数，若 nums[mid]==nums[mid-1]，则 single 在左侧；</li><li>single 在右侧。</li><li>时间复杂度为 o(logn)，典型算法有三个：二分查找，欧几里得算法（求最大公约数），幂运算</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_element</span><span class="params">(nums)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high): <span class="comment">#1</span></span><br><span class="line">        mid = low + (high-low)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] != nums[mid+<span class="number">1</span>] <span class="keyword">and</span> nums[mid]!= nums[mid<span class="number">-1</span>]):</span><br><span class="line">            <span class="keyword">return</span> nums[mid]</span><br><span class="line">        <span class="keyword">elif</span>((mid%<span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> nums[mid] == nums[mid+<span class="number">1</span>]) <span class="keyword">or</span> (mid%<span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> nums[mid] == nums[mid<span class="number">-1</span>])):</span><br><span class="line">            high = mid <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[low]</span><br></pre></td></tr></table></figure><p>备注：</p><ol><li>此处不能等于，否则会出现数组越界情况，如 nums=[1,1,2] 时，此时是由于第一种情况是，判断 nums[mid] != nums[mid+1] 时，当 mid 为 len(nums) - 1 时会造成数组越界。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
