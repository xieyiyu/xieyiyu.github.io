<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="动态规划 Dynamic Programming 是分阶段求解问题，具有最优子结构、边界和状态转移公式三个要素。 一般来说，给定一个规则，让我们求任意状态下的解，都是用动态规划。">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode 动态规划总结">
<meta property="og:url" content="https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="Cactus&#39;s blog">
<meta property="og:description" content="动态规划 Dynamic Programming 是分阶段求解问题，具有最优子结构、边界和状态转移公式三个要素。 一般来说，给定一个规则，让我们求任意状态下的解，都是用动态规划。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bi%5D=min(dp%5Bi-2%5D&plus;cost%5Bi-2%5D,dp%5Bi-1%5D&plus;cost%5Bi-1%5D)">
<meta property="og:image" content="https://latex.codecogs.com/gif.latex?dp%5Bi%5D=max(dp%5Bi-2%5D,dp%5Bi-3%5D)+nums%5Bi%5D">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bi%5D%5Bj%5D=max(dp%5Bi-1%5D%5Bj%5D,dp%5Bi-1%5D%5Bj-w%5Bi%5D%5D&plus;v%5Bi%5D)">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bj%5D=max(dp%5Bj%5D,dp%5Bj-weights%5Bi%5D%5D&plus;values%5Bi%5D)">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bi%5D%5Bj%5D=max(dp%5Bi-1%5D%5Bj%5D,dp%5Bi-1%5D%5Bj-k*weights%5Bi%5D%5D&plus;k*values%5Bi%5D)">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bi%5D%5Bj%5D=max(dp%5Bi-1%5D%5Bj%5D,dp%5Bi%5D%5Bj-weights%5Bi%5D%5D&plus;values%5Bi%5D)">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bj%5D=max(dp%5Bj%5D,dp%5Bj-weight%5Bi%5D%5D&plus;values%5Bi%5D)">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?%5Cdpi%7B200%7D&space;%5Ctiny&space;dp%5Bi%5D%5Bj%5D%5Bk%5D=max(dp%5Bi-1%5D%5Bj%5D%5Bk%5D,dp%5Bi-1%5D%5Bj-weights1%5Bi%5D%5D%5Bk-weights2%5Bi%5D%5D&plus;values%5Bi%5D)">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bj%5D%5Bk%5D=max(dp%5Bj%5D%5Bk%5D,dp%5Bj-weights1%5Bi%5D%5D%5Bk-weights2%5Bi%5D%5D&plus;values%5Bi%5D)">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bj%5D=min(dp%5Bj%5D,dp%5Bj-coins%5Bi%5D&plus;1%5D)">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bi%5D=sum(dp%5Bi-num%5D)">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bj%5D=max(dp%5Bj%5D,dp%5Bj-nums%5Bi%5D%5D&plus;nums%5Bi%5D)">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bi%5D%5Bj%5D=dp%5Bi-1%5D%5Bj%5D&plus;dp%5Bi-1%5D%5Bj-nums%5Bi%5D%5D">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bj%5D=dp%5Bj%5D&plus;dp%5Bj-nums%5Bi%5D%5D">
<meta property="og:image" content="http://latex.codecogs.com/gif.latex?dp%5Bi%5D=min(dp%5Bi%5D,dp%5Bi-j*j%5D)">
<meta property="og:image" content="https://latex.codecogs.com/gif.latex?dp%5Bi%5D=max%5C%7B1,dp%5Bj%5D+1%7Cnums%5Bi%5D%3Enums%5Bj%5D%5C&%5C&i%3Ej%5C%7D">
<meta property="article:published_time" content="2018-12-26T16:12:22.000Z">
<meta property="article:modified_time" content="2020-01-17T02:24:43.240Z">
<meta property="article:author" content="Cactus">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://latex.codecogs.com/gif.latex?dp%5Bi%5D=min(dp%5Bi-2%5D&plus;cost%5Bi-2%5D,dp%5Bi-1%5D&plus;cost%5Bi-1%5D)">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>leetcode 动态规划总结</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="Cactus&#39;s blog" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/01/04/algorithms/%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2018/12/18/algorithms/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&text=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&is_video=false&description=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=leetcode 动态规划总结&body=Check out this article: https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&name=leetcode 动态规划总结&description=&lt;p&gt;动态规划 Dynamic Programming 是分阶段求解问题，具有最优子结构、边界和状态转移公式三个要素。&lt;/p&gt;
&lt;p&gt;一般来说，给定一个规则，让我们求任意状态下的解，都是用动态规划。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&t=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#斐波那契数列"><span class="toc-number">1.</span> <span class="toc-text">斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#台阶问题"><span class="toc-number">1.1.</span> <span class="toc-text">台阶问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#爬楼梯的最低成本"><span class="toc-number">1.2.</span> <span class="toc-text">爬楼梯的最低成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强盗抢劫房子"><span class="toc-number">1.3.</span> <span class="toc-text">强盗抢劫房子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强盗抢劫房子II"><span class="toc-number">1.4.</span> <span class="toc-text">强盗抢劫房子II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#背包问题"><span class="toc-number">2.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1背包"><span class="toc-number">2.1.</span> <span class="toc-text">0-1背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完全背包"><span class="toc-number">2.2.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维费用的背包"><span class="toc-number">2.3.</span> <span class="toc-text">二维费用的背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#背包问题练习"><span class="toc-number">2.4.</span> <span class="toc-text">背包问题练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#按单词列表分割字符串"><span class="toc-number">2.4.1.</span> <span class="toc-text">按单词列表分割字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#找零钱"><span class="toc-number">2.4.2.</span> <span class="toc-text">找零钱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组合总和"><span class="toc-number">2.4.3.</span> <span class="toc-text">组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#划分数组为和相等的两部分"><span class="toc-number">2.4.4.</span> <span class="toc-text">划分数组为和相等的两部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用0-1组成最多的字符串"><span class="toc-number">2.4.5.</span> <span class="toc-text">用0-1组成最多的字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#得到目标和"><span class="toc-number">2.4.6.</span> <span class="toc-text">得到目标和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分割整数"><span class="toc-number">3.</span> <span class="toc-text">分割整数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解码方法"><span class="toc-number">3.1.</span> <span class="toc-text">解码方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完全平方数"><span class="toc-number">3.2.</span> <span class="toc-text">完全平方数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组区间"><span class="toc-number">4.</span> <span class="toc-text">数组区间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#子数组最大和"><span class="toc-number">4.1.</span> <span class="toc-text">子数组最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Product-Subarray"><span class="toc-number">4.2.</span> <span class="toc-text">Maximum Product Subarray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组区间和"><span class="toc-number">4.3.</span> <span class="toc-text">数组区间和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长递增子序列"><span class="toc-number">5.</span> <span class="toc-text">最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最长递增子序列-1"><span class="toc-number">5.1.</span> <span class="toc-text">最长递增子序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长公共子序列"><span class="toc-number">6.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长回文子串"><span class="toc-number">7.</span> <span class="toc-text">最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Palindromic-Substring"><span class="toc-number">7.1.</span> <span class="toc-text">Longest Palindromic Substring</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#矩阵路径"><span class="toc-number">8.</span> <span class="toc-text">矩阵路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unique-Paths"><span class="toc-number">8.1.</span> <span class="toc-text">Unique Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unique-Paths-II"><span class="toc-number">8.2.</span> <span class="toc-text">Unique Paths II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minimum-Path-Sum"><span class="toc-number">8.3.</span> <span class="toc-text">Minimum Path Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Triangle"><span class="toc-number">8.4.</span> <span class="toc-text">Triangle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dungeon-Game"><span class="toc-number">8.5.</span> <span class="toc-text">Dungeon Game</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximal-Square"><span class="toc-number">8.6.</span> <span class="toc-text">Maximal Square</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">9.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#股票最大收益"><span class="toc-number">9.1.</span> <span class="toc-text">股票最大收益</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock-III"><span class="toc-number">9.2.</span> <span class="toc-text">Best Time to Buy and Sell Stock III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock-IV"><span class="toc-number">9.3.</span> <span class="toc-text">Best Time to Buy and Sell Stock IV</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        leetcode 动态规划总结
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Cactus's blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2018-12-26T16:12:22.000Z" itemprop="datePublished">2018-12-26</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/leetcode/" rel="tag">leetcode</a>, <a class="tag-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a>, <a class="tag-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>动态规划 Dynamic Programming 是分阶段求解问题，具有最优子结构、边界和状态转移公式三个要素。</p>
<p>一般来说，给定一个规则，让我们求任意状态下的解，都是用动态规划。</p>
<a id="more"></a>

<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="台阶问题"><a href="#台阶问题" class="headerlink" title="台阶问题"></a>台阶问题</h3><p><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">Leetcode : 70. Climbing Stairs (Easy)</a></p>
<blockquote>
<p>You are climbing a stair case. It takes n steps to reach to the top.<br>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
</blockquote>
<p>问题描述：分解为子问题，F(n) = F(n-1) + F(n-2),是一个斐波那契数列，可以直接用递归求解，但递归的时间复杂度是指数级别的 o(n<sup>2</sup>) ，会出现参数被重复计算的问题。</p>
<p>利用动态规划求解：F(n-1) 和 F(n-2) 是 F(n) 的最优子结构，F(1) 和 F(2) 是问题边界（可以直接得出结果，不需要继续简化），F(n) = F(n-1) + F(n-2) 即状态转移公式。</p>
<p>自底向上对该问题进行求解，由于 F(n) 只依赖于 F(n-1) 和 F(n-2)，因此可以使用中间变量将其进行保存，从 1-n 依次迭代。此时时间复杂度为 o(n),空间复杂度为 o(1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climb_stairs</span><span class="params">(n)</span>:</span></span><br><span class="line">    a = b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        cur = a + b</span><br><span class="line">        a = b</span><br><span class="line">        b = cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<ol>
<li>python 中无需关心其实际含义的变量可用 _ 代替，仅需要循环，不需要计数  </li>
<li>a 表示到 i-2 台阶的方法数，b 表示到 i-1 台阶的方法数，cur 表示到当前台阶的方法数</li>
</ol>
<h3 id="爬楼梯的最低成本"><a href="#爬楼梯的最低成本" class="headerlink" title="爬楼梯的最低成本"></a>爬楼梯的最低成本</h3><p><a href="https://leetcode.com/problems/min-cost-climbing-stairs/description/" target="_blank" rel="noopener">Leetcode : 746. Min Cost Climbing Stairs (Easy)</a></p>
<p>问题描述：爬楼梯，每次可以走一层或者两层，每层都有一个花费 cost[i]， 求到顶点时的最小花费。  </p>
<p><strong>方法一：</strong><br>可以用一个列表 dp[i] 来表示到达第 i 层的花费(到达第 i 层时不需要加上 cost[i])，则我们要求的到顶点的花费即为 dp[len(cost)]， dp[] 的长度比 cost[] 的长度更大 1。<br>因此到达第 i 层时，可能是从 i-1 层跳上来，也可能是从 i-2 层跳上来，需要求这两种情况下的最小值。</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i]=min(dp[i-2]&plus;cost[i-2],dp[i-1]&plus;cost[i-1])"></div>

<p>该方法的时间复杂度为 o(n)，空间复杂度为 o(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_cost_climb_stairs</span><span class="params">(cost)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(cost)+<span class="number">1</span>):</span><br><span class="line">        dp.append(min(dp[i<span class="number">-2</span>] + cost[i<span class="number">-2</span>], dp[i<span class="number">-1</span>] + cost[i<span class="number">-1</span>]))</span><br><span class="line">    <span class="keyword">return</span> dp[len(cost)]</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong><br>由于 dp[i] 只与 dp[i-2] 和 dp[i-1] 以及 cost 有关，因此用三个变量即可。用 pre1 代表 dp[i-1]，用 pre2 代表 dp[i-2]， 用 cur 代表 dp[i]。<br>该方法的时间复杂度为 o(n)，空间复杂度为 o(1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_cost_climb_stairs</span><span class="params">(cost)</span>:</span></span><br><span class="line">    pre1, pre2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(cost) + <span class="number">1</span>):</span><br><span class="line">        cur = min(pre2 + cost[i<span class="number">-2</span>], pre1 + cost[i<span class="number">-1</span>])</span><br><span class="line">        pre2 = pre1</span><br><span class="line">        pre1 = cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h3 id="强盗抢劫房子"><a href="#强盗抢劫房子" class="headerlink" title="强盗抢劫房子"></a>强盗抢劫房子</h3><p><a href="https://leetcode.com/problems/house-robber/description/" target="_blank" rel="noopener">Leetcode : 198. House Robber (Easy)</a></p>
<p>问题描述：抢劫一排住户，不能抢相邻的，求最大的抢劫金额。与上一题相似。  </p>
<p>抢劫到第 i 个住户时最大的抢劫量为 dp[i]，由于不能抢 i-1 的住户，因此此时只能抢 i-2 或 i-3 的住户，因此 dp[i] 依赖于 dp[i-2] 和 dp[i-3] 的值；</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=max(dp[i-2],dp[i-3])+nums[i]"/></div>

<p>方法一：采用<strong>备忘录算法</strong>，该解法的时间复杂度为 o(n),空间复杂度为 o(n)，使用列表 dp[] 来记录下抢劫到第 i 个房子时最大的抢劫量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(nums)</span>:</span></span><br><span class="line">    size = len(nums)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    dp = []</span><br><span class="line">    dp.append(nums[<span class="number">0</span>])</span><br><span class="line">    dp.append(max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]))</span><br><span class="line">    dp.append(max(nums[<span class="number">0</span>]+nums[<span class="number">2</span>], nums[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, size):</span><br><span class="line">        dp.append(max(dp[i<span class="number">-2</span>], dp[i<span class="number">-3</span>]) + nums[i])</span><br><span class="line">    <span class="keyword">return</span> max(dp[size<span class="number">-1</span>], dp[size<span class="number">-2</span>])</span><br></pre></td></tr></table></figure>

<p>方法二：改进算法，空间复杂度 o(1) 实现。由于 dp[i] 依赖于 dp[i-2] 和 dp[i-3] 的值，因此需要记录下这两个的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    pre1 = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    pre2 = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">        cur = max(pre1, pre2+nums[i])</span><br><span class="line">        pre2 = pre1</span><br><span class="line">        pre1 = cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h3 id="强盗抢劫房子II"><a href="#强盗抢劫房子II" class="headerlink" title="强盗抢劫房子II"></a>强盗抢劫房子II</h3><p><a href="https://leetcode.com/problems/house-robber-ii/description/" target="_blank" rel="noopener">Leetcode : 213. House Robber II (Medium)</a></p>
<p>问题描述：房子的分布变为环形，即第一个和最后一个相邻，可以分别求去掉第一个的最大值，和去掉最后一个的最大值，然后比较两者的大小</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    size = len(nums)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> max(nums)</span><br><span class="line">    <span class="keyword">return</span> max(self.rob2(nums[<span class="number">1</span>:]), self.rob2(nums[:size<span class="number">-1</span>]))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob2</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    pre1 = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    pre2 = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">        cur = max(pre2+nums[i], pre1)</span><br><span class="line">        pre2 = pre1</span><br><span class="line">        pre1 = cur</span><br><span class="line">    <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>

<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h3><p>0-1 背包问题是在 M 件物品取出若干件放在空间为 N 的背包里，每种物品有且只有一个，并且有体积 w 和价值 v 两个属性。  </p>
<p>定义二维数组 dp 来存储最大价值，dp[i][j] 表示体积为 j 的背包，前 i 件物品能够达到的最大价值。对于第 i 件物品，有两种情况：  </p>
<ol>
<li>不放入第 i 件物品，则能够达到的最大价值为放入前 i-1 件物品的最大价值，即 dp[i][j] = dp[i-1][j]；  </li>
<li>放入第 i 件物品，则能够达到的最大价值为放入前 i-1 件物品的最大价值加上第 i 件物品的价值，即 dp[i][j] = dp[i-1][j-w[i]] + v[i]。  </li>
</ol>
<p>选出上述两种情况下的最大价值，则为空间为 j 的背包能够放下的物品的最大价值。因此，可以得到状态转移方程为：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]&plus;v[i])"></div> <br>

<p><strong>方法一</strong>：以填充格子的形式求解，返回最后一个格子即得到最大价值。<br>该方法的时间复杂度为 o(NM), 空间复杂度为 o(NM)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bag_01</span><span class="params">(M, N, weights, values)</span>:</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(N+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(M)] <span class="comment"># 初始化二维数组，物品数 M 为行，背包容量 N 为列</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(N+<span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = values[<span class="number">0</span>] <span class="keyword">if</span> j &gt;= weights[<span class="number">0</span>] <span class="keyword">else</span> <span class="number">0</span> <span class="comment"># 填充边界</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">            <span class="keyword">if</span> j &gt;= weights[i]:</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weights[i]] + values[i])</span><br><span class="line">    <span class="keyword">return</span> dp[M<span class="number">-1</span>][N]</span><br></pre></td></tr></table></figure>
<p>填完表格后，仅能得到最优解，但不知道最优解由哪些元素组成，通过最优解回溯，可以找到选择的物品。  </p>
<ol>
<li>当 dp[i][j] = dp[i-1][j] 时，说明第 i 件物品没有被选择， 则回到 dp[i-1][j]  </li>
<li>当 dp[i][j] = dp[i-1][j-weights[i]] + values[i], 说明选择了第 i 件物品，然后再回到装该物品之前的状态，即 dp[i-1][j-weights[i]] 时  </li>
<li>遍历到 i=0 时，找到组成最优解的商品  </li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bag_res</span><span class="params">(dp, N, M, weights, values)</span>:</span></span><br><span class="line">    j = N</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> dp[i][j] == dp[i<span class="number">-1</span>][j-weights[i]] + values[i]:</span><br><span class="line">            res.append(i+<span class="number">1</span>)</span><br><span class="line">            j = j - weights[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong>优化空间。由状态转移公式可知，前 i 件物品的状态只与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，用 dp[j] 来表示 dp[i][j] 和 dp[i-1][j]。此时的状态转移方程为：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=max(dp[j],dp[j-weights[i]]&plus;values[i])"></div>

<p>此时时间复杂度为 o(M * N), 空间复杂度为 o(N)  </p>
<p>需要注意的是：dp[] 填充时，必须要从右到左进行填充，也就是 j 应该倒序循环求解。否则，前一项的值即 dp[j-weights[i]] 改变了，dp[j] 无法求得正确的结果。  </p>
<p>但使用该方法，由于之前的数据被覆盖掉，只能够得到最后的最大价值，无法知道最优解由哪些元素组成，两种方法各有利弊。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bag01</span><span class="params">(M, N, weights, values)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[j] &lt;= dp[j-weights[i]] + values[i] <span class="keyword">and</span> j-weights[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[j] = dp[j-weights[i]] + values[i]</span><br><span class="line">    <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure>

<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>与 0-1 背包的条件基本一致，但每种物品都有若干件。<br>思路：  </p>
<ol>
<li>用 dp[i][j] 表示前 i 种物品放入若干件时到空间为 j 的背包中的最大价值。  </li>
<li>根据第 i 种物品放入的件数进行决策，对于空间 j，物品 i 能够放入的最大件数为 j/weights[i]，将其转化为 0-1背包求解。</li>
</ol>
<p>转为转移公式为, k 表示件数，(0 &lt;= k * weights[i] &lt;= j)：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i][j]=max(dp[i-1][j],dp[i-1][j-k*weights[i]]&plus;k*values[i])"></div>

<p>此时时间复杂度为 o(NM∑(j/weights[i]))</p>
<p><strong>优化一：</strong><br>直接对放与不放第 i 件物品进行决策。  </p>
<ol>
<li>不放第 i 件物品，则 dp[i][j] = dp[i-1][j]  </li>
<li>放第 i 件物品，则 dp[i][j] 中至少会出现一件物品 i，我们认为之前已经最大限度地放置了物品 i，如果能够放进去就放最后一件 i， 则此时 dp[i][j] = <strong>dp[i][j-weights[i]]</strong> + values[i]， <strong>注意此处与 0-1背包的区别</strong>。</li>
</ol>
<p>此时的状态转移公式为：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i][j]=max(dp[i-1][j],dp[i][j-weights[i]]&plus;values[i])"></div>

<p><strong>优化二：</strong><br>使用一维数组进行存储，状态转移公式与 01背包 的一维数组解法相同：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=max(dp[j],dp[j-weight[i]]&plus;values[i])"></div>

<p>此时要注意的是，完全背包与 01背包 的一维数组解法的遍历顺序不同：<br>01背包遍历 j 时需要逆序遍历，使得 dp[j-weights[i]] 存储的值为 dp[i-1][j-weights[i]] 的值，每个物品只使用一次；<br>而完全背包遍历 j 时需要正序遍历，此时 dp[j-weights[i]] 存储的值为 dp[i][j-weights[i]]的值，每个物品可以使用多次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">complete_bag</span><span class="params">(M, N, weights, values)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(weights[i], N+<span class="number">1</span>): <span class="comment">#1</span></span><br><span class="line">            <span class="keyword">if</span> dp[j] &lt;= dp[j - weights[i]] + values[i] <span class="keyword">and</span> j - weights[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[j] = dp[j - weights[i]] + values[i]</span><br><span class="line">        print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure>

<p>备注： 1. 唯一不同的地方在于对 j 的遍历。<strong>此处从 weights[i] 到 N+1</strong></p>
<h3 id="二维费用的背包"><a href="#二维费用的背包" class="headerlink" title="二维费用的背包"></a>二维费用的背包</h3><p>二维费用的背包是：对每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对每种费用都有一个可付出的最大值，即背包容量。  </p>
<p>设第 i 件物品所需的两种费用分别为 weights1[i] 和 weights2[i], 两种费用可付出的最大值为 N1 和 N2，物品的价值为 values[i]。</p>
<p>由于费用增加一维，则此时状态转移公式也需要增加一维，变为 dp[i][j][k]，用来表示前 i 件物品付出两种费用为 j 和 k 时可以获得的最大价值。此时的状态转移公式为：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?\dpi{200}&space;\tiny&space;dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-weights1[i]][k-weights2[i]]&plus;values[i])"></div>


<p>优化空间，使用二维形式表示：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j][k]=max(dp[j][k],dp[j-weights1[i]][k-weights2[i]]&plus;values[i])"></div>

<p>时间复杂度为 o(N1N2M), 空间复杂度为 o(N1N2)</p>
<p>注意：</p>
<ol>
<li>若每件物品只能取 1 次，即 01背包，则变量 j,k 逆序循环。</li>
<li>若每件物品可以取多次，即完全背包，则变量 j,k 顺序循环。</li>
</ol>
<h3 id="背包问题练习"><a href="#背包问题练习" class="headerlink" title="背包问题练习"></a>背包问题练习</h3><h4 id="按单词列表分割字符串"><a href="#按单词列表分割字符串" class="headerlink" title="按单词列表分割字符串"></a>按单词列表分割字符串</h4><p><a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="noopener">Leetcode : 139. Word Break (Medium)</a></p>
<p>问题描述：按照单词列表来分割字符串，若是分隔的字符串都在 word_dict 中，则返回 True。</p>
<p>用 dp[i] 来表示到第 i 个字符时是否可以被正确分割。对于上述的例子，有 dp[0] == True; dp[4] == True; dp[8] == True。当最后一个 dp[len(s)] == True 时，则表明整个字符串都可以被分割。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word_break</span><span class="params">(s, word_dict)</span>:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    dp = [<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> word_dict:</span><br><span class="line">            <span class="keyword">if</span> dp[i-len(word)] <span class="keyword">and</span> s[i-len(word):i] == word:</span><br><span class="line">                dp[i] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h4 id="找零钱"><a href="#找零钱" class="headerlink" title="找零钱"></a>找零钱</h4><p><a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="noopener">Leetcode : 322. Coin Change (Medium)</a></p>
<p>思路：显然这是一个完全背包问题，不同的是要寻找最少的硬币数来组成总额 amount，因此可以用 dp[] 来表示最少的硬币数，dp[] 的初始化应为无穷大。</p>
<p>状态转移公式为：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=min(dp[j],dp[j-coins[i]&plus;1])"></div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coin_change</span><span class="params">(coins, amount)</span>:</span></span><br><span class="line">    INF = float(<span class="string">"inf"</span>)  <span class="comment">#1</span></span><br><span class="line">    dp = [<span class="number">0</span>] + [INF] * amount </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(coins)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i], amount + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[j - coins[i]] != INF:</span><br><span class="line">                dp[j] = min(dp[j], dp[j - coins[i]] + <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != INF <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>备注：1. 注意 python 中无穷大可以用 float(“inf”) 来表示， 也可以写成 INF = 0x7ffffffe</p>
<h4 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h4><p><a href="https://leetcode.com/problems/combination-sum-iv/description/" target="_blank" rel="noopener">Leetcode : 377. Combination Sum IV (Medium)</a></p>
<p>问题描述：组合 nums 中的数使它们的和为 target。  </p>
<p>思路：用 dp[i] 表示 target 为 i 时，nums[] 可以组合的总数，那么对于上述的 dp[4]，遍历一遍 nums[], dp[4] = dp[3] + dp[2] + dp[1] （3，2，1三个数字），因此状态转移公式为：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i]=sum(dp[i-num])"></div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    dp = [<span class="number">1</span>] + [<span class="number">0</span>] * target  <span class="comment">#1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &lt;= i:</span><br><span class="line">                dp[i] += dp[i - num]</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>
<p>备注：<br>1.这里 dp[0] = 1 是因为当正好 nums[] 中有数字能组成 i 时，比如 3 一个数字就可以组成 dp[3]，那么 dp[3] += dp[0]，有一种解法。<br>2. dp[i-num] 表示能组成 i-num 的解法数，在这些解法的末尾加入 num，则得到 dp[i] 的解法，遍历一遍nums，所有 dp[i] 的解法数相加则得到最终结果，不会产生重复和缺失的问题。</p>
<h4 id="划分数组为和相等的两部分"><a href="#划分数组为和相等的两部分" class="headerlink" title="划分数组为和相等的两部分"></a>划分数组为和相等的两部分</h4><p><a href="https://leetcode.com/problems/partition-equal-subset-sum/description/" target="_blank" rel="noopener">Leetcode : 416. Partition Equal Subset Sum (Medium)</a></p>
<p>问题描述：将一个数组划分为和相等的两部分。可以看成是一个背包大小为 sum/2 的 0-1背包问题，且这个背包必须要被填满。可以用一个一维数组进行求解，将每个数字所占空间和价值都用 nums[i] 来表示。由题意得到的状态转移公式为：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=max(dp[j],dp[j-nums[i]]&plus;nums[i])"></div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">can_partition</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    V = sum(nums) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">2</span> * V != sum(nums):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (V + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[j] &lt;= dp[j - nums[i]] + nums[i] <span class="keyword">and</span> j - nums[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[j] = dp[j - nums[i]] + nums[i]</span><br><span class="line">                <span class="keyword">if</span> dp[j] == V:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="用0-1组成最多的字符串"><a href="#用0-1组成最多的字符串" class="headerlink" title="用0-1组成最多的字符串"></a>用0-1组成最多的字符串</h4><p><a href="https://leetcode.com/problems/ones-and-zeroes/description/" target="_blank" rel="noopener">Leetcode : 474. Ones and Zeroes (Medium)</a></p>
<p>思路：该问题为二维费用的 01背包问题，有两个费用，0 的数量和 1 的数量，其为背包的最大容量。组成每一个 strs[i] 都需要花费一些 0 和 1，将每个 strs[i] 的价值看做 1。<br>时间复杂度为 o(mnl), 空间复杂度为 o(mn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_form</span><span class="params">(strs, m, n)</span>:</span></span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(strs)):</span><br><span class="line">        ones = strs[i].count(<span class="string">'1'</span>)</span><br><span class="line">        zeros = strs[i].count(<span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n, ones<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(m, zeros<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[j][k] = max(dp[j][k], dp[j - ones][k - zeros] + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> dp[n][m]</span><br></pre></td></tr></table></figure>

<h4 id="得到目标和"><a href="#得到目标和" class="headerlink" title="得到目标和"></a>得到目标和</h4><p><a href="https://leetcode.com/problems/target-sum/description/" target="_blank" rel="noopener">Leetcode : 494. Target Sum (Medium)</a></p>
<p>问题描述：给定一个数组 nums[] 和一个目标数字 s, 数组中的数可以是给定 + 或 -，求其和能组成 s 的方法的总数。  </p>
<p>可以将 nums[]中的数看成两部分，要给 + 的数字为放入数组 P 中，要给 - 的数字放入数组 N 中，因此可以得到：  </p>
<blockquote>
<p>sum(P) - sum(N) = target<br>sum(p) + sum(N) = sum(nums)  </p>
</blockquote>
<p>由上式可以得到 sum(p) = (target + sum(nums)) // 2<br>因此该问题可以看成一个 0-1背包问题，从给定的 nums[] 中选出一个子集，如果其和等于 (target + sum(nums)) // 2, 则这个子集符合题意，找到有多少个这样的自己即得到所有的方法。  </p>
<p>因此可以用 dp[i][j] 表示前 i 个数的和为 j 的方法总数。第 i 个数可以选择放入背包或者不放入，则状态转移公式为：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i][j]=dp[i-1][j]&plus;dp[i-1][j-nums[i]]"></div>
空间优化后的状态转移公式为：
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[j]=dp[j]&plus;dp[j-nums[i]]"></div>  

<p>时间复杂度为 o(n<sup>2</sup>), 空间复杂度为 o(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_target_sum_ways</span><span class="params">(nums, S)</span>:</span></span><br><span class="line">    nsum = sum(nums)</span><br><span class="line">    target = (nsum + S) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> nsum &lt; S <span class="keyword">or</span> (nsum + S) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(target, nums[i] - <span class="number">1</span>, <span class="number">-1</span>): <span class="comment">#1</span></span><br><span class="line">            dp[j] = dp[j] + dp[j - nums[i]]</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>

<p>备注：1.此处的遍历从 target 到 num[i]-1，从而减少遍历的次数， 需要注意的是 range 的区间为左闭右开，即 [traget, nums[i]-1)</p>
<h2 id="分割整数"><a href="#分割整数" class="headerlink" title="分割整数"></a>分割整数</h2><h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a>解码方法</h3><p><a href="https://leetcode.com/problems/decode-ways/description/" target="_blank" rel="noopener">Leetcode : 91. Decode Ways (Medium)</a></p>
<p>问题描述：按照编码规则来将信息中的字母编码，给定编码，返回解码的方法总数。  </p>
<p>思路：用 dp[i] 来表示前 i 个字符的解码总数，由于数字只有处于 1-26 之间时才可以解码，因此可以分为三种情况。</p>
<ol>
<li>dp[i] = dp[i-2] + dp[i-1], (10 &lt; int(s[i-2 : i]) &lt;= 26 and int(s[i-2 : i]) != 20)  </li>
<li>dp[i] = dp[i-2], (int(s[i-2 : i]) == 20 or int(s[i-2 : i]) == 10)  </li>
<li>dp[i] = dp[i-1], (s[i-1] != ‘0’)  </li>
</ol>
<p>必须要注意的时，0 只有和 10，20 才可以解码成功</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    size = len(s)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'0'</span>: <span class="comment">#1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">1</span>,<span class="number">1</span>] + [<span class="number">0</span>] * (size - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, size + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">10</span> &lt; int(s[i<span class="number">-2</span> : i]) &lt;= <span class="number">26</span> <span class="keyword">and</span> int(s[i<span class="number">-2</span> : i]) != <span class="number">20</span>:</span><br><span class="line">            dp[i] = dp[i<span class="number">-2</span>] + dp[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">elif</span> int(s[i<span class="number">-2</span> : i]) == <span class="number">20</span> <span class="keyword">or</span> int(s[i<span class="number">-2</span> : i]) == <span class="number">10</span>:</span><br><span class="line">            dp[i] = dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">elif</span> s[i<span class="number">-1</span>] != <span class="string">'0'</span>:</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> dp[size]</span><br></pre></td></tr></table></figure>
<p>备注：1. 必须先判断 size，再判断 s[0]，否则空字符串会造成数组越界。</p>
<h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p><a href="https://leetcode.com/problems/perfect-squares/description/" target="_blank" rel="noopener">Leetcode : 279. Perfect Squares(Medium)</a></p>
<p>问题描述：按完全平方数来分割整数，将一个数 n 分割成 1,4,9,16…… 的和。  </p>
<p>思路：用 dp[i] 来存储组成数字 i 的完全平方数的最小个数，<br>因为：13 = 1 * 1 + 12， 13 = 2 * 2 + 9，13 = 3 * 3 + 4<br>那么 dp[13] = min(1 + dp[12], 1 + dp[9], 1 + dp[4])<br>状态转移公式为：</p>
<div align="center"><img src="http://latex.codecogs.com/gif.latex?dp[i]=min(dp[i],dp[i-j*j])"></div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_squares</span><span class="params">(n)</span>:</span></span><br><span class="line">    INF = float(<span class="string">"inf"</span>)</span><br><span class="line">    dp = [INF] * (n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, int(math.sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">            dp[i] = min(dp[i], dp[i - j * j] + <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>

<h2 id="数组区间"><a href="#数组区间" class="headerlink" title="数组区间"></a>数组区间</h2><h3 id="子数组最大和"><a href="#子数组最大和" class="headerlink" title="子数组最大和"></a>子数组最大和</h3><p><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">Leetcode : 53. Maximum Subarray (Easy)</a></p>
<p>问题描述：找到一个数组中的连续子数组的最大的和。  </p>
<p>到第 i 个数时的子数组最大和只可能是 sum[i-1] + nums[i] 或者是 nums[i]自身， 即<br>sum[i] = max(sum[i-1] + nums[i], nums[i])<br>当前 i-1 项的和 sum[i-1] &lt;= 0 时，则 sum[i]<br> = nums[i]， 抛弃之前的子数组，从 i 开始寻找新的最大和的子数组。这样就可以得到每一部分的最大的 sum，最后再从每一部分的最大 sum 中找到整个数组的 max_sum 。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_subArray</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        sum = max(sum + nums[i], nums[i])</span><br><span class="line">        max_sum = max(max_sum, sum)</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>

<h3 id="Maximum-Product-Subarray"><a href="#Maximum-Product-Subarray" class="headerlink" title="Maximum Product Subarray"></a>Maximum Product Subarray</h3><p><a href="https://leetcode.com/problems/maximum-product-subarray/description/" target="_blank" rel="noopener">Leetcode : 152. Maximum Product Subarray (Medium)</a></p>
<p>思路： max[i] 表示以 i 结尾的子数组中的最大乘积，若要 O(1) 的空间复杂度，则用 res 记录下 max[i] 中的最大值。<br>但是由于会出现 <strong>负负得正</strong> 的情况，因此还需要记录下最小值 min[i]。<br>最大最小乘积只会在 [max[i-1] * nums[i], min[i-1] * nums[i], nums[i]] 三者之间产生。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    res = maxp = minp = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">        lastmax = maxp</span><br><span class="line">        maxp = max(minp*nums[i], lastmax*nums[i], nums[i])</span><br><span class="line">        minp = min(minp*nums[i], lastmax*nums[i], nums[i])</span><br><span class="line">        res = max(res, maxp)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="数组区间和"><a href="#数组区间和" class="headerlink" title="数组区间和"></a>数组区间和</h3><p><a href="https://leetcode.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">Leetcode : 303. Range Sum Query - Immutable (Easy)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        self.dp = nums</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            self.dp[x] = self.dp[x<span class="number">-1</span>] + nums[x]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum_range</span><span class="params">(self, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.dp[j] - self.dp[i<span class="number">-1</span>] <span class="keyword">if</span> i !=<span class="number">0</span> <span class="keyword">else</span> self.dp[j]</span><br></pre></td></tr></table></figure>
<p>备注：必须将前 x 个数的和先存下来，否则会超时；直接令 dp = nums，这样就不用再初始化 dp[0] = nums[0]，简洁高效。</p>
<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p><strong>子序列</strong>：已知一个序列 {S<sub>1</sub>, S<sub>2</sub>,…,S<sub>n</sub>} ，取出若干数组成新的序列 {S<sub>i1</sub>, S<sub>i2</sub>,…, S<sub>im</sub>}，其中 i1、i2 … im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个子序列。  </p>
<p><strong>递增子序列</strong>：如果在子序列中，当下标 ix &gt; iy 时，S<sub>ix</sub> &gt; S<sub>iy</sub>，称子序列为原序列的一个递增子序列。  </p>
<h3 id="最长递增子序列-1"><a href="#最长递增子序列-1" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p><a href="https://leetcode.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="noopener">Leetcode : 300. Longest Increasing Subsequence (Medium)</a></p>
<blockquote>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.  </p>
<p>For example,<br>Given [10, 9, 2, 5, 3, 7, 101, 18],<br>The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p>
</blockquote>
<p>思路：定义数组 dp[i] 表示到第 i 个数的最长递增子序列的长度，则对于一个递增子序列 {S<sub>i1</sub>, S<sub>i2</sub>,…,S<sub>im</sub>}，如果 im &lt; n 并且 S<sub>im</sub> &lt; S<sub>n</sub> ，此时 {S<sub>i1</sub>, S<sub>i2</sub>,…, S<sub>im</sub>, S<sub>n</sub>} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的即是最长递增子序列。<br>因此，状态转移公式为：</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=max\{1,dp[j]+1|nums[i]>nums[j]\&\&i>j\}"/></div> <br>

<p>对于长度为 n 的序列，最长递增子序列不一定是以 nums[n-1] 结尾，因此 dp[n-1] 不一定是最长递增子序列的长度，应该是 dp[] 数组的最大值。  </p>
<p>该解法的时间复杂度为 o(n<sup>2</sup>)， 空间复杂度为 o(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">length_of_LIS</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dp_max = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                dp_max = max(dp_max, dp[j] + <span class="number">1</span>)</span><br><span class="line">        dp[i] = dp_max</span><br><span class="line">    <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>

<p><strong>时间优化</strong>：利用二分查找可将时间复杂度优化到 o(nlogn)</p>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><h3 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a>Longest Palindromic Substring</h3><p><a href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank" rel="noopener">Leetcode : 5. Longest Palindromic Substring (Medium)</a></p>
<p>思路：枚举每个回文串的中点，再向左右两边扩展扫描，直到不是回文串为止，存在两种情况。</p>
<ul>
<li>回文串长度为奇数，则中点是 s 中的每个字符，有 len(s) 种可能</li>
<li>回文串长度为偶数，则中点是 s[i]+s[i+1]，有 len(s)-1 种可能<br>对于每个中心往两边扫的时间复杂度为 O(n)，则该方法的时间复杂度为 O((2n-1) * n) = O(n<sup>2</sup>)</li>
</ul>
<p>以上思路需要对 s 遍历两边，对其进行改进，逐一遍历 s 中的每一个字符，并比较其与后面一个字符，如果相等的话，则先找到这一对相邻的字符，再向左右扩展，此时把 i 更新为 right 的值，这样也省去了一些重复的计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    res = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        left = right = i</span><br><span class="line">        <span class="keyword">while</span> right &lt; n<span class="number">-1</span> <span class="keyword">and</span> s[right] == s[right+<span class="number">1</span>]:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        i = right</span><br><span class="line">        <span class="keyword">while</span> left &gt; <span class="number">0</span> <span class="keyword">and</span> right &lt; n<span class="number">-1</span> <span class="keyword">and</span> s[left<span class="number">-1</span>] == s[right+<span class="number">1</span>]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right-left+<span class="number">1</span> &gt; len(res):</span><br><span class="line">            res = s[left:right+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="矩阵路径"><a href="#矩阵路径" class="headerlink" title="矩阵路径"></a>矩阵路径</h2><h3 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a>Unique Paths</h3><p><a href="https://leetcode.com/problems/unique-paths/description/" target="_blank" rel="noopener">Leetcode : 62. Unique Paths (Medium)</a></p>
<p>一开始想将 dp 数组全部置为 0， 然后把第一行和第一列置为 1，实际可以简化为全部置为1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">    dp = [[<span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Unique-Paths-II"><a href="#Unique-Paths-II" class="headerlink" title="Unique Paths II"></a>Unique Paths II</h3><p><a href="https://leetcode.com/problems/unique-paths-ii/description/" target="_blank" rel="noopener">Leetocde : 63. Unique Paths II (Medium)</a></p>
<p>在矩阵中设置障碍，用 0 和 1 来表示该格是否有障碍。<br>填充 dp 时需要注意，如果是第一行第一列中出现了障碍，那么该障碍之后的路都走不通，需要全部置为 0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">    n = len(obstacleGrid)</span><br><span class="line">    m = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][j] != <span class="number">1</span>:</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a>Minimum Path Sum</h3><p><a href="https://leetcode.com/problems/minimum-path-sum/description/" target="_blank" rel="noopener">Leetcode : 64. Minimum Path Sum (Medium)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">    n = len(grid)</span><br><span class="line">    m = len(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">and</span> m == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j]</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Triangle"><a href="#Triangle" class="headerlink" title="Triangle"></a>Triangle</h3><p><a href="https://leetcode.com/problems/triangle/description/" target="_blank" rel="noopener">Leetcode : 120. Triangle (Medium)</a></p>
<p>若要空间复杂度为 O(n)，则只能用一维数组，此时在遍历 j 的时候必须从后往前遍历，才不会丢失原来的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    dp[<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                dp[j] = dp[j] + triangle[i][j]</span><br><span class="line">            <span class="keyword">elif</span> j == i:</span><br><span class="line">                dp[j] = dp[j<span class="number">-1</span>] + triangle[i][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[j] = min(dp[j], dp[j<span class="number">-1</span>]) + triangle[i][j]</span><br><span class="line">    <span class="keyword">return</span> min(dp)</span><br></pre></td></tr></table></figure>

<h3 id="Dungeon-Game"><a href="#Dungeon-Game" class="headerlink" title="Dungeon Game"></a>Dungeon Game</h3><p><a href="https://leetcode.com/problems/dungeon-game/description/" target="_blank" rel="noopener">Leetcode : 174. Dungeon Game (Hard)</a><br>由题意，当其实的能量 HP &lt;= 0 时则游戏结束，所以需要保证其实到每一个格子的时候，都有 HP &gt;= 1。  </p>
<p>思路：</p>
<ol>
<li>从右下角向上填充格子，用 dp[i][j] 表示进入到 i,j 格子前需要的最小 HP 数，因此对于最后一个格子， dp[-1][-1] = max(1, -dungeon[-1][-1]+1)</li>
<li>在每一个格子 i,j ，骑士可能向下走或者向右走， 当 i=m-1 时，不能向下，只能向右走；当 j=n-1 时，只能向下走；当 i &lt; m-1 and j &lt; n-1 时，可能向下也可能向右，因此需要选择一条消耗能量最小的路径，dp[i][j] = min(down, right)</li>
<li>在每一个格子 i,j, 若骑士向下走，进入到 (i,j) 前需要的最少能量为 down = max(1, dp[i+1][j]-dungeon[i][j]); 若骑士向右走，进入到 (i,j) 前需要的最少能量为 right = max(1, dp[i][j+1]-dungeon[i][j])</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span><span class="params">(self, dungeon)</span>:</span></span><br><span class="line">    m = len(dungeon)</span><br><span class="line">    n = len(dungeon[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(n)] <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line">    dp[<span class="number">-1</span>][<span class="number">-1</span>] = max(<span class="number">1</span>, -dungeon[<span class="number">-1</span>][<span class="number">-1</span>]+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            down = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; m<span class="number">-1</span>:</span><br><span class="line">                down = max(<span class="number">1</span>, dp[i+<span class="number">1</span>][j]-dungeon[i][j])</span><br><span class="line">            right = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; n<span class="number">-1</span>:</span><br><span class="line">                right = max(<span class="number">1</span>, dp[i][j+<span class="number">1</span>]-dungeon[i][j])</span><br><span class="line">            <span class="keyword">if</span> down <span class="keyword">and</span> right:</span><br><span class="line">                dp[i][j] = min(down, right)</span><br><span class="line">            <span class="keyword">elif</span> down:</span><br><span class="line">                dp[i][j] = down</span><br><span class="line">            <span class="keyword">elif</span> right:</span><br><span class="line">                dp[i][j] = right</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Maximal-Square"><a href="#Maximal-Square" class="headerlink" title="Maximal Square"></a>Maximal Square</h3><p><a href="https://leetcode.com/problems/maximal-square/description/" target="_blank" rel="noopener">Leetcode : 221. Maximal Square (Medium)</a></p>
<p>思路： 用 dp[i][j] 来存储以点 (i,j) 为右下角的正方形的最大边长。</p>
<ul>
<li>当 matrix[i][j] == ‘0’ 时，边长为 0，则 dp[i][j] = 0</li>
<li>当 matrix[i][j] == ‘1’ 时，则比较 (i,j) 周围的三个点 (i-1,j) (i,j-1) (i-1,j-1) 取其最小值加一则为正方形边长。<br>因此状态转移公式为： dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1</li>
</ul>
<p>最后要得到边长最大的正方形的面积，则用一个 res 记录下遍历时的最大边长即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = len(matrix)</span><br><span class="line">    m = len(matrix[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dp[i][<span class="number">0</span>] = int(matrix[i][<span class="number">0</span>])</span><br><span class="line">        res = max(res, dp[i][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        dp[<span class="number">0</span>][j] = int(matrix[<span class="number">0</span>][j])</span><br><span class="line">        res = max(res, dp[<span class="number">0</span>][j])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">                res = max(res, dp[i][j])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> res**<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="股票最大收益"><a href="#股票最大收益" class="headerlink" title="股票最大收益"></a>股票最大收益</h3><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">Leetcode : 121. Best Time to Buy and Sell Stock (Easy)</a></p>
<p>问题描述：只能买入和卖出一次，求股票最大的收益。若是持续下跌，则收益为 0。<br>记录下最小值和最大的收益，遍历一遍，时间 o(n) 空间 o(1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_profit</span><span class="params">(prices)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(prices) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    pmin = prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)):</span><br><span class="line">        <span class="keyword">if</span> prices[i] &lt; pmin:</span><br><span class="line">            pmin = prices[i]</span><br><span class="line">        <span class="keyword">if</span> prices[i] - pmin &gt; profit:</span><br><span class="line">            profit = prices[i] - pmin</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>

<h3 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a>Best Time to Buy and Sell Stock III</h3><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="noopener">Leetcode : 123. Best Time to Buy and Sell Stock III (Hard)</a></p>
<p>问题描述：允许最多买入卖出 2 次，求最大 profit。  </p>
<p>该题若将 prices 数组分为两个部分，再复用上题的结果分别计算每个部分的 maxProfit 会超时。  </p>
<p>思路：考虑用两个数组来存储结果， profit_max1[i] 为前 i 天的最大利润，profit_max2[i] 为 i 天之后的最大利润，注意 profit_max2[i] 需要从后往前计算，而且存的是 pmax，用 pmax-prices[i]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">    n = len(prices)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    profit_max1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    profit_max2 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    </span><br><span class="line">    pmin = prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        profit_max1[i] = max(profit_max1[i<span class="number">-1</span>], prices[i]-pmin)</span><br><span class="line">        pmin = min(pmin, prices[i])</span><br><span class="line">    </span><br><span class="line">    pmax = prices[n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        profit_max2[i] = max(profit_max2[i+<span class="number">1</span>], pmax-prices[i])</span><br><span class="line">        pmax = max(pmax, prices[i])</span><br><span class="line">        </span><br><span class="line">    profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        profit = max(profit, profit_max1[i]+profit_max2[i])</span><br><span class="line">    <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>

<h3 id="Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="Best Time to Buy and Sell Stock IV"></a>Best Time to Buy and Sell Stock IV</h3><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/" target="_blank" rel="noopener">Leetcode : 188. Best Time to Buy and Sell Stock IV (Hard)</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#斐波那契数列"><span class="toc-number">1.</span> <span class="toc-text">斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#台阶问题"><span class="toc-number">1.1.</span> <span class="toc-text">台阶问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#爬楼梯的最低成本"><span class="toc-number">1.2.</span> <span class="toc-text">爬楼梯的最低成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强盗抢劫房子"><span class="toc-number">1.3.</span> <span class="toc-text">强盗抢劫房子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强盗抢劫房子II"><span class="toc-number">1.4.</span> <span class="toc-text">强盗抢劫房子II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#背包问题"><span class="toc-number">2.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1背包"><span class="toc-number">2.1.</span> <span class="toc-text">0-1背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完全背包"><span class="toc-number">2.2.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维费用的背包"><span class="toc-number">2.3.</span> <span class="toc-text">二维费用的背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#背包问题练习"><span class="toc-number">2.4.</span> <span class="toc-text">背包问题练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#按单词列表分割字符串"><span class="toc-number">2.4.1.</span> <span class="toc-text">按单词列表分割字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#找零钱"><span class="toc-number">2.4.2.</span> <span class="toc-text">找零钱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组合总和"><span class="toc-number">2.4.3.</span> <span class="toc-text">组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#划分数组为和相等的两部分"><span class="toc-number">2.4.4.</span> <span class="toc-text">划分数组为和相等的两部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用0-1组成最多的字符串"><span class="toc-number">2.4.5.</span> <span class="toc-text">用0-1组成最多的字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#得到目标和"><span class="toc-number">2.4.6.</span> <span class="toc-text">得到目标和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分割整数"><span class="toc-number">3.</span> <span class="toc-text">分割整数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解码方法"><span class="toc-number">3.1.</span> <span class="toc-text">解码方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完全平方数"><span class="toc-number">3.2.</span> <span class="toc-text">完全平方数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组区间"><span class="toc-number">4.</span> <span class="toc-text">数组区间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#子数组最大和"><span class="toc-number">4.1.</span> <span class="toc-text">子数组最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Product-Subarray"><span class="toc-number">4.2.</span> <span class="toc-text">Maximum Product Subarray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组区间和"><span class="toc-number">4.3.</span> <span class="toc-text">数组区间和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长递增子序列"><span class="toc-number">5.</span> <span class="toc-text">最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最长递增子序列-1"><span class="toc-number">5.1.</span> <span class="toc-text">最长递增子序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长公共子序列"><span class="toc-number">6.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最长回文子串"><span class="toc-number">7.</span> <span class="toc-text">最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Palindromic-Substring"><span class="toc-number">7.1.</span> <span class="toc-text">Longest Palindromic Substring</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#矩阵路径"><span class="toc-number">8.</span> <span class="toc-text">矩阵路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unique-Paths"><span class="toc-number">8.1.</span> <span class="toc-text">Unique Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unique-Paths-II"><span class="toc-number">8.2.</span> <span class="toc-text">Unique Paths II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minimum-Path-Sum"><span class="toc-number">8.3.</span> <span class="toc-text">Minimum Path Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Triangle"><span class="toc-number">8.4.</span> <span class="toc-text">Triangle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dungeon-Game"><span class="toc-number">8.5.</span> <span class="toc-text">Dungeon Game</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximal-Square"><span class="toc-number">8.6.</span> <span class="toc-text">Maximal Square</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">9.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#股票最大收益"><span class="toc-number">9.1.</span> <span class="toc-text">股票最大收益</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock-III"><span class="toc-number">9.2.</span> <span class="toc-text">Best Time to Buy and Sell Stock III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock-IV"><span class="toc-number">9.3.</span> <span class="toc-text">Best Time to Buy and Sell Stock IV</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&text=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&is_video=false&description=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=leetcode 动态规划总结&body=Check out this article: https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&title=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&name=leetcode 动态规划总结&description=&lt;p&gt;动态规划 Dynamic Programming 是分阶段求解问题，具有最优子结构、边界和状态转移公式三个要素。&lt;/p&gt;
&lt;p&gt;一般来说，给定一个规则，让我们求任意状态下的解，都是用动态规划。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=https://xieyiyu.github.io/2018/12/26/algorithms/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&t=leetcode 动态规划总结" target="_blank" rel="noopener"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 Cactus
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a href="/categories/">Categories</a></li>
         
          <li><a href="/tags/">Tags</a></li>
         
          <li><a href="/search/">Search</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
