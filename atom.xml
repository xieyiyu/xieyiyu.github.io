<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cactus&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xieyiyu.github.io/"/>
  <updated>2020-01-17T02:24:43.240Z</updated>
  <id>https://xieyiyu.github.io/</id>
  
  <author>
    <name>Cactus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="https://xieyiyu.github.io/2020/01/17/test/"/>
    <id>https://xieyiyu.github.io/2020/01/17/test/</id>
    <published>2020-01-17T10:23:29.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python 时间函数总结</title>
    <link href="https://xieyiyu.github.io/2019/12/15/python/Python-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>https://xieyiyu.github.io/2019/12/15/python/Python-%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-15T10:55:51.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>在实际开发中，常常需要用到日期和时间，并将其进行格式化处理，在 Python 中的时间模块常用的是 time 和 datetime，这两个模块中的方法容易混淆，特此对 Python 中的日期时间获取与格式化进行梳理总结。</p><a id="more"></a><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><ol><li><p>UTC time Coordinated Universal Time：世界协调时间，又称格林尼治天文时间、世界标准时间。与 UTC time 对应的是各个时区的 local time，也就是本地时间，如北京时间。</p></li><li><p>epoch time：表示时间开始的起点，是一个特定的时间，不同平台上这个时间点的值不太相同，对 Unix，epoch time 是 1970-01-01 00:00:00 UTC。</p></li><li><p>timestamp：时间戳，也称为 Unix 时间或 POSIX 时间，是一种时间表示方式，表示从格林尼治时间 1970 年 1 月 1 日 0 时 0 分 0 秒开始到现在所经过的毫秒数，其值为 float 类型。<strong>但需要注意的是这在某些编程语言中是秒数，比如 python。</strong></p></li></ol><p>对应的，在 python 中日期时间也有三种表示方式。</p><ol><li><p>timestamp： 时间戳</p></li><li><p>struct_time：时间元组，共有九个元素组。stamptime 时间戳和格式化时间字符串之间的转化必须通过 struct_time 才行，所以 struct_time 是 3 种时间表示的中心。</p></li><li><p>format time：格式化时间，已格式化的结构字符串使时间更具可读性。包括自定义格式和固定格式。</p></li></ol><p>在使用过程中，常需要在三种时间格式之间进行相应的转换，以得到我们想要的表现格式。</p><h3 id="time-模块"><a href="#time-模块" class="headerlink" title="time 模块"></a>time 模块</h3><p>在 time 模块中，获取当前时间只有一种方式，使用<code>time.time()</code>，但得到的是时间戳格式的时间，想要获取时间元组和格式化时间，只能进行转换。</p><h4 id="timestamp-与-struct-time"><a href="#timestamp-与-struct-time" class="headerlink" title="timestamp 与 struct_time"></a>timestamp 与 struct_time</h4><p>localtime 和 gmtime 方法都可以将时间戳转化为时间元组，如果不传入参数默认为当前时间。localtime 转的是本地时间， gmtime 是世界标准时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># struct_time to timestamp</span></span><br><span class="line">time.mktime(time.localtime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># timestamp to struct_time</span></span><br><span class="line">t = time.time() <span class="comment"># 1576397965.253168</span></span><br><span class="line">time.localtime(t)</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=12, tm_mday=15, tm_hour=16, tm_min=19, tm_sec=25, tm_wday=6, tm_yday=349, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">time.gmtime(t)</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=12, tm_mday=15, tm_hour=8, tm_min=19, tm_sec=25, tm_wday=6, tm_yday=349, tm_isdst=0)</span></span><br></pre></td></tr></table></figure><h5 id="struct-time"><a href="#struct-time" class="headerlink" title="struct_time"></a>struct_time</h5><table><thead><tr><th>属性</th><th>含义</th><th>值</th></tr></thead><tbody><tr><td>tm_wday</td><td>weekday</td><td>0 - 6（0 表示周日）</td></tr><tr><td>tm_yday</td><td>一年中的第几天</td><td>1 - 366</td></tr><tr><td>tm_isdst</td><td>是否是夏令时</td><td>默认为 -1</td></tr></tbody></table><p>struct_time 属性值获取可以通过两种方式获取：</p><ul><li>利用下标，如 st[0] 即 tm_year 的值</li><li>通过对象名 <code>st.tm_year</code> 获取</li></ul><h4 id="struct-time-与-format-time"><a href="#struct-time-与-format-time" class="headerlink" title="struct_time 与 format_time"></a>struct_time 与 format_time</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># struct_time to format_time</span></span><br><span class="line">time.strftime(<span class="string">"%Y-%m-%d"</span>) <span class="comment"># '2019-12-18'</span></span><br><span class="line">time.strftime(<span class="string">"%Y-%m-%d"</span>, time.localtime())</span><br><span class="line"></span><br><span class="line"><span class="comment"># format_time to struct_time</span></span><br><span class="line">time.strptime(<span class="string">'2019-12-18'</span>, <span class="string">'%Y-%m-%d'</span>)</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=12, tm_mday=18, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=2, tm_yday=352, tm_isdst=-1)</span></span><br></pre></td></tr></table></figure><h5 id="format-time"><a href="#format-time" class="headerlink" title="format_time"></a>format_time</h5><table><thead><tr><th>格式</th><th>含义</th></tr></thead><tbody><tr><td>%a</td><td>本地（locale）简化星期名称</td></tr><tr><td>%A</td><td>本地完整星期名称</td></tr><tr><td>%b</td><td>本地简化月份名称</td></tr><tr><td>%B</td><td>本地完整月份名称</td></tr><tr><td>%c</td><td>本地相应的日期和时间表示</td></tr><tr><td>%d</td><td>一个月中的第几天（01 - 31）</td></tr><tr><td>%H</td><td>一天中的第几个小时（24小时制，00 - 23）</td></tr><tr><td>%I</td><td>第几个小时（12小时制，01 - 12）</td></tr><tr><td>%j</td><td>一年中的第几天（001 - 366）</td></tr><tr><td>%m</td><td>月份（01 - 12）</td></tr><tr><td>%M</td><td>分钟数（00 - 59）</td></tr><tr><td>%p</td><td>本地 am 或者 pm 的相应符</td></tr><tr><td>%S</td><td>秒（00 - 61, 60 是闰秒，61 是基于历史原因保留）</td></tr><tr><td>%U</td><td>一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。</td></tr><tr><td>%w</td><td>一个星期中的第几天（0 - 6，0是星期天）</td></tr><tr><td>%W</td><td>和 %U 基本相同，不同的是 %W 以星期一为一个星期的开始。</td></tr><tr><td>%x</td><td>本地相应日期</td></tr><tr><td>%X</td><td>本地相应时间</td></tr><tr><td>%y</td><td>去掉世纪的年份（00 - 99）</td></tr><tr><td>%Y</td><td>完整的年份</td></tr><tr><td>%Z</td><td>时区的名字（如果不存在为空字符）</td></tr><tr><td>%%</td><td>‘%’字符</td></tr></tbody></table><p>最常用： <code>%Y-%m-%d %H:%M:%S</code></p><h3 id="datetime-模块"><a href="#datetime-模块" class="headerlink" title="datetime 模块"></a>datetime 模块</h3><p>datetime 模块是对 time 模块的进一步封装，对用户更加友好，在时间的获取上也比较方便。 datetime 模块中常用的类有 date、time、datetime 和 timedelta。</p><h4 id="date-类"><a href="#date-类" class="headerlink" title="date 类"></a>date 类</h4><p>date 对象由 year、 month、 day 三部分组成： datetime.date(year, month, day)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">a = datetime.date(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">18</span>)</span><br><span class="line">a.year <span class="comment"># 2019</span></span><br><span class="line">a.month <span class="comment"># 12</span></span><br><span class="line">a.day <span class="comment"># 18</span></span><br></pre></td></tr></table></figure><h4 id="time-类"><a href="#time-类" class="headerlink" title="time 类"></a>time 类</h4><p>datetime.time(hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ) </p><p>静态方法和字段：</p><ul><li>time.min、time.max：time类所能表示的最小、最大时间。其中，time.min = time(0, 0, 0, 0)， time.max = time(23, 59, 59, 999999)；</li><li>time.resolution：时间的最小单位，这里是 1 微秒；</li></ul><h4 id="datetime-类"><a href="#datetime-类" class="headerlink" title="datetime 类"></a>datetime 类</h4><p>datetime 相当于 date 和 time 结合起来<br><code>datetime.datetime (year, month, day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] )</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">dt = datetime.datetime.now() <span class="comment"># datetime.datetime(2019, 12, 18, 20, 56, 36, 415244)</span></span><br><span class="line">dt.date() <span class="comment"># datetime.date(2019, 12, 18)</span></span><br><span class="line">dt.time() <span class="comment"># datetime.time(20, 56, 36, 415244)</span></span><br><span class="line">dt.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>) <span class="comment"># '2019-12-18 20:56:36'</span></span><br><span class="line">dt.ctime() <span class="comment"># 'Wed Dec 18 20:56:36 2019'，返回一个日期时间的 C 格式字符串</span></span><br><span class="line">dt.utctimetuple() <span class="comment"># UTC 时间元组：time.struct_time(tm_year=2019, tm_mon=12, tm_mday=18, tm_hour=20, tm_min=56, tm_sec=36, tm_wday=2, tm_yday=352, tm_isdst=0)</span></span><br></pre></td></tr></table></figure><h4 id="timedelta-类"><a href="#timedelta-类" class="headerlink" title="timedelta 类"></a>timedelta 类</h4><p>timedelta 类可以实现日期之间的加减运算，包括 date、time、datetime 对象。注意不能计算月份。</p><ol><li>获取之前或之后的时间: 天(days), 小时(hours), 分钟(minutes), 秒(seconds), 微秒(microseconds)。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dt - datetime.timedelta(days=<span class="number">1</span>) <span class="comment"># 昨天，datetime.datetime(2019, 12, 17, 20, 56, 36, 415244)</span></span><br><span class="line">dt + datetime.timedelta(hours=<span class="number">8</span>) <span class="comment"># 当前时间向后 8 小时，datetime.datetime(2019, 12, 19, 4, 56, 36, 415244)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>获取时间差，时间差单位默认为秒，可以查看天(days), 秒(seconds), 微秒(microseconds)。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start_time = datetime.datetime.now()</span><br><span class="line">end_time = start_time + datetime.timedelta(hours=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">end_time - start_time <span class="comment"># datetime.timedelta(seconds=28800)</span></span><br><span class="line">(end_time - start_time).seconds <span class="comment"># 28800</span></span><br><span class="line">(end_time - start_time).days <span class="comment"># 0</span></span><br></pre></td></tr></table></figure><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.cnblogs.com/awakenedy/articles/9182036.html" target="_blank" rel="noopener">Python datetime模块详解</a><br><a href="https://www.cnblogs.com/haitaoli/p/10823403.html" target="_blank" rel="noopener">python time模块和datetime模块详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际开发中，常常需要用到日期和时间，并将其进行格式化处理，在 Python 中的时间模块常用的是 time 和 datetime，这两个模块中的方法容易混淆，特此对 Python 中的日期时间获取与格式化进行梳理总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据结构底层实现</title>
    <link href="https://xieyiyu.github.io/2019/09/25/python/Python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>https://xieyiyu.github.io/2019/09/25/python/Python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-09-25T21:54:32.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>list、dict、set、tuple 是 python 中常用的四种数据结构，在平常的学习中只是简单学习了其使用方式，没有了解底层实现，特此记录和学习一下更深层次的知识。</p><a id="more"></a><h2 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h2><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>python 的内建数据类型 dict 字典，就是用哈希表实现的。</p><p>Python 是使用开放寻址法中的二次探查来解决冲突的。然后如果使用的容量超过数组大小的 2/3，就申请更大的容量。数组大小较小的时候 resize 为 * 4，较大的时候 resize * 2。实际上是用左移的形式。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合 set 中的元素互不相同，没有重复元素，set 中的元素是无序的，比如 {1, 2, 3} 和 {3, 2, 1} 是同一个集合，创建一个空集合可以用 <code>s = set()</code>，将一个 list 转为 set 元素的顺序会打乱。</p><p>set 和 dict 的底层实现方式类似，都是使用哈希，把 set 的实现方式叫做 Hash Set，dict 的实现叫 Hash Table。<br>set 与 dict 的不同是，set 只存储 key，对于 set 查找元素的时间复杂度为 O(1)</p><p>set 的去重是通过两个函数 <code>__hash__</code> 和 <code>__eq__</code> 结合实现的</p><ol><li>当两个变量的哈希值不同时，就认为这两个变量是不同的</li><li>当两个变量哈希值相同时，调用 <code>__eq__</code> 方法，返回 True 则这两个变量是同一个，应该去除一个；返回 False 则不去重，因为哈希值相同的变量的值可能不同。</li></ol><p>set 中的元素和 dict 的 key 必须是可以 hash 的，不可变类型类型都是可 hash 的，比如 number(int, float, complex)、布尔型、字符串(str, bytes)、tuple、None；而可变类型 list、set、dict 都是不可哈希的。</p><p>set 的 hash 寻址是二次散列和顺序寻址结合的,</p><h5 id="set-常用方法"><a href="#set-常用方法" class="headerlink" title="set 常用方法"></a>set 常用方法</h5><ol><li>s.add(elem)： 添加一个元素到 set 中，如果元素存在则什么都不做</li><li>s.remove(elem)： 删除 set 中的一个元素，元素不存则报错 KeyError</li><li>s.pop()： 删除并返回<strong>任意</strong>元素，空集报错 KeyError</li><li>s.clear()： 删除所有元素<br>set 不能修改元素，只能添加和删除元素，时间复杂度平均为 O(1), 最差的情况是 O(n)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;list、dict、set、tuple 是 python 中常用的四种数据结构，在平常的学习中只是简单学习了其使用方式，没有了解底层实现，特此记录和学习一下更深层次的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/tags/Python/"/>
    
      <category term="数据结构" scheme="https://xieyiyu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="dict" scheme="https://xieyiyu.github.io/tags/dict/"/>
    
      <category term="list" scheme="https://xieyiyu.github.io/tags/list/"/>
    
      <category term="set" scheme="https://xieyiyu.github.io/tags/set/"/>
    
      <category term="tuple" scheme="https://xieyiyu.github.io/tags/tuple/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文本处理三剑客</title>
    <link href="https://xieyiyu.github.io/2019/09/23/linux/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <id>https://xieyiyu.github.io/2019/09/23/linux/Linux-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/</id>
    <published>2019-09-23T21:14:39.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>grep、awk、sed 是 linux 中进行文本处理的三大利器，称为 linux 三剑客。grep 适合单纯的文本查找和匹配，awk 适合用于格式化文本，sed 适合编辑匹配的文本。</p><a id="more"></a><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 是 linux 的文本搜索工具，根据用户指定的 “模式”（可以是正则表达式）对目标文件逐步进行匹配检查，并打印匹配到的行。</p><h3 id="grep-格式与参数"><a href="#grep-格式与参数" class="headerlink" title="grep 格式与参数"></a>grep 格式与参数</h3><p>grep [options] pattern [filepath]</p><p>-c ：统计匹配到的行数；<br>-E ：使用扩展的正则表达式<br>-f ：&lt;规则文件&gt; 查找符合指定规则文件的内容，格式为每行一个规则样式；<br>-i ：忽略大小写；<br>-n ：输出行号；<br>-o ：只显示被匹配到的字符串；<br>-v ：反向匹配，也就是输出不匹配的内容，相当于 [^]； </p><p>若希望输出匹配行的前后行 -A -B -C 参数： </p><ul><li>grep 字符串 filepath -A 1 ： 输出除匹配的该行外，还显示其后面一行(After 1)</li><li>grep 字符串 filepath -B 1 ： 输出除匹配的该行外，还显示其前面一行(Before 1)</li><li>grep 字符串 filepath -C 1 ： 输出除匹配的该行外，还显示前一行和后一行</li></ul><h3 id="grep-实例"><a href="#grep-实例" class="headerlink" title="grep 实例"></a>grep 实例</h3><p>1.统计某个文本中 abc 出现的次数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -o <span class="string">'abc'</span> filename | wc -l</span><br><span class="line"><span class="comment"># 不能用 grep -c 这只显示出符合要求的行数，一行多个的话无法判断</span></span><br></pre></td></tr></table></figure><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>awk 是一种编程语言，用于 linux 处理数据和生成报告，更适合文本格式化，对文本进行较复杂的格式处理。 awk 将文件逐行输入，以空格为默认分隔符将每行切片，然后可以对切开的每部分进行分析和处理。</p><h3 id="awk-格式与参数"><a href="#awk-格式与参数" class="headerlink" title="awk 格式与参数"></a>awk 格式与参数</h3><p><code>awk [options] &#39;pattern{action}&#39; filepath</code><br>pattern 表示 awk 在数据中查找的内容，action 是在找到匹配内容时执行的命令</p><p>-F fs ：指定分隔符 fs，fs 可以是字符串或正则表达式，如果有多个分隔符： <code>awk -F &#39;[:,]&#39; filepath</code><br>-f scriptfile ：从脚本文件中读取 awk 命令<br>-v var=value ：赋值一个用户定义变量，将外部变量传递给 awk</p><h3 id="awk-变量"><a href="#awk-变量" class="headerlink" title="awk 变量"></a>awk 变量</h3><h4 id="awk-内建变量"><a href="#awk-内建变量" class="headerlink" title="awk 内建变量"></a>awk 内建变量</h4><ul><li>$0 整行, $1-$n 第n个字段，awk 逐行处理文本，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。 直接 print 或 print $0 就显示整行。</li><li>NF ：浏览记录的域的个数（字段数）； $NF 是最后一列的内容，$(NF-1) 是倒数第二列</li><li>FS ：输入字段分隔符，默认为空白字符</li><li>OFS ：输出字段分隔符，默认为空白字符</li><li>RS ：输入记录分隔符，指定输入时的换行符，原换行符扔有效，比如 RS=’:’，则遇到冒号就换行输出</li><li>ORS ：输出记录分隔符，输出时用指定符号代替换行符</li><li>NR ：已经读出的记录数，即行号，从 1 开始，有多个文件的话值也是不断累加的，用于最后可以输出总共的记录数。</li><li>FNR ：各文件分别计数, 行号，后跟一个文件和 NR 一样，跟多个文件，第二个文件行号从 1 开始</li><li>FILENAME ：当前文件名</li><li>ARGC ：命令行参数的个数</li><li>ARGV ：数组，保存的是命令行所给定的各参数，查看参数</li></ul><p>使用时要加 -v</p><p><strong>实例</strong><br>1.查看最近 5 条登录用户和 ip 地址，第一列是用户名，第三列是 IP </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ last -n 5 | awk <span class="string">'&#123;print $1"\t"$3&#125;'</span></span><br></pre></td></tr></table></figure><p>2.过滤文本，查看 /etc/passwd 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F <span class="string">":"</span> <span class="string">'&#123;print NR, $1, $5, $6&#125;'</span> OFS=<span class="string">"\t"</span> /etc/passwd <span class="comment"># OFS 指定输出格式</span></span><br></pre></td></tr></table></figure><p>3.统计 ip.txt 文件中出现次数最多的 ip， 文本第二个字段是 ip</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ip.txt | awk <span class="string">'NR!=1 &#123;if($2) print $2&#125;'</span> | sort | uniq -c | sort -nr | head -n 1</span><br><span class="line"><span class="comment"># uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用, -c 在每列旁边显示该行重复出现的次数。</span></span><br><span class="line"><span class="comment"># sort -n 是按照数值排序，否则会按字典序； sort -r 是倒序，由大到小排序</span></span><br><span class="line"><span class="comment"># NR!=1 去掉第一行，也就是 title；if($2) 保证非空</span></span><br></pre></td></tr></table></figure><p>4.统计文件中每个单词出现的次数，一行有多个单词，每个单词按照空格分割</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v RS=<span class="string">' '</span> <span class="string">'&#123;if($0) print&#125;'</span>  test1 | grep -v <span class="string">"^$"</span> | sort | uniq -c</span><br><span class="line"><span class="comment"># RS=' ' 按照空格切分，并遇到空格就换行；grep -v "^$" 去掉空白行，这个空白行是由于空格分割导致的</span></span><br></pre></td></tr></table></figure><p>如果每个单词占一行的话：<br><code>cat word.txt | sort | uniq -c</code></p><h4 id="awk-自定义变量"><a href="#awk-自定义变量" class="headerlink" title="awk 自定义变量"></a>awk 自定义变量</h4><p>使用 <code>-v var=value</code> 结构可以自定义变量，可以在 print 前后定义变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk -v name=<span class="string">"myname"</span> <span class="string">'&#123;print name, $NF&#125;'</span> test.txt</span><br><span class="line">$ awk <span class="string">'&#123;name="myname"; print name, $NF&#125;'</span> test.txt <span class="comment"># 直接在编程体中定义</span></span><br></pre></td></tr></table></figure><h3 id="awk-pattern-匹配"><a href="#awk-pattern-匹配" class="headerlink" title="awk pattern 匹配"></a>awk pattern 匹配</h3><ol><li><p>未指定，则匹配每一行</p></li><li><p>/regular expression/ ：仅处理能够模式匹配到的行，正则表达式需要用 <code>/ /</code> 括起来</p></li><li><p>relational expression：关系表达式，结果为“真”才会被处理，即非 0 非空</p></li><li><p>line ranges：行范围<br>startline(起始行), endline(结束行)：/pat1/,/pat2/  不支持直接给出数字，可以有多段，中间可以有间隔</p></li><li><p>BEGIN/END 模式<br><code>awk &#39;BEGIN{BEGIN 操作} {文件行处理块} END{END 操作}&#39; filepath</code></p></li></ol><ul><li>BEGIN 模块是在文件输入前执行的，不输入任何文件数据也会执行该模块，常用于设置修改内置变量如 OFS,RS 等，为用户自定义的变量赋初始值或者打印标题信息等。操作语句以 “;” 或分行隔开。BEGIN 可缺省。  </li><li>END 模块是处理完文件后的操作</li></ul><p><strong>实例</strong><br>1.正则匹配<br>~ 表示模式开始，/pattern/ 中间是模式，用 !~ // 表示模式取反</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'/80/&#123;print $4&#125;'</span> netstat.txt <span class="comment"># 匹配字段中有 80 的</span></span><br><span class="line">$ awk <span class="string">'$4 ~ /^c/&#123;print $4&#125;'</span> netstat.txt <span class="comment"># 第 4 列是以字母 c 开头的</span></span><br><span class="line">$ awk <span class="string">'$4 !~ /^c/&#123;print $4&#125;'</span> netstat.txt <span class="comment"># 第 4 列不是以字母 c 开头的</span></span><br><span class="line">$ awk <span class="string">'$6 ~ /FIN|WAIT/ || NR==1 &#123;print $4,$6&#125;'</span> netstat.txt <span class="comment"># 第 6 列包含 FIN 或 WAIT 的，并显示 titie，对第一行不做处理</span></span><br></pre></td></tr></table></figure><p>2.使用关系表达式<br><code>awk &#39;$0{print}&#39; file</code> 去掉空行 </p><p>3.统计每个用户的进程占了多少内存（计算 RSS 列）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | awk <span class="string">'NR!=1&#123;a[$1]+=$6;&#125; END &#123;for (i in a) print i "," a[i]"KB";&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="awk-高阶用法"><a href="#awk-高阶用法" class="headerlink" title="awk 高阶用法"></a>awk 高阶用法</h3><h4 id="条件语句-if-else"><a href="#条件语句-if-else" class="headerlink" title="条件语句 if-else"></a>条件语句 if-else</h4><p>if(condition){statement;…} else{statement}<br>if(condition1){statement1} else if(condition2){statement2} else{statement3}</p><p>1.使用 awk 拆分文件，可以使用重定向，如按照第 6 列拆分文件 NR!=1 表示不处理表头，文件名即为第 6 列的名字</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;if(NR!=1 &amp;&amp; $6) print &gt; $6&#125;'</span> netstat.txt</span><br></pre></td></tr></table></figure><p>2.复杂一点，可以使用 if-else if 语句，将符合某个条件的行划分到一个文本中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'NR!=1 &amp;&amp; $6 &#123;if($6 ~ /FIN|WAIT/) print &gt; 1.txt; </span></span><br><span class="line"><span class="string">      else if($6 ~ /LISTEN/) print &gt; 2.txt; </span></span><br><span class="line"><span class="string">      else print &gt; 3.txt&#125;'</span> netstat.txt</span><br></pre></td></tr></table></figure><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h5><p>语法 ：while(condition){statement;…}</p><p>使用场景 ：用于对一行内多个字段进行逐一处理，或对数组中的各元素逐一处理</p><p>1.以 : 分割，显示每一行长度大于 3 的单词及其长度</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F : <span class="string">'&#123;i=1; while(i&lt;NF)&#123;if(length($i)&gt;=3)&#123;print $i, length($i)&#125;; i++&#125;&#125;'</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>2.计算 1+2+3+…+100</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'BEGIN&#123;i=1; sum=0; while(i&lt;=100)&#123;sum+=i; i++&#125;; print sum&#125;'</span></span><br></pre></td></tr></table></figure><h5 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h5><p>语法 ：for(expr1; expr2; expr3){statement;…}<br>遍历数组 ：for(var in array){statement;…} </p><p>显示每行每个单词的长度，按照空格分隔</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'&#123;for(i=1;i&lt;=NF;i++)&#123;print $i, length($i)&#125;&#125;'</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>sed 是一种流编辑器（stream editor），一次处理一行内容，是一个文本编辑工具，实现数据的替换，删除，增加，选取等。</p><p>原理：</p><ol><li>sed 将当前处理的行存储在临时缓冲区中，即模式空间(patternspace)</li><li>使用 sed 命令处理缓冲区中的内容</li><li>处理完成后，将缓冲区内容输出到屏幕，然后读下一行进行处理。</li></ol><h3 id="sed-格式和参数"><a href="#sed-格式和参数" class="headerlink" title="sed 格式和参数"></a>sed 格式和参数</h3><p><code>sed [options] &#39;[地址定界]动作&#39; filepath</code></p><p><strong>options：</strong></p><ul><li><code>-e &lt;script&gt;</code> ：直接在命令列模式上进行 sed 的动作编辑，可以用多个 -e ‘actions’ -e ‘actions’</li><li><code>-f &lt;script文件&gt;</code> ：将 sed 动作写在文件内，以指定的 script 来处理输入的文本</li><li>-i ：直接修改读取的文件内容，不输出到终端，也可选择将修改重定向到一个新的文件</li><li>-n ：使用安静模式，一般 sed 会将所有的输入都列出在终端，使用 -n 就只有被匹配处理过的行会显示出来</li><li>-r ：使用扩展的正则表达式</li></ul><p><strong>地址定界：</strong></p><ul><li>无地址 ：全文处理</li><li>单地址 ： <ul><li><code>#</code> ：指定的行</li><li><code>/pattern/</code> ：被此处模式所能够匹配到的每一行</li></ul></li><li>地址范围：<code>#,#</code>   <code>/pat1/,/pat2/</code>     <code>#,/pat1/</code></li><li>步长 ~：<ul><li><code>sed -n &#39;1~2p&#39;</code> ：只打印奇数行 （1~2 从第 1 行，一次加 2 行）</li><li><code>sed -n &#39;2~2p&#39;</code> ：只打印偶数行</li></ul></li></ul><p><strong>动作说明：</strong></p><ul><li>a ：新增，a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</li><li>i ：插入，在当前行之前插入文本。多行时除最后一行外，每行末尾需用”&quot;续行</li><li>d ：删除行</li><li>p ：打印，将某个选择的数据打印，通常和 sed -n 搭配使用</li><li>s ：替换，搭配正则表达式，如 ‘s/old/new/g’</li></ul><h3 id="sed-实例"><a href="#sed-实例" class="headerlink" title="sed 实例"></a>sed 实例</h3><p>1.在每行最前面或最后面添加 #</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/^/#/g'</span> filepath</span><br><span class="line">$ sed <span class="string">'s/$/#/g'</span> filepath</span><br></pre></td></tr></table></figure><p>2.指定需要替换的内容，允许多个匹配，用分号隔开</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'3s/old/new/g'</span> filepath <span class="comment"># 替换第 3 行的</span></span><br><span class="line">$ sed <span class="string">'3,6s/old/new/g'</span> filepath <span class="comment"># 替换第 3-6 行的</span></span><br><span class="line">$ sed <span class="string">'s/old/new/1'</span> filepath <span class="comment"># 替换每行的第一个</span></span><br><span class="line">$ sed <span class="string">'s/old/new/3g; xxx'</span> filepath <span class="comment"># 替换每行的第三个以后的</span></span><br><span class="line">$ sed <span class="string">'1~2s/old/new/g'</span> filepath <span class="comment"># 替换奇数行的 old</span></span><br></pre></td></tr></table></figure><p>3.使用 &amp; 表示被匹配的变量，在周围添加内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'s/my/[&amp;]/g'</span> filepath <span class="comment"># 将所有的 my 变为 [my]</span></span><br></pre></td></tr></table></figure><p>4.删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">'2d'</span> filepath <span class="comment"># 删除第 2 行</span></span><br></pre></td></tr></table></figure><p>5.打印</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">'2!p'</span> filepath <span class="comment"># 打印除了第 2 行的内容</span></span><br><span class="line">$ sed -n <span class="string">'1,3p'</span> filepath <span class="comment"># 打印第 1-3 行</span></span><br><span class="line">$ sed -n <span class="string">'/aaa/p'</span> filepath <span class="comment"># 打印包含 aaa 的行</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/along21/p/10366886.html#auto_id_15" target="_blank" rel="noopener">Linux文本三剑客超详细教程—grep、sed、awk</a><br><a href="https://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">AWK 简明教程</a><br><a href="https://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">SED 简明教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;grep、awk、sed 是 linux 中进行文本处理的三大利器，称为 linux 三剑客。grep 适合单纯的文本查找和匹配，awk 适合用于格式化文本，sed 适合编辑匹配的文本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://xieyiyu.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://xieyiyu.github.io/tags/Linux/"/>
    
      <category term="grep" scheme="https://xieyiyu.github.io/tags/grep/"/>
    
      <category term="awk" scheme="https://xieyiyu.github.io/tags/awk/"/>
    
      <category term="sed" scheme="https://xieyiyu.github.io/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>数据库连接池</title>
    <link href="https://xieyiyu.github.io/2019/09/20/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>https://xieyiyu.github.io/2019/09/20/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</id>
    <published>2019-09-20T18:02:17.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决共享资源的频繁分配、释放的一些问题，有一个著名的设计模式：资源池。 将该模式应用到数据库连接管理领域，就是建立一个数据库连接池。</p><a id="more"></a><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个，这样可以使得一个数据库连接可以得到高效、安全的复用，避免了数据库频繁建立、关闭的开销，极大的节省了系统资源和时间。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>数据库连接池的基本原理是： 在内部对象池中维护一定数量的数据库连接，并对外暴露数据库连接获取和返回方法。一旦数据库连接建立后，不同的数据库访问请求就可以共享复用这些连接。</p><p>外部使用者可以通过 getConnection 方法从连接池中获取数据库连接，使用完毕后通过 releaseConnection 方法将连接返回池子，但此时连接并没有关闭，而是由连接池管理器回收，并为下一次使用做好准备。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>资源重用</li><li>更快的系统响应速度： 数据库连接池在初始化时，就已经创建了若干数据库连接置于池中备用，请求访问可以直接使用。</li><li>新的资源分配手段</li><li>统一的连接管理，避免数据库连接泄漏: 在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。</li></ol><h2 id="python-数据库连接池"><a href="#python-数据库连接池" class="headerlink" title="python 数据库连接池"></a>python 数据库连接池</h2><h3 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h3><p>python 中可以用 pymysql、MySQLdb 等进行数据库连接和增删查改操作，但每次请求连接 mysql 时，都是独立的请求访问，比较浪费资源，当请求达到一定数量时，对 mysql 的性能会产生较大影响，因此在 python 中可以使用数据库连接池包 DBUtils 来访问 mysql，从而达到资源复用的目的。</p><p>DBUtils 提供两种外部接口：</p><ul><li>PersistentDB：用于单线程，提供线程专用的数据库连接，并自动管理连接。</li><li>PooledDB： 用于多线程，提供线程间可共享的数据库连接，并自动管理连接。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> DBUtils.PooledDB <span class="keyword">import</span> PooledDB</span><br><span class="line"><span class="keyword">from</span> DBUtils.PersistentDB <span class="keyword">import</span> PersistentDB</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">'host'</span>: <span class="string">'localhost'</span>,</span><br><span class="line">    <span class="string">'port'</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="string">'database'</span>: <span class="string">'student_course'</span>,</span><br><span class="line">    <span class="string">'user'</span>: <span class="string">'root'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'a123456'</span>,</span><br><span class="line">    <span class="string">'charset'</span>: <span class="string">'utf8'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_db_pool</span><span class="params">(is_mult_thread)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_mult_thread:</span><br><span class="line">        poolDB = PooledDB(</span><br><span class="line">            creator=pymysql, <span class="comment"># 指定数据库连接驱动</span></span><br><span class="line">            maxconnections=<span class="number">3</span>, <span class="comment"># 连接池允许的最大连接数,0 和 None 表示没有限制</span></span><br><span class="line">            mincached=<span class="number">2</span>, <span class="comment"># 初始化时,连接池至少创建的空闲连接,0 表示不创建</span></span><br><span class="line">            maxcached=<span class="number">5</span>, <span class="comment"># 连接池中空闲的最多连接数,0 和 None 表示没有限制</span></span><br><span class="line">            maxshared=<span class="number">3</span>, <span class="comment"># 连接池中最多共享的连接数量,0 和 None 表示全部共享</span></span><br><span class="line">            blocking=<span class="literal">True</span>, <span class="comment"># 连接池中如果没有可用共享连接后,是否阻塞等待,True 表示等待, False 表示不等待然后报错</span></span><br><span class="line">            setsession=[], <span class="comment"># 开始会话前执行的命令列表</span></span><br><span class="line">            ping=<span class="number">0</span>, <span class="comment"># ping Mysql 服务器检查服务是否可用</span></span><br><span class="line">            **config</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        poolDB = PersistentDB(</span><br><span class="line">            creator=pymysql, <span class="comment"># 指定数据库连接驱动</span></span><br><span class="line">            maxusage=<span class="number">1000</span>, <span class="comment"># 一个连接最大复用次数,0 或者 None 表示没有限制,默认为 0</span></span><br><span class="line">            **config</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> poolDB</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    db_pool = get_db_pool(<span class="literal">False</span>) <span class="comment"># 以单线程的方式初始化数据库连接池</span></span><br><span class="line">    conn = db_pool.connection() <span class="comment"># 从数据库连接池中取出一条连接</span></span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(<span class="string">'select * from sc'</span>) <span class="comment"># 执行 sql 语句</span></span><br><span class="line">    result = cursor.fetchall() <span class="comment"># 得到所有结果</span></span><br><span class="line">    print(result)</span><br><span class="line">    conn.close() <span class="comment"># 把连接返还给连接池</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5af026a06fb9a07ac47ff282" target="_blank" rel="noopener">数据库连接池的实现及原理</a><br><a href="https://blog.csdn.net/shuaihj/article/details/14223015" target="_blank" rel="noopener">谈谈数据库连接池的原理</a><br><a href="https://blog.csdn.net/zbc1090549839/article/details/51336458" target="_blank" rel="noopener">Python实现Mysql数据库连接池</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了解决共享资源的频繁分配、释放的一些问题，有一个著名的设计模式：资源池。 将该模式应用到数据库连接管理领域，就是建立一个数据库连接池。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://xieyiyu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://xieyiyu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>自动化测试之Selenium</title>
    <link href="https://xieyiyu.github.io/2019/09/14/test/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8BSelenium/"/>
    <id>https://xieyiyu.github.io/2019/09/14/test/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8BSelenium/</id>
    <published>2019-09-14T16:42:33.000Z</published>
    <updated>2020-01-17T02:24:43.244Z</updated>
    
    <content type="html"><![CDATA[<p>Selenium 是用于 web 应用的自动化测试工具，可以模拟浏览器操作，自动完成 web 基本任务管理。</p><a id="more"></a><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>适合自动化测试的情况：</p><ol><li>项目周期长且相对稳定</li><li>需要做频繁的冒烟测试</li><li>需要经常做回归测试</li><li>需要进行大数据量的数据驱动测试</li></ol><p>不适合自动化测试的情况：</p><ol><li>项目周期短，且用例不会多次重复执行</li><li>被测项目不稳定，变化频繁</li></ol><p>需要关注的指标：</p><ol><li>自动化测试用例的覆盖率</li><li>节省的时间成本 = 手工测试所花时间 - 自动化测试所花时间</li><li>自动化测试的投入</li><li>自动化测试发现的缺陷数</li><li>关键指标是： 自动化测试的投入产出比 ROI = (手工测试的成本 - 自动化测试的成本) / 自动化测试的成本，ROI 为正值且越大说明回报越好</li></ol><h2 id="Selenium-原理"><a href="#Selenium-原理" class="headerlink" title="Selenium 原理"></a>Selenium 原理</h2><p>selenium 的原理涉及到三个部分：</p><ol><li>WebDriver API，即 client，也就是写的代码</li><li>浏览器驱动 driver，也就是下载的 chromedriver.exe</li><li>浏览器</li></ol><h3 id="Selenium-执行流程"><a href="#Selenium-执行流程" class="headerlink" title="Selenium 执行流程"></a>Selenium 执行流程</h3><p>client 并不知道浏览器是如何工作的，可以通过 driver，实现 client 与浏览器之间的通信，client 根据 webdriver 协议发送请求给 driver，driver 解析请求，并在浏览器上执行相应的操作，并把执行结果返回给 client。具体如下：</p><ol><li>对于每一条 Selenium 脚本，一个 HTTP 请求会被创建并且发送给浏览器的驱动</li><li>浏览器驱动中包含了一个 HTTP Server，用来接收这些 HTTP 请求</li><li>HTTP Server 接收到请求后根据请求来具体操控对应的浏览器</li><li>浏览器执行具体的测试步骤</li><li>浏览器将步骤执行结果返回给 HTTP Server</li><li>HTTP Server 又将结果返回给 Selenium 的脚本，如果是错误的 HTTP 代码，控制台会显示相应的报错信息。</li></ol><h3 id="webdriver-协议"><a href="#webdriver-协议" class="headerlink" title="webdriver 协议"></a>webdriver 协议</h3><p>webdriver 基于的协议是 JSON Wire protocol，数据传输使用的是 json，JSON Wire protocol 是在 http 协议基础上，对 http 请求及响应的 body 部分的数据进一步规范。</p><p>在 client 和 server 之间，只要是基于 JSON Wire Protocol 来传递数据，无论 client 使用 java、python 还是其他语言实现，driver 都能处理相应的脚本。</p><h2 id="Selenium-的简单使用"><a href="#Selenium-的简单使用" class="headerlink" title="Selenium 的简单使用"></a>Selenium 的简单使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动浏览器</span></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 打开一个网页</span></span><br><span class="line">driver.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="comment"># 百度搜索 selenium</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(<span class="string">"selenium"</span>)</span><br><span class="line"><span class="comment"># 单击搜索按钮</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line"><span class="comment"># 后退</span></span><br><span class="line">driver.back()</span><br><span class="line"><span class="comment"># 前进</span></span><br><span class="line">driver.forward()</span><br><span class="line"><span class="comment"># 截图</span></span><br><span class="line">driver.save_screenshot(<span class="string">"baidu.png"</span>)</span><br><span class="line"><span class="comment"># 退出浏览器</span></span><br><span class="line">driver.close()</span><br><span class="line"><span class="comment">#关闭浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><ul><li>driver.quit(): 退出并关闭窗口的每一个相关的驱动程序</li><li>driver.close(): 关闭当前窗口</li></ul><h2 id="Python-webdriver-API"><a href="#Python-webdriver-API" class="headerlink" title="Python webdriver API"></a>Python webdriver API</h2><h3 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h3><p>webdriver 提供了一系列的对象定位方法，常用的有：</p><ul><li>find_element_by_id()，唯一</li><li>find_element_by_name()，唯一</li><li>find_element_by_class_name()</li><li>find_element_by_linx_text()， 操作对象是文字超链接</li><li>find_element_by_partial_link_text()，操作对象是文字超链接</li><li>find_element_by_tag_name()， 标签名</li><li>find_element_by_xpath()</li><li>find_element_by_css_selector()</li></ul><p>定位一组对象，用 find_elements，返回的是一个 list，可以用于批量操作对象，如选择复选框</p><ol><li>find_elements_by_tag_name()</li><li>find_element_by_css_selector()</li></ol><p>判断元素是否存在： 需要用元素定位和异常捕获的方法判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    driver.find_element_by_id(<span class="string">"none"</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">"element does not exist"</span>)</span><br></pre></td></tr></table></figure><p>注意： 在 selenium 中不能定位不可见元素，比如 hidden 和 display=none 的元素</p><h3 id="操作测试对象"><a href="#操作测试对象" class="headerlink" title="操作测试对象"></a>操作测试对象</h3><ul><li>clear() ：清除内容</li><li>click() ：鼠标点击</li><li>send_keys() ：向输入框输入</li><li>submit() ：提交表单</li></ul><h3 id="显式等待和隐式等待"><a href="#显式等待和隐式等待" class="headerlink" title="显式等待和隐式等待"></a>显式等待和隐式等待</h3><p>显示等待 WebDriverWait()：是针对某个特定元素设置的等待时间，在设置时间内，默认每隔一段时间检测一次当前页面某个元素是否存在，如果在规定的时间内找到了元素，则直接执行，即找到元素就执行相关操作，如果超过设置时间检测不到则抛出异常。</p><p>隐式等待 implicitly_wait()：是设置了全局等待，设置等待时间，是对页面中的所有元素设置加载时间，如果超出了设置时间的则抛出异常。隐式等待可以理解成在规定的时间范围内，浏览器在不停的刷新页面，直到找到相关元素或者时间结束。</p><p>强制等待 sleep()：也叫线程等待，设置固定休眠时间，执行 sleep() 后线程休眠，上面两种等待不会休眠。</p><h2 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h2><p>appium 是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web应用和混合应用。</p><ol><li>移动原生应用 native：用 iOS 或 Android SDK 写的应用</li><li>移动 web 应用 H5：使用移动浏览器访问的应用</li><li>混合应用：原生代码封装网页视图，原生代码和 web 内容交互</li></ol><p>appium 类库封装了标准 Selenium 客户端类库，实现了 Mobile JSON Wire Protocol</p><p>流程： 使用 python（client）编写一个 appium 自动化脚本并执行，首先会请求 appium-Server（mac 和 win 下不同），appium-Server 通过解析，驱动 Android 虚拟机或真机来执行 appium 脚本。</p><h3 id="元素定位-1"><a href="#元素定位-1" class="headerlink" title="元素定位"></a>元素定位</h3><p>可以使用 uiautomatorviewer 工具来查看控件的属性，定位方式与 selenium 相同，有 id、name、class_name、xpath 等方法。</p><h3 id="native-与-h5-切换"><a href="#native-与-h5-切换" class="headerlink" title="native 与 h5 切换"></a>native 与 h5 切换</h3><p>在混合开发的 app 中，原生应用可以通过 uiautomator 获取控件信息，而 h5 也就是 web 网页是 B/S 架构，两者的运行环境不同，因此需要进行上下文(context) 切换，再对 h5 页面元素进行定位操作。</p><p>切换到 h5，进行 h5 元素定位：</p><ol><li>导航到应用程序中 web 页面</li><li>获取上下文列表 driver.contexts，它返回一个我们可以访问的上下文列表，例如：NATIVE_APP 或 WEBVIEW_xxx</li><li>通过 driver.switch_to.context 切换到你要操作的 webview，原来是在 NATIVE_APP，切换到 WEBVIEW_xxx</li><li>操作完后，返回到原来的 app view</li></ol><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言是一些布尔表达式，当需要在一个值为 False 时中断当前操作的话，可以使用断言。</p><p>断言可以用于单元测试，判断到某个节点位置必须满足某些逻辑条件时才能继续运行下去，不满足程序就会崩溃或报错，这个时候就可以使用断言。</p><h3 id="断言与异常"><a href="#断言与异常" class="headerlink" title="断言与异常"></a>断言与异常</h3><ul><li>断言用于开发测试期间，是给程序员自己使用的；断言触发后程序崩溃退出，不需要从错误中恢复</li><li>异常在程序运行期间触发；异常通常会用 try/except/finally 等结构捕获异常，之后还能从错误中恢复继续运行</li></ul><h3 id="python-常用断言"><a href="#python-常用断言" class="headerlink" title="python 常用断言"></a>python 常用断言</h3><ul><li>assertEqual(a, b [, msg=’xxx’])： 断言 a 和 b 相等，msg 为测试失败时打印的信息； assertNotEqual(a, b)</li><li>assertIs(a, b [, msg=’xxx’]): 断言 a 是 b； assertNotIs(a, b)</li><li>assertIn(a, b [, msg=’xxx’])：断言 a 在 b 中； assertNotIn(a, b)</li><li>assertIsInstance(a, b [, msg=’xxx’])： 断言 a 是 b 的一个实例； assertNotIsInstance(a, b)</li><li>assertTrue(x [, msg=’xxx’])： 断言 x 为 True； assertFalse(x)</li><li>assertIsNone(x [, msg=’xxx’])： 断言 x 是 None； assertIsNotNone(x)</li></ul><h2 id="单元测试-unittest"><a href="#单元测试-unittest" class="headerlink" title="单元测试 unittest"></a>单元测试 unittest</h2><p><a href="#https://huilansame.github.io/huilansame.github.io/archivers/python-unittest">Python必会的单元测试框架 —— unittest</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Selenium 是用于 web 应用的自动化测试工具，可以模拟浏览器操作，自动完成 web 基本任务管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="测试" scheme="https://xieyiyu.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="自动化测试" scheme="https://xieyiyu.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Selenium" scheme="https://xieyiyu.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>死锁的产生和解决方法</title>
    <link href="https://xieyiyu.github.io/2019/09/07/%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://xieyiyu.github.io/2019/09/07/%E6%AD%BB%E9%94%81%E7%9A%84%E4%BA%A7%E7%94%9F%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2019-09-07T22:11:14.000Z</published>
    <updated>2020-01-17T02:24:43.244Z</updated>
    
    <content type="html"><![CDATA[<p>当两个或两个以上的进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，造成死锁。</p><a id="more"></a><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><ol><li>互斥条件： 资源分配是排他性的，每个资源只能同时给一个进程使用</li><li>不可剥夺条件： 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，只能进程自己主动释放</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。</li></ol><h2 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h2><h3 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h3><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略，也就是忽略它。</p><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>死锁的预防是破坏死锁产生的四个必要条件之一，属于静态策略。</p><ol><li><p>互斥条件，是资源本身特点，不可避免</p></li><li><p>破坏不可剥夺条件： 采用 <strong>可剥夺资源</strong>，允许进程强行从占有者那里夺取某些资源。缺点是可能降低系统性能。、</p></li><li><p>破坏请求和保持条件： 采用 <strong>资源一次性分配</strong> ，所有进程在开始执行前请求所需要的全部资源。比如数据库中的<strong>一次封锁法</strong>。 缺点是进程执行是动态的，不可预测；资源利用率低；降低进程的并发性</p></li><li><p>破坏循环等待条件： 采用 <strong>资源有序分配</strong>，系统给进程编号，按某一顺序申请资源，释放资源则反序释放。 比如数据库中的<strong>顺序封锁法</strong>。 缺点是增加了系统的开销</p></li></ol><ul><li>一次封锁法：要求每个事务在开始执行时必须把需要访问的数据项全部加锁。</li><li>顺序封锁法：对数据库中的事务访问的所有数据项规定一个加锁顺序，每个事务在执行过程中必须按此顺序对所需的数据项加锁。</li></ul><h3 id="死锁避免（动态策略）"><a href="#死锁避免（动态策略）" class="headerlink" title="死锁避免（动态策略）"></a>死锁避免（动态策略）</h3><p>在进程在每次申请资源时，对其操作进行动态检查，根据检查结果决定是否分配资源，若在资源分配过程中预测有发生死锁的可能，则进行死锁的避免。关键是确定资源分配的安全性。</p><h4 id="1-安全状态"><a href="#1-安全状态" class="headerlink" title="1. 安全状态"></a>1. 安全状态</h4><p>系统中的所有进程按照某一调度次序分配资源，并且进程能够依次运行完毕，那这种进程序列 {P1，P2，…，Pn} 是一个安全序列，此时系统处于安全状态，这种情况不会发生死锁。如果发生死锁，那么系统一定处于不安全状态。</p><p>在安全序列中，系统当前可用资源 + 前一个进程 P[i] 所释放的资源能够 &gt;= P[i+1] 还需要的资源</p><p>系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配后系统处于安全状态，则将资源分配给进程；否则，令进程等待。</p><h4 id="2-银行家算法"><a href="#2-银行家算法" class="headerlink" title="2. 银行家算法"></a>2. 银行家算法</h4><p>银行家算法是一种避免死锁的算法，实质是设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。</p><h5 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h5><p>问题描述：<br>一个银行家拥有一定数量的资金，有若干个客户要贷款。每个客户须在一开始就声明他所需贷款的总额。若该客户贷款总额不超过银行家的资金总数，银行家可以接收客户的要求。客户在借满所需的全部单位款额之前可能会等待，但银行家须保证这种等待是有限的，可完成的。</p><p>银行家算法是从当前状态出发，逐个按安全序列检查各客户谁能完成其工作，然后假定其完成工作且归还全部贷款，再进而检查下一个能完成工作的客户，也就是说是算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p>缺点：</p><ol><li>要求客户数保持固定不变，这在多道程序系统中难以做到   </li><li>要保证所有客户在有限的时间内得到满足，但实时客户要求快速响应，可能难以快速响应  </li><li>寻找一个安全序列会增加系统的开销</li></ol><h5 id="多个资源的银行家算法"><a href="#多个资源的银行家算法" class="headerlink" title="多个资源的银行家算法"></a>多个资源的银行家算法</h5><p>n 个进程 m 个资源。</p><p>检查一个状态是否安全的算法如下：</p><ol><li>查找需求矩阵中是否存在一行小于等于剩余可用资源。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到可用资源中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。如果一个状态不是安全的，需要拒绝进入这个状态。</li></ol><h3 id="死锁的检测与恢复"><a href="#死锁的检测与恢复" class="headerlink" title="死锁的检测与恢复"></a>死锁的检测与恢复</h3><p>由于操作系统有并发、共享及随机性等特点，通过死锁预防和死锁避免需要较大的系统开销，且不能充分利用资源，因此这样难以达到排除死锁的目的。</p><p>死锁的检测：建立资源分配表和进程等待表。</p><p>死锁的恢复：从其他进程强制剥夺资源给死锁进程；可以直接撤销死锁进程，或撤销代价最小的进程；回退策略。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/abigale1011/article/details/6450845" target="_blank" rel="noopener">什么是死锁及死锁的必要条件和解决方法</a><br><a href="https://blog.csdn.net/qq_28602957/article/details/53508447" target="_blank" rel="noopener">【操作系统】处理死锁的方法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当两个或两个以上的进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，造成死锁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://xieyiyu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="死锁" scheme="https://xieyiyu.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="银行家算法" scheme="https://xieyiyu.github.io/tags/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux 正则表达式</title>
    <link href="https://xieyiyu.github.io/2019/09/05/linux/Linux-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://xieyiyu.github.io/2019/09/05/linux/Linux-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2019-09-05T10:14:50.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>在 linux 中，常用的正则表达式引擎有：</p><ul><li>POSIX 基本正则表达式（BRE）引擎，grep 使用</li><li>POSIX 扩展正则表达式（ERE）引擎，grep -E 使用</li></ul><a id="more"></a><h2 id="linux-正则表达式的元字符"><a href="#linux-正则表达式的元字符" class="headerlink" title="linux 正则表达式的元字符"></a>linux 正则表达式的元字符</h2><blockquote><p><code>. * [ ] ^ $ { } + ? | ( )</code></p></blockquote><h3 id="BRE-和-ERE-通用元字符"><a href="#BRE-和-ERE-通用元字符" class="headerlink" title="BRE 和 ERE 通用元字符"></a>BRE 和 ERE 通用元字符</h3><p><code>\</code> : 转义，将元字符当做普通字符，如 <code>\(...\)与\{...\}</code></p><p><code>.</code> : 匹配任意单个字符（除 NULL）</p><p><code>*</code> : 匹配前一个字符 0 次或多次，如 <code>.*</code> 匹配任意字符的任意长度</p><p><code>^</code> : 开头定位，匹配以后面字符开头的行</p><p><code>$</code> : 结尾定位，匹配以前面字符结尾的行</p><p><code>[]</code> : 匹配方括号内的任意字符，其中可用连字符（-）指的连续字符的范围； 可以用 <code>^</code> 符号表示匹配不在列表中的任一字符，匹配数字 <code>[0-9]</code>，匹配非数字 <code>[^0-9]</code>。</p><h3 id="BRE-特有元字符"><a href="#BRE-特有元字符" class="headerlink" title="BRE 特有元字符"></a>BRE 特有元字符</h3><p><code>\{n, m\}</code> : 区间表达式，匹配前面一个字符 n 到 m 次，<code>\{n\}</code> 匹配 n 次</p><h3 id="ERE-特有元字符"><a href="#ERE-特有元字符" class="headerlink" title="ERE 特有元字符"></a>ERE 特有元字符</h3><p>相比于 BRE，使用 ERE 更加方便，建议以后使用 grep -E 来进行正则匹配<br><code>{n, m}</code> ： 区间表达式，匹配前面一个字符 n 到 m 次，<code>{n}</code> 匹配 n 次， <code>{n,}</code> 匹配 n 次以上</p><p><code>+</code> : 匹配前一个字符 0 次或多次</p><p><code>?</code> : 匹配前一个字符 0 次或 1 次</p><p><code>|</code> : 表示 “或” ，实现多个正则表达式的匹配，匹配其中之一</p><p><code>()</code> : 匹配括号括起来的正则表达式群</p><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul><li>[[:alnum:]] 所有字母与数字； [[:alpha:]] 所有字母； [[:digit:]] 所有数字  </li><li>[[:blank:]] 所有水平空格； [[:space:]] 所有水平与垂直空格符； [[:punct:]] 所有标点符号  </li><li>[[:graph:]] 所有可打印字符（不包含空格）； [[:print:]] 所有可打印字符(包含空格)  </li><li>[[:upper:]] 所有大写字母； [[:lower:]] 所有小写字母</li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 会在文本文件中查找一个指定的正则表达式，并把匹配行输出到标准输出。</p><p><code>grep [options] regex [file...]</code> 其中 regex 即正则表达式</p><h3 id="grep-参数"><a href="#grep-参数" class="headerlink" title="grep 参数"></a>grep 参数</h3><p>-c 显示符合要求的行的个数；<br>-i 忽略大小写；<br>-n 输出行号；<br>-v 反向输出，也就是不匹配的内容；<br>-o 只显示被匹配到的字符串；<br>-f &lt;规则文件&gt; 查找符合指定规则文件的内容，格式为每行一个规则样式<br>-E 使用扩展正则表达式进行匹配</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol><li><p>匹配空行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'^$'</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li><li><p>查找文件 test 中有三个数字连在一起的行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -n -E <span class="string">'[0-9][0-9][0-9]'</span> <span class="built_in">test</span> <span class="comment"># -n 显示行号，-E 可以省略，grep 查找可以省略 ''</span></span><br><span class="line">grep -n -E <span class="string">'[0-9]&#123;3&#125;'</span> <span class="built_in">test</span> <span class="comment"># 不能省略 -E，需要用扩展的正则</span></span><br><span class="line">grep -n -E <span class="string">'[[:digit:]]&#123;3&#125;'</span> test2 <span class="comment"># 用字符集</span></span><br></pre></td></tr></table></figure></li><li><p>查找 good 或 glad</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">'g(oo|la)d'</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 linux 中，常用的正则表达式引擎有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;POSIX 基本正则表达式（BRE）引擎，grep 使用&lt;/li&gt;
&lt;li&gt;POSIX 扩展正则表达式（ERE）引擎，grep -E 使用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://xieyiyu.github.io/categories/Linux/"/>
    
    
      <category term="正则表达式" scheme="https://xieyiyu.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="Linux" scheme="https://xieyiyu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 多线程爬虫</title>
    <link href="https://xieyiyu.github.io/2019/08/31/python/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB/"/>
    <id>https://xieyiyu.github.io/2019/08/31/python/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB/</id>
    <published>2019-08-31T14:33:17.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>爬虫主要运行时间消耗是请求网页时的 IO 阻塞，使用多线程能够让不同请求的等待同时进行，从而提高爬虫运行效率。</p><a id="more"></a><p>基于多线程（这里开启了10个线程），使用 github 的 api，抓取 fork cpython 项目的信息，并将数据存储到 json 文件中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计时用的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func(*args, **kw)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">'running'</span>, end-start, <span class="string">'s'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.qurl = Queue()</span><br><span class="line">        self.data = list()</span><br><span class="line">        self.email = <span class="string">'xxx'</span> <span class="comment"># 登录github用的邮箱</span></span><br><span class="line">        self.password = <span class="string">'xxx'</span> <span class="comment"># 登录github用的密码</span></span><br><span class="line">        self.page_num = <span class="number">120</span></span><br><span class="line">        self.thread_num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">produce_url</span><span class="params">(self)</span>:</span></span><br><span class="line">        baseurl = <span class="string">'https://api.github.com/repos/python/cpython/forks?page=&#123;&#125;'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, self.page_num + <span class="number">1</span>):</span><br><span class="line">            url = baseurl.format(i)</span><br><span class="line">            self.qurl.put(url) <span class="comment"># 生成URL存入队列，等待其他线程提取</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_info</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.qurl.empty(): <span class="comment"># 保证url遍历结束后能退出线程</span></span><br><span class="line">            url = self.qurl.get() <span class="comment"># 从队列中获取URL</span></span><br><span class="line">            print(<span class="string">'crawling'</span>, url)</span><br><span class="line">            req = requests.get(url, auth = (self.email, self.password))</span><br><span class="line">            data = req.json()</span><br><span class="line">            <span class="keyword">for</span> datai <span class="keyword">in</span> data:</span><br><span class="line">                result = &#123;</span><br><span class="line">                    <span class="string">'project_name'</span>: datai[<span class="string">'full_name'</span>],</span><br><span class="line">                    <span class="string">'project_url'</span>: datai[<span class="string">'html_url'</span>],</span><br><span class="line">                    <span class="string">'project_api_url'</span>: datai[<span class="string">'url'</span>],</span><br><span class="line">                    <span class="string">'star_count'</span>: datai[<span class="string">'stargazers_count'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                self.data.append(result)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @run_time</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.produce_url()</span><br><span class="line"></span><br><span class="line">        ths = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.thread_num):</span><br><span class="line">            th = Thread(target=self.get_info)</span><br><span class="line">            th.start()</span><br><span class="line">            ths.append(th)</span><br><span class="line">        <span class="keyword">for</span> th <span class="keyword">in</span> ths:</span><br><span class="line">            th.join()</span><br><span class="line"></span><br><span class="line">        s = json.dumps(self.data, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'github_thread.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(s)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'Data crawling is finished.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Spider().run()</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://juejin.im/post/5b0951ab51882538ac1ce3c8" target="_blank" rel="noopener">https://juejin.im/post/5b0951ab51882538ac1ce3c8</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;爬虫主要运行时间消耗是请求网页时的 IO 阻塞，使用多线程能够让不同请求的等待同时进行，从而提高爬虫运行效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/tags/Python/"/>
    
      <category term="多线程" scheme="https://xieyiyu.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="爬虫" scheme="https://xieyiyu.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python 协程</title>
    <link href="https://xieyiyu.github.io/2019/08/25/python/Python-%E5%8D%8F%E7%A8%8B/"/>
    <id>https://xieyiyu.github.io/2019/08/25/python/Python-%E5%8D%8F%E7%A8%8B/</id>
    <published>2019-08-25T10:40:02.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>协程 Coroutine，也叫微线程，是一种比线程更加轻量级的存在，一个线程可以有多个协程。</p><a id="more"></a><h2 id="协程概述"><a href="#协程概述" class="headerlink" title="协程概述"></a>协程概述</h2><p>协程的执行过程中在子程序内部可以中断，转而执行其他子程序（不是调用），在适当的时候再返回来执行。  </p><p><strong>特点</strong> ：只有一个线程执行。  </p><p><strong>优势</strong></p><ol><li>执行效率高，由于子程序切换不是由线程，而是由程序自身控制，因此没有线程切换的消耗</li><li>不需要多线程的锁机制，由于只有一个线程，不存在同时写变量冲突，协程中控制共享资源不加锁。  </li></ol><ul><li>线程由操作系统控制</li><li>协程由程序自身控制</li></ul><h2 id="python-实现协程"><a href="#python-实现协程" class="headerlink" title="python 实现协程"></a>python 实现协程</h2><p>python 中实现协程大概经过三个阶段</p><ol><li>最初的生成器变形 yield/send </li><li>在 python3.4 中引入 @asyncio.coroutine 和 yield from </li><li>在 python3.5 中引入 async/await 关键字</li></ol><h3 id="yield-send"><a href="#yield-send" class="headerlink" title="yield/send"></a>yield/send</h3><p>python 生成器的 yield 可以在一定程度上实现协程。</p><p>传统的生产者/消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但容易造成死锁。</p><p>使用协程，在生产者生产消息后，直接通过 yield 跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 等待接收数据</span></span><br><span class="line">        num = <span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">'consuming '</span>, num)</span><br><span class="line"></span><br><span class="line">consumer = consume()</span><br><span class="line">next(consumer) <span class="comment"># 得先 next 才能 send，否则会报错，也可以用 consumer.send(None)</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    print(<span class="string">'start producting '</span>, n)</span><br><span class="line">    consumer.send(n)</span><br></pre></td></tr></table></figure><p>主线程中创建了一个 consumer 协程，并在主线程中产生数据，协程中消费数据，输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start producting  0</span><br><span class="line">consuming  0</span><br><span class="line">start producting  1</span><br><span class="line">consuming  1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="asyncio-yield-from"><a href="#asyncio-yield-from" class="headerlink" title="asyncio/yield from"></a>asyncio/yield from</h3><p>先来看 yield 和 yield from 的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> range(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1 = generator1()</span><br><span class="line">g2 = generator2()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> g1:</span><br><span class="line">    print(x)</span><br><span class="line"><span class="comment"># range(0, 5)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> g2:</span><br><span class="line">    print(x)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>range(5) 是一个可迭代对象，yield 和 yield from 后边接可迭代对象时，yield 是 直接 yield 的是可迭代对象，而 yield from 是将可迭代对象中的元素一个一个yield出来。</p><p>asyncio 是一个基于事件循环的实现异步 IO 的模块，使用 @asyncio.coroutine 可以把一个 generator 标记为 coroutine 类型，然后在 coroutine 内部用 yield from 调用另一个 coroutine 实现异步操作。</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>在 python 3.5 以后， async/await 成为了实现协程更好的替代方案。<br>async/await 让协程表面上独立于生成器存在，将细节都隐藏于 asyncio 模块下，语法更清晰明了。</p><p>在一个普通函数前加 async 关键字，可以将其变成协程。注意，async 无法将一个生成器转化为协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio, random</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">my_coroutine</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> len(alist) &gt; <span class="number">0</span>:</span><br><span class="line">        c = random.randint(<span class="number">0</span>, len(alist)<span class="number">-1</span>)</span><br><span class="line">        print(alist.pop(c))</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    loop = asyncio.get_event_loop() <span class="comment">#运行协程用事件循环，可以看到交替执行的结果</span></span><br><span class="line">    strs = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">    ints = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    c1 = my_coroutine(strs)</span><br><span class="line">    c2 = my_coroutine(ints)</span><br><span class="line">    tasks = [c1, c2]</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    print(<span class="string">'All task finished.'</span>)</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">a</span><br><span class="line">3</span><br><span class="line">c</span><br><span class="line">2</span><br><span class="line">b</span><br><span class="line">All task finished.</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/soonfly/article/details/78361819" target="_blank" rel="noopener">理解Python协程:从yield/send到yield from再到async/await</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;协程 Coroutine，也叫微线程，是一种比线程更加轻量级的存在，一个线程可以有多个协程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/tags/Python/"/>
    
      <category term="协程" scheme="https://xieyiyu.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python 迭代器与生成器</title>
    <link href="https://xieyiyu.github.io/2019/08/23/python/Python-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://xieyiyu.github.io/2019/08/23/python/Python-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2019-08-23T13:06:43.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>在 python 中，生成器 generator 可以实现一遍循环一遍计算，是一种惰性计算，也就是在真正需要的时候才计算结果，这样可以节省空间，避免不必要的计算，从而提升性能。</p><a id="more"></a><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可迭代对象 Iterable： 能够直接作用于 for 循环的对象，如 list、tuple、dict、set、str、file、generator<br>迭代器 Iterator： 可以被 next() 函数调用并不断返回下一个值的对象</p><p>生成器是 Iterator 对象，但 list、 dict、 str 虽然都是 Iterable，但不是 Iterator， 可以用 iter() 方法将其变成 Iterable 类型。</p><p>Python 的 Iterator 对象表示的是一个数据流，Iterator 对象可以被 next() 函数调用并不断返回下一个数据，直到没有数据时抛出 StopIteration 错误。可以把这个数据流看做是一个有序序列甚至是无限大的数据流，只能不断通过 next() 函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p><h3 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h3><p>如果一个容器类提供了 <code>__iter__()</code> 方法，并且该方法能返回一个能够逐个访问容器内所有元素的迭代器，则我们说该容器类实现了迭代器协议。</p><p>for 循环的本质是不断调用 next()。</p><p>Python 处理 for 循环时，首先会调用内建函数 iter(something)，它实际上会调用 <code>something.__iter__()</code>，返回 something 对应的迭代器。而后，for 循环会调用内建函数 next()，作用在迭代器上，获取迭代器的下一个元素，并赋值给 x。此后，Python 才开始执行循环体。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>迭代器是一个更加抽象的概念，生成器是一个迭代器对象，是创建迭代器的简单而强大的工具。</p><p>python 中提供两种方式来构造生成器： 生成器表达式和生成器函数。</p><h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>将列表的 [] 改为 ()，就是一个生成器表达式，生成器需要通过调用 next(g) 来获得其下一个返回值，直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">print(l) <span class="comment"># [0, 1, 4, 9, 16]，使用列表推导，会一次产生所有结果</span></span><br><span class="line"></span><br><span class="line">g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">print(g) <span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x000002590811D830&gt;</span></span><br><span class="line">print(next(g)) <span class="comment"># 0</span></span><br><span class="line">print(next(g)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>实际上我们在用生成器时，并不会去调用 next()，因为生成器实现了迭代器协议，是一个可迭代对象，因此可以通过 for 循环来迭代，不用考虑 StopIteration 的异常。如果生成器推导较复杂，则可以通过生成器函数来完成。</p><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><p>带有 yield 关键词的函数是一个生成器函数，可以用于迭代。 yield 类似于 return，迭代一次遇到 yield 就返回 yield 后面的值，并记住这个返回位置，下一次迭代就从遇到 yield 的下一行开始执行。注意，<strong>每次从暂停恢复时，生成器函数的内部变量、指令指针、内部求值栈等内容和暂停时完全一致。</strong></p><p>与普通函数不同，生成器函数被调用后，其函数体内的代码不会立即执行，而是返回一个生成器。当生成器调用成员方法时，相应生成器函数中的代码才会执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> i ** <span class="number">2</span></span><br><span class="line">g = my_generator() <span class="comment"># &lt;class 'generator'&gt;</span></span><br><span class="line"><span class="comment"># for x in g:</span></span><br><span class="line"><span class="comment">#     print(x) # 0,1,4,9</span></span><br><span class="line">print(next(g)) <span class="comment"># 0</span></span><br><span class="line">print(g.__next__()) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h3 id="generator-send-value"><a href="#generator-send-value" class="headerlink" title="generator.send(value)"></a>generator.send(value)</h3><p>generator.send(value) 方法可以将上一次被挂起的 yield 表达式的值设置为 value，也就可以与生成器函数进行通信，这是使用 yield 在 python 中使用协程的基础。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        y = <span class="keyword">yield</span> i ** <span class="number">2</span></span><br><span class="line">        print(y)</span><br><span class="line">g = my_generator() <span class="comment"># &lt;class 'generator'&gt;</span></span><br><span class="line">print(next(g)) <span class="comment"># 0</span></span><br><span class="line">print(g.send(<span class="number">30</span>)) <span class="comment"># 先是 y = 30，再 print(30)，接着再继续 for 循环， i == 1，yield 会返回 1，因此打印 1</span></span><br><span class="line">print(next(g)) <span class="comment"># 因为会从上一次 yield 的下一行开始执行，也就是 print(y)，但是这时候 y 并没有值，因此会打印 None，接着再继续 for 循环，i == 2</span></span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">30</span><br><span class="line">1</span><br><span class="line">None</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>注意： 在一个生成器对象没有执行 next 之前，由于没有 yield 被挂起，那么此时如果执行 send 会报错。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://liam.page/2017/06/30/understanding-yield-in-python/" target="_blank" rel="noopener">Python 中的黑暗角落（一）：理解 yield 关键字</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 python 中，生成器 generator 可以实现一遍循环一遍计算，是一种惰性计算，也就是在真正需要的时候才计算结果，这样可以节省空间，避免不必要的计算，从而提升性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 装饰器</title>
    <link href="https://xieyiyu.github.io/2019/08/19/python/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://xieyiyu.github.io/2019/08/19/python/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/</id>
    <published>2019-08-19T12:37:02.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>python 中的函数与 java、c++ 中不同之处在于： python 中的函数可以作为变量当做参数传入另一个函数中。装饰器 Decorator 本质上就是一个 python 函数，可以让其他函数在不需要任何代码变动的前提下增加额外功能。  </p><a id="more"></a><p>有了装饰器，就可以抽离出大量与函数本身功能无关的雷同代码到装饰器中并继续重用，也就是能够给函数增加额外的功能。装饰器的返回值是一个函数对象。</p><p>常用场景：插入日志、性能测试、事务处理、缓存、权限校验等。 </p><p>首先来看一个简单的例子： 如果有两个函数 foo1 和 foo2 都要实现在进入函数主体前，先处理日志的功能，那么我们可能会新定义一个函数 use_logging 来专门处理，这样 foo1 和 foo2 就只需要调用 use_logging，其他函数有需要也可以重用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    logging.warning(<span class="string">"%s is running"</span> % func.__name__) <span class="comment"># logging 的默认设置 warn 会输出，info 不会</span></span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo1'</span>)</span><br><span class="line"></span><br><span class="line">use_logging(foo1)</span><br><span class="line"><span class="comment"># WARNING:root:foo1 is running</span></span><br><span class="line"><span class="comment"># i am foo1</span></span><br></pre></td></tr></table></figure><p>这样看起来达到了我们的目的，实现了函数运行前先处理日志的功能，但是每次我们调用的是 use_logging 函数，而真正的业务逻辑是在 foo1 中，这样破坏了原有的代码结果，我们希望是能够直接调用 foo1 函数，这就可以用到装饰器来实现。</p><h3 id="简单的装饰器"><a href="#简单的装饰器" class="headerlink" title="简单的装饰器"></a>简单的装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        logging.warning(<span class="string">"%s is running"</span> % fun.__name__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'i am foo1'</span>)</span><br><span class="line"></span><br><span class="line">f = use_logging(foo1) <span class="comment"># use_logging 是一个装饰器，返回的是 wrapper，这里相当于是 f=wrapper</span></span><br><span class="line">f() <span class="comment"># 也就是执行 wrapper()，然后返回 func()，就是执行 foo1()</span></span><br></pre></td></tr></table></figure><p>在这里 use_logging 装饰器把执行真正业务逻辑的函数 func 包裹在里面，也就是 foo1 被 use_logging 所装饰。 在这个例子中，函数进入和退出时 ，被称为一个横切面，这种编程方式被称为面向切面的编程。</p><h3 id="使用语法糖"><a href="#使用语法糖" class="headerlink" title="使用语法糖 @"></a>使用语法糖 @</h3><p>语法糖： 指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p><p>@ 符号是装饰器的语法糖，放在函数定义之前，这样就不需要赋值，直接调用 foo1() 即可，这样 foo1() 不需要做任何修改，就可以增加额外的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@use_logging</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'i am foo1'</span>)</span><br><span class="line">foo1()</span><br></pre></td></tr></table></figure><h3 id="args、-kwargs"><a href="#args、-kwargs" class="headerlink" title="*args、 **kwargs"></a>*args、 **kwargs</h3><p>如果业务逻辑函数 foo1 需要带参数，就可以给装饰器里的 wrapper 带上同样的参数，但可能有多个带有不同参数的函数需要使用装饰器 use_logging 的话，就可以使用 <code>*args，**kwargs</code> 来定义，这样不管 foo1 带有多少个参数，都可以完整的传到 func 中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line"><span class="keyword">return</span> func(*args, **kwargs) <span class="comment"># 可以让其用于任何函数，无论参数形式如何</span></span><br><span class="line"><span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>在上面的装饰器中，我们只给装饰器传入了一个参数，也就是要执行的业务逻辑函数 func，但如果我们在调用装饰器时，想要加上其他参数，比如可以给日志定义级别，因为不同业务逻辑需要的日志级别可能不同，这时我们就可以给装饰器加上参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">'warn'</span>:</span><br><span class="line">                logging.warning(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">elif</span> level == <span class="string">'error'</span>:</span><br><span class="line">                logging.error(<span class="string">"%s has error"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(level="warn")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(name, msg)</span>:</span></span><br><span class="line">    print(<span class="string">'i am %s, %s'</span> %(name, msg))</span><br><span class="line"></span><br><span class="line">foo1(<span class="string">'foo1'</span>, <span class="string">'hello!'</span>)</span><br></pre></td></tr></table></figure><p>这个带参数的装饰器实际上只是在原有装饰器的基础上再套上一层，是对原有装饰器的一个函数封装，并返回一个装饰器。</p><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>相比于函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。</p><p>类装饰器使用类的 <code>__call__</code> 方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'class decorator runing'</span>)</span><br><span class="line">        self._func()</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'class decorator ending'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Decor</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><h3 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h3><p>使用装饰器会使得原函数的一些元信息消失，比如 <code>__name__</code>, <code>__doc__</code> 会被装饰器的替代。比如之前的装饰器在最后打印 <code>print(foo1.__name__)</code>，得到的是 wrapper，而不是 foo1.</p><p>可以使用 functools.wraps 来进行装饰器修复，wraps 本身是一个装饰器，能够把原函数的元信息拷贝到装饰器里的 func 函数中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps <span class="comment"># 导入模块</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func) # 使用 wraps，记得要传入 func</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(level="warn")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(name, msg)</span>:</span></span><br><span class="line">    print(<span class="string">'i am %s, %s'</span> %(name, msg))</span><br><span class="line"></span><br><span class="line">foo1(<span class="string">'foo1'</span>, <span class="string">'hello!'</span>)</span><br><span class="line">print(foo1.__name__) <span class="comment"># foo1, 如果不加 @wraps(func)，打印出的是 wrapper</span></span><br></pre></td></tr></table></figure><h3 id="装饰器执行顺序"><a href="#装饰器执行顺序" class="headerlink" title="装饰器执行顺序"></a>装饰器执行顺序</h3><p>一个函数可以定义多个装饰器，执行顺序是从里到外，先调用最靠近函数的装饰器，下面的装饰器执行顺序为 c、b、a，也就是 foo = a(b(c(foo)))</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a</span></span><br><span class="line"><span class="meta">@b</span></span><br><span class="line"><span class="meta">@c</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="常用内置装饰器"><a href="#常用内置装饰器" class="headerlink" title="常用内置装饰器"></a>常用内置装饰器</h3><ol><li>@staticmethod</li><li>@classmethod</li><li>@property<br>可以把类中的一个方法当做属性使用，调用时就只要 a.func, 而不用 a.func()。<br>被修饰的特性方法，内部可以实现处理逻辑，但对外提供统一的调用方式，遵循了统一访问的原则。</li></ol><p>在给一个类的属性比如分数 score 初始化时，为了限制它的范围，我们可以给它加上 set_score()、 get_score() 方法，然后在调用时通过 s.get_score(60) 来设置大小，get_score() 来获取值，但是这样调用又略显复杂，没有直接用属性那么简单。python 的 @property 装饰器就可以把方法变成一个属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">60</span> <span class="comment"># 相当于是 s.get_score(60)</span></span><br><span class="line">s.score = <span class="string">'a'</span> <span class="comment"># ValueError: score must be an integer!</span></span><br><span class="line">s.score = <span class="number">101</span> <span class="comment"># ValueError: score must be an integer!</span></span><br></pre></td></tr></table></figure><p>@property 本身创建了一个装饰器 @score.setter，负责把一个 setter 方法变成属性赋值，实际上就相当于之前自己定义的 set_score(); 当然也有一个 @score.getter 装饰器用来获取属性值。</p><ol start="4"><li>functools.wraps<br>用在装饰器的代码里。可以把原始函数的<code>__name__</code>等属性复制到 wrapper() 函数中，这样就可以获取到真实函数的<code>__name__</code>属性，而不是 wrapper。</li></ol><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包就是能够读取其他函数内部变量的函数，可以理解为定义在一个函数内部的函数，外部的叫外函数，内部的叫内函数。</p><p>在一个外函数中定义了一个内函数，内函数用到了外函数的临时变量，外函数的返回值是内函数的引用，这就构成了闭包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(a)</span>:</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(x)</span>:</span></span><br><span class="line">print(a * x + b) <span class="comment"># a,b 是 outer 的临时变量</span></span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">demo = outer(<span class="number">1</span>)</span><br><span class="line">demo(<span class="number">2</span>) <span class="comment"># 输出 1*2+10 = 12</span></span><br></pre></td></tr></table></figure><p>若要在内函数中修改闭包变量（外函数绑定给内函数的局部变量）：</p><ol><li>在 python3 中，用 nonlocal 关键字申明变量，表示这个变量不是局部变量空间的，需要向上一层变量空间中寻找该变量</li><li>在 python2 中，没有 nonlocal 关键字，但可以把闭包变量改为可变类型数据进行修改，如 set、list、dict</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(a)</span>:</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = [a]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">nonlocal</span> b</span><br><span class="line">b += <span class="number">1</span> <span class="comment"># 方法1</span></span><br><span class="line">c[<span class="number">0</span>] += <span class="number">1</span> <span class="comment"># 方法2</span></span><br><span class="line">print(b, c[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">demo = outer(<span class="number">1</span>)</span><br><span class="line">demo() <span class="comment"># 输出 11, 2</span></span><br></pre></td></tr></table></figure><p>在使用闭包的过程中，一旦外函数被调用一次返回了内函数的引用，虽然每次调用内函数，是开启一个函数执行过后消亡，但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(b)</span>:</span></span><br><span class="line"><span class="keyword">nonlocal</span> a</span><br><span class="line">a += b</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">demo = outer(<span class="number">1</span>)</span><br><span class="line">demo(<span class="number">2</span>) <span class="comment"># 输出 1+2=3</span></span><br><span class="line">demo(<span class="number">3</span>) <span class="comment"># 输出 3+3=6</span></span><br></pre></td></tr></table></figure><h3 id="装饰器实战"><a href="#装饰器实战" class="headerlink" title="装饰器实战"></a>装饰器实战</h3><h4 id="装饰器为访问页面添加登录验证功能"><a href="#装饰器为访问页面添加登录验证功能" class="headerlink" title="装饰器为访问页面添加登录验证功能"></a>装饰器为访问页面添加登录验证功能</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义用户字典</span></span><br><span class="line">users = &#123;<span class="string">'xieyiyu'</span>: <span class="string">'123456'</span>,</span><br><span class="line">         <span class="string">'lily'</span>: <span class="string">'123'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化当前用户名，无用户名，登录状态为 False</span></span><br><span class="line">current_user = &#123;<span class="string">'username'</span>: <span class="literal">None</span>, <span class="string">'login'</span>: <span class="literal">False</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth_deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 若已经登录，执行基本函数</span></span><br><span class="line">        <span class="keyword">if</span> current_user[<span class="string">'username'</span>] <span class="keyword">and</span> current_user[<span class="string">'login'</span>]:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 若未登录，提示用户输入用户名和密码</span></span><br><span class="line">        username = input(<span class="string">'请输入用户名：'</span>).strip()</span><br><span class="line">        passwd = input(<span class="string">'请输入密码：'</span>).strip()</span><br><span class="line">        <span class="comment"># 验证用户名和密码是否正确</span></span><br><span class="line">        <span class="keyword">if</span> username <span class="keyword">not</span> <span class="keyword">in</span> users.keys():</span><br><span class="line">            print(<span class="string">'用户名不存在'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> passwd == users[username]: <span class="comment"># 登录成功，将 current_user 设置为该用户</span></span><br><span class="line">                current_user[<span class="string">'username'</span>] = username</span><br><span class="line">                current_user[<span class="string">'login'</span>] = <span class="literal">True</span></span><br><span class="line">                print(<span class="string">'登录成功'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'用户名或密码输入错误，请重新登录'</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth_deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span> <span class="comment"># 在进入页面前先校验用户是否登录了</span></span><br><span class="line">    <span class="keyword">if</span> current_user[<span class="string">'username'</span>]:</span><br><span class="line">        print(<span class="string">'你好, %s'</span> %current_user[<span class="string">'username'</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'请先登录'</span>)</span><br><span class="line"></span><br><span class="line">index()</span><br></pre></td></tr></table></figure><h4 id="用装饰器实现数据库连接"><a href="#用装饰器实现数据库连接" class="headerlink" title="用装饰器实现数据库连接"></a>用装饰器实现数据库连接</h4><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://foofish.net/python-decorator.html" target="_blank" rel="noopener">理解 Python 装饰器看这一篇就够了</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 中的函数与 java、c++ 中不同之处在于： python 中的函数可以作为变量当做参数传入另一个函数中。装饰器 Decorator 本质上就是一个 python 函数，可以让其他函数在不需要任何代码变动的前提下增加额外功能。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python decimal 模块</title>
    <link href="https://xieyiyu.github.io/2019/08/10/python/Python-decimal-%E6%A8%A1%E5%9D%97/"/>
    <id>https://xieyiyu.github.io/2019/08/10/python/Python-decimal-%E6%A8%A1%E5%9D%97/</id>
    <published>2019-08-10T17:21:30.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>python 中的 decimal 模块提供十进制浮点运算支持。</p><a id="more"></a><p>我们先来看下直接对两个浮点数进行运算得到的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1.1</span></span><br><span class="line">b = <span class="number">2.2</span></span><br><span class="line">print(a + b) <span class="comment"># 输出 3.3000000000000003</span></span><br></pre></td></tr></table></figure><p>输出不是期望的 3.3，这是由于原生的二进制浮点数本身存在误差，直接计算的话会得到不精确的结果。 为了消除这种误差，可以用 decimal 模块进行更加精确的浮点计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line">a = Decimal(<span class="string">'1.1'</span>)</span><br><span class="line">b = Decimal(<span class="string">'2.2'</span>)</span><br><span class="line">print(a + b) <span class="comment"># 输出 3.3</span></span><br></pre></td></tr></table></figure><h3 id="设定有效数字"><a href="#设定有效数字" class="headerlink" title="设定有效数字"></a>设定有效数字</h3><p>通过 getcontext().prec 可以设置有效数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> getcontext</span><br><span class="line">getcontext().prec = <span class="number">4</span></span><br><span class="line">print(Decimal(<span class="string">'2.2'</span>)/Decimal(<span class="string">'1.3'</span>)) <span class="comment"># 1.692</span></span><br></pre></td></tr></table></figure><h3 id="设定小数位数"><a href="#设定小数位数" class="headerlink" title="设定小数位数"></a>设定小数位数</h3><p>Deicmal() 函数可以四舍五入设置保留的小数位，且不用管小数原来的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line">Decimal(num).quantize(Decimal(<span class="string">'0.000000'</span>)) <span class="comment"># 四舍五入，保留六位小数，不管 num 是什么形式</span></span><br></pre></td></tr></table></figure><p>而使用格式化的方式，如 float(‘%.6f’ % a) 可以控制保留六位小数，但是如果后面都是 0 的话，比如 0.00000，返回的是 0.0； 如果是 1.2200000 的话，返回的是 1.22</p><p>【参考】<br><a href="https://finthon.com/python-decimal/" target="_blank" rel="noopener">Python中的decimal模块执行精确的浮点运算</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 中的 decimal 模块提供十进制浮点运算支持。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 单例模式</title>
    <link href="https://xieyiyu.github.io/2019/08/05/python/Python-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://xieyiyu.github.io/2019/08/05/python/Python-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-08-05T17:33:26.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是确保某个类只有一个实例存在，保证了在程序的不同位置都可以且仅可以取到同一个对象实例。如果实例不存在，会创建一个实例；如果已存在就会返回这个实例。</p><a id="more"></a><h2 id="单例模式特点"><a href="#单例模式特点" class="headerlink" title="单例模式特点"></a>单例模式特点</h2><p>只有一个实例、单例类的构造函数是私有的，自行创建类的实例、向整个系统公开这个实例接口</p><h2 id="单例模式使用场景"><a href="#单例模式使用场景" class="headerlink" title="单例模式使用场景"></a>单例模式使用场景</h2><ol><li>Python 的 logger 就是一个单例模式，用以日志记录</li><li>Windows 的资源管理器是一个单例模式</li><li>线程池，数据库连接池等资源池一般也用单例模式</li><li>网站计数器</li></ol><p>为什么不用全局变量？<br>全局变量不能保证应用程序只有一个实例，且可能会有名称空间的干扰，如果有重名的可能会被覆盖，不能继承</p><h2 id="python-实现单例模式"><a href="#python-实现单例模式" class="headerlink" title="python 实现单例模式"></a>python 实现单例模式</h2><p>python 有多种方式来实现单例模式： 模块、<code>__new__</code>、 装饰器、 元类 metaclass</p><h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p><strong>python  的模块就是天然的单例模式</strong>，在模块第一次导入时，会生成 <code>.pyc</code> 文件，之后的导入就会加载 <code>.pyc</code> 文件，而不会再次执行模块代码。</p><p>如果想创建一个单例类，可以新建一个 mysingleton.py 文件，也就是一个模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">my_singleton = My_Singleton()</span><br></pre></td></tr></table></figure><p>在其他文件中，只要导入上满这个模块中的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure><h3 id="使用-new-方法"><a href="#使用-new-方法" class="headerlink" title="使用 __new__ 方法"></a>使用 <code>__new__</code> 方法</h3><p>为了使类只能出现一个实例，可以用 <code>__new__</code> 来控制实例的创建过程，将类的实例和一个类变量 <code>_instance</code> 关联起来，如果 <code>cls._instance</code> 为 None 则创建实例，否则直接返回 <code>cls._instance</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">s1 = Singleton()</span><br><span class="line">s2 = Singleton()</span><br><span class="line">print(id(s1) == id(s2)) <span class="comment"># True,说明是同一个实例</span></span><br></pre></td></tr></table></figure><p>但是当有多个线程同时去初始化对象时，就很可能同时判断 <code>_instance is None</code>，无法实现单例。这种情况下，需要用同步锁来解决问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> synchronize <span class="keyword">import</span> make_synchronized</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"><span class="meta">    @make_synchronized # 用装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h3><p>可以使用装饰器来修饰某个类，使其只能生成一个实例。</p><ol><li>定义一个装饰器 singleton，它返回了一个内部函数 getinstance，该函数会判断某个类是否在字典 instances 中。</li><li>如果不存在，将 <code>cls</code> 作为 key，<code>cls(*args, **kw)</code> 作为 value 存到 instances 中，否则，直接返回 <code>instances[cls]</code>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h3><p>元类（metaclass）可以控制类的创建过程，它主要做三件事：</p><ol><li>拦截类的创建</li><li>修改类的定义</li><li>返回修改后的类</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(metaclass=Singleton)</span>:</span></span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式是确保某个类只有一个实例存在，保证了在程序的不同位置都可以且仅可以取到同一个对象实例。如果实例不存在，会创建一个实例；如果已存在就会返回这个实例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/tags/Python/"/>
    
      <category term="设计模式" scheme="https://xieyiyu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python 面向对象</title>
    <link href="https://xieyiyu.github.io/2019/08/02/python/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://xieyiyu.github.io/2019/08/02/python/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2019-08-02T17:36:17.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象编程(OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。简单的说就是基于类和对象的使用。</p><a id="more"></a><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象的三个特征：封装、继承、多态</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别。</p><ul><li>封装数据： 为了保护隐私，明确区分内外数据，对外提供操作该数据的接口</li><li>封装方法： 目的是隔离复杂度</li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在定义一个类的时候可以从当前有的类中进行继承。</p><p>python 允许多继承，并且在子类中拥有父类所有的成员变量和方法，为了缓解代码中的冗余，子类在父类的基础上增加的成员变量可以如下修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Person)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">Person.__init__(self, name, sex)</span><br><span class="line">self.mother = mother</span><br></pre></td></tr></table></figure><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>当子类继承父类之后，成员方法既可以重写也可以不重写。当调用的时候只要保证新方法编写正确，不用管原来的代码</p><ul><li>对扩展开放（Open for extension）：允许子类重写方法函数</li><li>对修改封闭（Closed for modification）：不重写，直接继承父类方法函数</li></ul><p>鸭子类型： 一些类含有相同的方法，则这些类就互称为鸭子</p><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p><h4 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h4><p>private：私有变量以 <code>__</code> 开头，只有内部能够访问，可以给类增加 get、set 方法<br>特殊变量： <code>__xxx__</code>, 可以直接访问</p><h4 id="init-和-new-区别"><a href="#init-和-new-区别" class="headerlink" title="init 和 new 区别"></a><strong>init</strong> 和 <strong>new</strong> 区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值。</span><br><span class="line">__new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例，是个静态方法。</span><br><span class="line"></span><br><span class="line">即，__new__在__init__之前被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. __init__ 方法为初始化方法, __new__方法才是真正的构造函数，创建实例。</span><br><span class="line">2. __new__方法默认返回实例对象供__init__方法、实例方法使用。</span><br><span class="line">3. __init__ 方法为初始化方法，为类的实例提供一些属性或完成一些动作。</span><br><span class="line">4. __new__是一个静态方法，而__init__是一个实例方法。</span><br></pre></td></tr></table></figure><h4 id="self-和-cls-区别"><a href="#self-和-cls-区别" class="headerlink" title="self 和 cls 区别"></a>self 和 cls 区别</h4><p>self 是实例方法定义，cls 主要用在类方法定义。</p><p>一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。<br>而使用 @staticmethod 或 @classmethod，就可以不需要实例化，直接类名.方法名()来调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span><span class="params">(name)</span>:</span> <span class="comment"># 静态函数，这种方法与类有某种关系但不需要使用到实例或者类来参与</span></span><br><span class="line">print(name) <span class="comment"># 既可以作为类的方法使用，也可以作为类的实例的方法使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo2</span><span class="params">(self, name)</span>:</span></span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo3</span><span class="params">(cls, name)</span>:</span></span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.foo1(<span class="string">'xyy'</span>)</span><br><span class="line">A.foo1(<span class="string">'xyy'</span>)</span><br><span class="line"></span><br><span class="line">a.foo2(<span class="string">'xyy'</span>)</span><br><span class="line">A.foo2(<span class="string">'xyy'</span>) <span class="comment"># 报错</span></span><br><span class="line"></span><br><span class="line">a.foo3(<span class="string">'xyy'</span>)</span><br><span class="line">A.foo3(<span class="string">'xyy'</span>)</span><br></pre></td></tr></table></figure><p>@staticmethod 和 @classmethod 都可以直接类名.方法名()来调用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向对象编程(OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。简单的说就是基于类和对象的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/tags/Python/"/>
    
      <category term="面向对象" scheme="https://xieyiyu.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引</title>
    <link href="https://xieyiyu.github.io/2019/07/28/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <id>https://xieyiyu.github.io/2019/07/28/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</id>
    <published>2019-07-28T13:34:02.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>数据库索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息，索引的目的是为了加快检索表中数据。索引的实现通常使用 B树 及其变种 B+树。</p><a id="more"></a><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>原理：通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。 </p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ol><li>创建唯一索引，保证数据库表中每行数据的唯一性</li><li>加快数据的检索速度</li><li>加速表与表之间的连接，特别是在实现数据的参考完整性方面特别有意义</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li></ol><p>缺点:</p><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>适用于建立索引的情况：<code>主键、经常搜索、连接(外键)、排序的、where 的、统计或分组的</code></p><ol><li>建立在经常需要搜索的字段上，可以加快搜索的速度；</li><li>在作为主键的字段上，强制该列的唯一性和组织表中数据的排列结构；</li><li>经常与其他表进行连接的字段，这些字段主要是外键，可以加快连接的速度；</li><li>经常需要根据范围进行搜索的字段上创建索引，因为索引已经排序，其指定的范围是连续的；</li><li>在经常需要排序的字段上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</li><li>经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</li></ol><p>不适用于建立索引的情况：</p><ol><li>查询中很少使用或者参考的字段不应该创建索引。</li><li>数据值选择性很低的字段，不适合建索引，比如性别</li><li>对于大的文本字段甚至超长字段，不要建索引，比如text, image 和 bit 数据类型</li><li>修改操作远远多于检索操作时，不应该创建索引。</li><li>频繁更新（增删改）的字段不适合创建索引</li></ol><h3 id="mysql-创建索引的方式"><a href="#mysql-创建索引的方式" class="headerlink" title="mysql 创建索引的方式"></a>mysql 创建索引的方式</h3><p>在执行 CREATE TABLE 语句时可以创建索引，也可以单独用 CREATE INDEX 或 ALTER TABLE 来为表增加索引。</p><ol><li><p>在创建表时建立索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">sno <span class="built_in">INT</span> AUTO_INCREMENT</span><br><span class="line">sname <span class="built_in">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">birth <span class="built_in">DATE</span></span><br><span class="line"></span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(sno) <span class="comment"># 创建主键索引</span></span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> [sname_index] (sname) <span class="comment"># 创建唯一索引，也可以在上面字段定义时使用 UNIQUE 来创建</span></span><br><span class="line"><span class="keyword">INDEX</span> [sname_birth_index] (sname, birth) <span class="comment"># 创建普通的组和索引</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>CREATE [UNIQUE | CLUSTERED] INDEX index_name ON table_name(column_name1 ASC, column_name2 DESC)<br>注意： create index 不能创建主键索引</p></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>|CLUSTERED] <span class="keyword">INDEX</span> [index_name] (<span class="keyword">column</span> <span class="keyword">name</span>)</span><br></pre></td></tr></table></figure><p>alter table 可以创建主键索引： ALTER TABLE student ADD PRIMARY KEY (sno)</p></li></ol><p><strong>删除索引</strong>  </p><ol><li>DROP INDEX index_name ON table_name</li><li>ALTER TABLE table_name DROP INDEX index_name</li><li>ALTER TABLE table_name DROP PRIMARY KEY</li></ol><p><strong>查看索引</strong><br>SHOW INDEX FROM database_name.table_name;</p><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><p>聚簇索引：物理索引，与基表的物理顺序相同，数据值的顺序总是按照顺序排列。一般情况下主键会默认创建聚簇索引，在一张表上最多只能创建一个聚集索引。直接缩小范围找到记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CLUSTERED <span class="keyword">INDEX</span> my_index <span class="keyword">ON</span> student(<span class="keyword">id</span>)</span><br></pre></td></tr></table></figure><p>非聚簇索引： 表数据存储顺序与索引顺序无关，需要通过位置去找到记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> UNCLUSTERED <span class="keyword">INDEX</span> my_index <span class="keyword">ON</span> student(my_column)</span><br></pre></td></tr></table></figure><h3 id="唯一索引与主键索引"><a href="#唯一索引与主键索引" class="headerlink" title="唯一索引与主键索引"></a>唯一索引与主键索引</h3><p>唯一索引： 保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用，允许有空值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> CLUSTERED <span class="keyword">INDEX</span> my_index <span class="keyword">ON</span> student(my_column)</span><br></pre></td></tr></table></figure><p>主键索引： 就是主键，是一种特殊的唯一索引，不能为空。一张表中只能定义一个主键索引，通常有一列或列组合，用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。为表定义一个主键将自动创建主键索引（聚簇索引）。主键可以是聚簇索引也可以是非聚簇索引。</p><p>区别：</p><ol><li>主键索引一定是唯一索引，唯一索引不一定是主键索引</li><li>唯一索引可以为空，主键索引不能为空</li><li>一张表只能有一个主键索引，可以有多个唯一索引</li></ol><h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><ol><li>如果条件中有 or，即使其中有部分条件带索引也不会使用。 要想使用 or，又想让索引生效，只能将 or 条件中的每个列都加上索引。</li><li>like 查询是以 % 开头，索引失效；但以 % 结尾，索引可以使用</li><li>存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>对于多列索引，必须满足 最左匹配原则 (eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)。</li><li>where 子句里对索引列上有数学运算，用不上索引</li><li>where 子句里对有索引列使用函数，用不上索引， where abs(id)=1</li><li>如果 mysql 估计使用全表扫描要比使用索引快,则不使用索引，比如数据量极小的表</li></ol><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>一般把排序分组频率最高的列放在最左边。</p><p>如果在一个表的三列，col1，col2，col3 建立了一个联合索引，在 select 语句中：</p><ol><li>where col1，where col1 and col2， where col1 and col2 and col3，可以命中索引</li><li>where col2，where col3，不会命中索引</li><li>where col1 and col3，能够命中部分索引，也就是 col1 这部分</li><li>where col2 and col1，先会拿 col2 去比较，没有结果，但是 mysql 会对这个语句进行优化，把 col1 放在第一位，因此可以命中索引 </li></ol><h2 id="索引的实现原理"><a href="#索引的实现原理" class="headerlink" title="索引的实现原理"></a>索引的实现原理</h2><h3 id="为什么加索引能够优化慢查询："><a href="#为什么加索引能够优化慢查询：" class="headerlink" title="为什么加索引能够优化慢查询："></a>为什么加索引能够优化慢查询：</h3><p>DB 在执行一条 Sql 语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。 </p><p>索引其实是一种优化查询的数据结构，比如 Mysql 中的索引是用 B+ 树实现的，而 B+ 树就是一种能够优化查询速度的数据结构，可以利用索引快速查找数据，所以能优化查询。</p><p>能够优化查询速度的数据结构： B 树、 B+ 树、 哈希表、 平衡二叉树等</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h3><p>B-树（Balance tree），也叫 B树，是一种平衡的多叉树，又称平衡多路查找树或外部查找树。</p><p>满足条件：</p><ol><li>任意非叶子节点最多只有 M 个儿子节点，且 M &gt; 2</li><li>根节点的儿子数为 [2, M]</li><li>除根节点外的非叶子节点的儿子数为 [M/2, M]</li><li>每个节点存放至少 M/2-1（取上整）和至多 M-1 个关键字（至少2个关键字）</li><li>非叶子节点的关键字个数 = 指向儿子的指针个数 - 1</li><li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li><li>非叶子结点的指针：P[1], P[2], …, P[M]；其中 P[1] 指向关键字小于 K[1] 的子树，P[M] 指向关键字大于 K[M-1] 的子树，其它 P[i] 指向关键字属于 (K[i-1], K[i]) 的子树；</li><li>所有叶子结点位于同一层；</li></ol><p>如图，一棵 M=3 的 B-树</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1564304350/B-tree.jpg"></div><p>B-树的特性：</p><ol><li>关键字集合分布在整颗树中；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束；</li><li>其搜索性能等价于在关键字全集内做一次二分查找；</li><li>自动层次控制；</li></ol><p>B-树的查找性能为 O(logn), n 为关键词总数， 与 M 无关。</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B-树的变体，sqlite、mysql 应用 B+树处理索引。</p><p>B+树与B-树的定义基本相同，除了以下几点：</p><ol><li>非叶子结点的子树指针与关键字个数相同</li><li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树，（注意B-树是开区间）</li><li>所有叶子结点增加一个链指针，构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li><li>所有关键字都在叶子结点出现，非叶子节点仅具有索引作用</li></ol><p>如图，一棵 M=3 的 B+树</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1564304772/B%2Btree.jpg"></div><p>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p><h3 id="B-树和B-树的优点"><a href="#B-树和B-树的优点" class="headerlink" title="B+树和B-树的优点"></a>B+树和B-树的优点</h3><p>B+ 树的优点：</p><ol><li>由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的 key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。</li><li>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li></ol><p>B-树的优点：<br>由于B树的每一个节点都包含 key 和 value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</p><h3 id="B-树和B-树的区别"><a href="#B-树和B-树的区别" class="headerlink" title="B+树和B-树的区别"></a>B+树和B-树的区别</h3><ol><li><p>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个叶子结点，但是其只拥有m-1个关键字。</p></li><li><p>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</p></li><li><p>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</p></li><li><p>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</p></li></ol><h3 id="数据库索引为何不用二叉树"><a href="#数据库索引为何不用二叉树" class="headerlink" title="数据库索引为何不用二叉树"></a>数据库索引为何不用二叉树</h3><p>考虑到磁盘 IO 的影响，它相对于内存来说是很慢的。</p><p>数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。</p><p>所以我们要减少 IO 次数，对于树来说，IO 次数就是树的高度，而“矮胖”就是b树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。</p><h3 id="为什么-mysql-要用-B-树"><a href="#为什么-mysql-要用-B-树" class="headerlink" title="为什么 mysql 要用 B+树"></a>为什么 mysql 要用 B+树</h3><p>mysql 中的数据是存放在磁盘中的，读取数据需要对磁盘进行访问，数据量太大的话无法一次性加载到内存中，而使用 B树或B+树就只需加载部分索引。<strong>局部性原理与磁盘预读</strong></p><p>预读: 即使只需要一个字节，操作系统也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这里的一定长度叫做页，也就是操作系统操作磁盘时的基本单位。一般操作系统中一页的大小是4Kb。</p><p><strong>磁盘预读</strong><br>当一个数据被用到时，其附近的数据也通常会马上被使用。 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><p><strong>不用 AVL 或 红黑树的原因是</strong>：当数据量比较大时，都会由于树的深度过大而造成 IO 读写过于频繁，进而导致查询效率低下。而B+树的操作能够保持较低的高度，从而保证高效的查找效率。</p><p><strong>不用 B 树的原因是</strong>：</p><ol><li><p>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p></li><li><p>B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></li><li><p>数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，方便扫库，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。<br>对于多条数据的查找，B树要做局部的中序遍历，还可能要跨层访问；而B+树所有数据都在叶子节点，不用跨层，且有链表结构，只需要找到首尾通过链表就能读出所有数据。</p></li></ol><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ol><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ol><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><p>用 B+树查找的时间为 O(logn)，用 hash 查找的时间为 O(1)，那索引实现为什么要用 B+树而不是 hash 呢？<br>答： 与业务场景相关</p><ol><li>如果只查找一个值的话，hash 是一个很好的选择，而数据库经常会选择多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比 hash 就快得多。</li><li>数据库中的索引一般是在磁盘上，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，能够提高查找效率。</li></ol><h2 id="MyIASM-和-InnoDB-的索引结构"><a href="#MyIASM-和-InnoDB-的索引结构" class="headerlink" title="MyIASM 和 InnoDB 的索引结构"></a>MyIASM 和 InnoDB 的索引结构</h2><h3 id="MyIASM"><a href="#MyIASM" class="headerlink" title="MyIASM"></a>MyIASM</h3><p>MyISAM 引擎的索引结构为 B+树，其中B+树的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，索引文件仅保存数据记录的地址，只不过是用索引指向了实际的数据，这种索引就是非聚集索引。</p><p>在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 引擎的索引结构也是 B+树，但是 Innodb 的索引文件本身就是数据文件，即B+树的数据域存储的就是实际的数据，这种索引是聚集索引。这个索引的 key 就是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。</p><p>InnoDB 的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。<br>InnoDB 不建议使用过长的主键，否则会使辅助索引变得过大。建议使用自增的字段作为主键，这样B+树的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。</p><p>InnoDB 数据文件本身是一颗B+树。</p><p>B+ 树一个节点的大小： Mysql的Innodb引擎中一页的默认大小是16k（如果操作系统中一页大小是4k，那么Mysql中1页=操作系统中4页）</p><p>B+ 树一个节点存储的内容：<br>非叶子节点： 索引 + 指针<br>叶子节点： 数据</p><p>【参考文献】<br><a href="#https://blog.csdn.net/u013411246/article/details/81088914">B树、B-树、B+树、B*树之间的关系</a><br><a href="https://www.cnblogs.com/0201zcr/p/5296843.html" target="_blank" rel="noopener">mysql 数据库引擎</a><br><a href="https://juejin.im/post/5c822b0ce51d453a42155c3d" target="_blank" rel="noopener">面试必备之MYSQL索引底层原理分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息，索引的目的是为了加快检索表中数据。索引的实现通常使用 B树 及其变种 B+树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://xieyiyu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://xieyiyu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="索引" scheme="https://xieyiyu.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="B Tree" scheme="https://xieyiyu.github.io/tags/B-Tree/"/>
    
  </entry>
  
  <entry>
    <title>同步异步和阻塞非阻塞</title>
    <link href="https://xieyiyu.github.io/2019/07/20/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>https://xieyiyu.github.io/2019/07/20/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E5%92%8C%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</id>
    <published>2019-07-20T16:53:09.000Z</published>
    <updated>2020-01-17T02:24:43.244Z</updated>
    
    <content type="html"><![CDATA[<p>在实际开发中，经常会听到同步、异步、阻塞、非阻塞等概念，还可能遇到以下四种组合情况：</p><ol><li>同步 + 阻塞</li><li>同步 + 非阻塞</li><li>异步 + 阻塞</li><li>异步 + 非阻塞</li></ol><a id="more"></a><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步和异步是指: 请求发起方对消息结果的获取是主动发起的，还是等被动通知的。</p><ol><li>请求方主动发起，一直在等待应答结果： 同步阻塞</li><li>请求方主动发起，先去处理其他的事情，但通过不断轮询查看发起的请求是否有应答结果： 同步非阻塞</li><li>由服务方通知，也就是请求方发出请求后，一直在等待通知：异步阻塞</li><li>由服务方通知，请求方发出请求后，就先去处理其他事情：异步非阻塞<br>当事情处理完成之后，服务方会主动通知请求方，它的请求已经完成，这就是异步。异步通知的方式一般是通过状态改变，消息通知，或者回调函数来完成，大多数时候采用的都是回调函数。</li></ol><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞和非阻塞概念通常是和对于 IO 操作，如网络 IO 和磁盘 IO 等</p><p>阻塞和非阻塞通常形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其它所有需要这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。而非阻塞允许多个线程同时进入临界区。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实际开发中，经常会听到同步、异步、阻塞、非阻塞等概念，还可能遇到以下四种组合情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步 + 阻塞&lt;/li&gt;
&lt;li&gt;同步 + 非阻塞&lt;/li&gt;
&lt;li&gt;异步 + 阻塞&lt;/li&gt;
&lt;li&gt;异步 + 非阻塞&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://xieyiyu.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构之哈希表</title>
    <link href="https://xieyiyu.github.io/2019/07/09/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://xieyiyu.github.io/2019/07/09/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2019-07-09T11:25:58.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>哈希 (Hash、散列) 是电脑科学中一种对资料的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。</p><a id="more"></a><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>Hash 就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。直观解释起来，就是对一串数据 m 进行杂糅，输出另一段固定长度的数据 h，作为这段数据的特征（指纹）。也就是说，无论数据块 m 有多大，其输出值 h 为固定长度。这种转换是一种压缩映射。</p><p>Hash 主要应用于数据结构中和密码学中。</p><ul><li>使用 Hash 的数据结构叫做哈希表，主要是为了提高查询的效率。</li><li>在密码学中，hash 算法的作用主要是用于消息摘要和签名，主要用于对整个消息的完整性进行校验。</li></ul><p>hash 函数的特点：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同。</p><h3 id="常见的-hash-函数"><a href="#常见的-hash-函数" class="headerlink" title="常见的 hash 函数"></a>常见的 hash 函数</h3><ul><li><p>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。</p></li><li><p>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。</p></li><li><p>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。</p></li><li><p>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</p></li><li><p>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</p></li><li><p>伪随机数法：采用一个伪随机数当作哈希函数。</p></li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表（Hash table，也叫散列表），是根据关键码值 (Key value) 而直接进行访问的数据结构。</p><p>根据键（Key）值将数据映射到内存中一个位置的函数称为哈希函数，根据哈希函数建立的记录数据的表称为哈希表。</p><p>使用哈希表可以进行非常快速的查找操作，查找时间为 O(1)， 且不需要元素排列有序。 </p><p>尽管最坏的情况下，哈希表中查找一个元素的时间与链表中查找的时间相同，达到了O(n)。但在实际应用中，散列的查找的性能是极好的。在一些合理的假设下，在散列表中查找一个元素的平均时间是 O(1)。</p><h3 id="哈希表实现过程"><a href="#哈希表实现过程" class="headerlink" title="哈希表实现过程"></a>哈希表实现过程</h3><ol><li>存储时，通过哈希函数计算记录的哈希地址，并按此地址存储该记录。</li><li>查找记录时，同样通过哈希函数计算记录的散列地址，按此散列地址访问该记录。</li></ol><p>所以说散列技术既是一种存储方法，也是一种查找方法。它与线性表、树、图等数据结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，而哈希技术之间数据元素不存在逻辑关系，它只与关键字有关系。因此，哈希主要是面向查找的存储结构。</p><h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><p>冲突指不同键经过哈希函数计算得到相同的索引，这样造成索引重复的冲突，即 k1≠k2，而 f(k1)=f(k2)。</p><h4 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h4><p>开放定址法就是产生冲突之后去寻找下一个空闲的空间，需要探测出一个尚未被占用的索引。因为需要探测，所以添加一个 key-value 对可能需要更多的时间，但是查找仍是 O(1) 时间复杂度的。</p><h4 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h4><p>散列到同一位置的元素，不是继续往下探测，而是在这个位置是一个链表，这些元素则都放到这一个链表上。</p><h2 id="python-中的哈希"><a href="#python-中的哈希" class="headerlink" title="python 中的哈希"></a>python 中的哈希</h2><p>hash() 用于获取取一个对象（字符串或者数值等）的哈希值，不能直接应用于 list、set、dict。</p><p>在 hash() 对对象使用时，所得的结果不仅和对象的内容有关，还和对象的 id()，也就是内存地址有关。</p><p>hash() 函数的对象字符不管有多长，返回的 hash 值都是固定长度的。</p><h3 id="python-字典"><a href="#python-字典" class="headerlink" title="python 字典"></a>python 字典</h3><p>python 的内建数据类型 dict 字典，就是用哈希表实现的。</p><p>Python 是使用开放寻址法中的二次探查来解决冲突的。然后如果使用的容量超过数组大小的 2/3，就申请更大的容量。数组大小较小的时候 resize 为 * 4，较大的时候 resize * 2。实际上是用左移的形式。</p><h3 id="dict-和-HashMap-区别"><a href="#dict-和-HashMap-区别" class="headerlink" title="dict 和 HashMap 区别"></a>dict 和 HashMap 区别</h3><p>pyhton dict 和 java HashMap 都是采用哈希表实现，不同的是 dict 在发生哈希冲突的时候采用了开放寻址法，而 HashMap 采用了链接法。</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>在 JDK1.8 中，HashMap 底层是用数组 Node&lt;K,V&gt; 数组存储，数组中每个元素用链表存储元素，当元素超过 8 个时，将链表转化成红黑树存储。</p><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器 Bloom Filter 是一种多哈希函数映射的快速查找算法。通常应用于快速判断一个元素是否属于集合，但是并不是严格要求 100% 正确的场合。 </p><ul><li>优点： 优空间效率和查询时间都远远超过一般的算法</li><li>缺点：有一定的误识别率，但是它只会把不存在集合中的元素误判成存在于集合中，而不会把存在集合中的元素误判成不存在集合中。且不能删除已经插入的关键词，因此该元素的位置会影响其他元素。</li></ul><p>改进： 改进就是 counting Bloom filter，用一个 counter 数组代替位数组，就可以支持删除了</p><h3 id="Bloom-Filter-原理"><a href="#Bloom-Filter-原理" class="headerlink" title="Bloom Filter 原理"></a>Bloom Filter 原理</h3><p>Bloom Filter 实际上是一个很长的二进制向量和一系列随机映射函数，将一个值映射到布隆过滤器中，需要使用多个不同的哈希函数生成多个哈希值，然后在布隆过滤器中，给每个哈希值的 index 置 1。</p><p>判断一个元素是否存在于集合中，使用哈希函数得到多个哈希值，判断每个哈希值的 index 是否为 1，只要有一个是 0，这个元素就不可能存在集合中；但可能会误判，因为不同的元素计算出的哈希值可能是相同的，但在布隆过滤器中都是 1，如果计算出的 k 个位置全部为1，则可能在集合中。</p><h3 id="如何选择哈希函数个数和布隆过滤器长度"><a href="#如何选择哈希函数个数和布隆过滤器长度" class="headerlink" title="如何选择哈希函数个数和布隆过滤器长度"></a>如何选择哈希函数个数和布隆过滤器长度</h3><p>布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。</p><p>哈希函数的个数越多则布隆过滤器 bit 位置位 1 的速度越快，那么布隆过滤器的效率越低；但是如果太少的话，误报率变高。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，就不用进行后续昂贵的查询请求。</p><p>性能较高的哈希函数有： MurmurHash、Fnv</p><p>【参考文献】<br><a href="https://python123.io/index/topics/data_structure/hash_table" target="_blank" rel="noopener">Python 数据结构入门 - 哈希表（Hash Table）</a><br><a href="#https://harveyqing.gitbooks.io/python-read-and-write/content/python_advance/python_dict_implementation.html">Python字典实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈希 (Hash、散列) 是电脑科学中一种对资料的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://xieyiyu.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://xieyiyu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希表" scheme="https://xieyiyu.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="dict" scheme="https://xieyiyu.github.io/tags/dict/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之红黑树</title>
    <link href="https://xieyiyu.github.io/2019/07/05/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://xieyiyu.github.io/2019/07/05/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2019-07-05T09:12:49.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树是平衡搜索树的一种，可以保证在最坏情况下基本动态集合操作的时间复杂度为 O(logn)</p><a id="more"></a><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树（BST），又称二叉排序树、二叉搜索树。叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，为 o(logn)。二叉查找树中序遍历一遍的结果是单调递增的，可以用于二分搜索。</p><ol><li>没有键值相等的节点</li><li>若<strong>左子树</strong>不为空，则左子树上节点值<strong>均小于</strong>根节点的值</li><li>若<strong>右子树</strong>不为空，则右子树上节点值<strong>均大于</strong>根节点的值</li><li>任意节点的左、右子树也是二叉查找树</li></ol><p>二叉排序树的性能取决于二叉树的层数：</p><ul><li>最好的情况是 O(logn)，存在于完全二叉排序树情况下，其访问性能近似于折半查找；</li><li>最差时候会是 O(n)，比如插入的元素是有序的，二叉查找树退化为单链表时，需要遍历全部元素。</li></ul><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1564277685/red-black-tree.png"></div><p>红黑树具有五条性质：</p><ol><li>每个结点要么是红的，要么是黑的。  </li><li>根结点是黑的。  </li><li>每个叶结点（叶结点即指树尾端 NIL 指针或 NULL 结点）是黑的。  </li><li>如果一个结点是红的，那么它的俩个儿子都是黑的。  </li><li>对于任一结点而言，其到叶结点树尾端 NIL 指针的每一条路径都包含相同数目的黑结点。  </li></ol><p>五大性质总结：</p><ol><li>对每个红色节点，子节点只有两种情况：要么都没有，要么都是黑色的。（不然会违反特征四）</li><li>对黑色节点，如果只有一个子节点，那么这个子节点，必定是红色节点。（不然会违反特征五）</li><li>假设从根节点到叶子节点中，黑色节点的个数是 h, 那么树的高度 H 范围 h &lt;= H &lt;= 2H（特征四五决定）， 因此红黑树的查找不会退化到线性查找，时间复杂度为 O(logn)。</li></ol><h3 id="树的旋转"><a href="#树的旋转" class="headerlink" title="树的旋转"></a>树的旋转</h3><p>当对红黑树进行插入或删除操作时，可能会破坏红黑树的结构。为了保持红黑树的性质，可以对结点重新着色，及对树进行旋转操作，修改树中某些结点的颜色及指针结构。</p><p>树的旋转包括左旋和右旋，红黑树左右旋的目的是调整红黑节点结构，转移黑色节点位置，使其在进行插入、删除后仍能保持红黑树的 5 条性质。</p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p>pivot 的左旋是： 把 pivot 变成它右孩子 Y 的左孩子，右孩子 Y 的左孩子变成它的右孩子；左旋是把右子树里的一个节点 (Y) 移动到左子树</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1564278589/left-rotate.jpg"></div><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p>pivot 的右旋是： 把 pivot 变成它左孩子 Y 的右孩子，左孩子 Y 的右孩子变成它的左孩子</p><div align="center"><img src="https://res.cloudinary.com/dty6stpv6/image/upload/v1564278589/right-rotate.jpg"></div><p>对于树的旋转，能保持不变的只有原树的搜索性质，而原树的红黑性质则不能保持，在红黑树的数据插入和删除后可利用旋转和颜色重涂来恢复树的红黑性质。</p><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><ol><li>首先和二叉查找树的插入一样，查找到结点插入的位置、插入</li><li>然后调整结构，保证满足红黑树状态:<ul><li>对结点进行重新着色</li><li>以及对树进行相关的旋转操作</li></ul></li></ol><p>二叉查找树的插入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, root, x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        root = TreeNode(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt; root.val:</span><br><span class="line">            root.left = self.insert(root.left, x) <span class="comment"># 递归的去查找插入点</span></span><br><span class="line">        <span class="keyword">elif</span> x &gt; root.val:</span><br><span class="line">            root.right = self.insert(root.right, x)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>红黑树定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, color=<span class="string">"R"</span>)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.color = color</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>红黑树的插入红黑树的插入在二叉查找树插入的基础上，为了重新恢复平衡，继续做了插入修复操作。插入的节点一般设定为红色然后再调整。</p><ol><li><p>若插入的是根节点，直接变成黑色</p></li><li><p>若插入节点的父节点是黑色，则不调整颜色</p></li><li><p>若插入节点的父节点为红色（违反性质四），且父节点的兄弟节点也为红色。<br>1) 把父节点及其兄弟节点变成黑色，把祖父节点变成红色（使其不违反性质五）。<br>2) 再检查祖父节点是否违反红黑树的性质（一或四）</p></li><li><p>若插入节点的父节点为红色（违反性质四），且父节点的兄弟节点为黑色，且插入节点，父节点，及祖父节点同侧：把父节点变成黑色节点，把祖父节点变成红色节点，同时反向旋转祖父节点（同左则，右旋； 同右则左旋）</p></li><li><p>若插入节点的父节点为红色（违反性质四），且父节点的兄弟节点为黑色，且插入节点，父节点，及祖父节点不同侧：  旋转父节点，使期变成同侧（第 4 种情况），再根据情况 4 来处理。</p></li></ol><p>具体的图解请参考：<a href="https://blog.csdn.net/net_wolf_007/article/details/79706498" target="_blank" rel="noopener">理解红黑树并实现(python3)</a></p><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p>【参考资料】<br><a href="https://blog.csdn.net/net_wolf_007/article/details/79706498" target="_blank" rel="noopener">理解红黑树并实现(python3)</a><br><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" target="_blank" rel="noopener">教你透彻了解红黑树</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;红黑树是平衡搜索树的一种，可以保证在最坏情况下基本动态集合操作的时间复杂度为 O(logn)&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://xieyiyu.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://xieyiyu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="红黑树" scheme="https://xieyiyu.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Python 异常处理</title>
    <link href="https://xieyiyu.github.io/2019/04/01/python/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://xieyiyu.github.io/2019/04/01/python/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2019-04-01T12:08:18.000Z</published>
    <updated>2020-01-17T02:24:43.240Z</updated>
    
    <content type="html"><![CDATA[<p>python 使用 try/except/finally 语句块来处理异常。 良好的异常处理可以让程序更加健壮，清晰的错误信息能够帮助快速修复问题。</p><a id="more"></a><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="try-except-finally"><a href="#try-except-finally" class="headerlink" title="try/except/finally"></a>try/except/finally</h3><p>try/except 语句用来检测 try 语句块中的错误，从而让 except 语句能够捕获异常信息并处理，except 可以有多个。 except 后面若不指定异常类型，则默认捕获所有异常，可以通过 logging 或 sys 模块获取当前异常。</p><p>try/finally 语句无论是否发生异常都将执行最后的代码，可以只使用 try/finally, 省略 except</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(a / b)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        print(<span class="string">"Error: b should not be 0 !!"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"Unexpected Error: &#123;&#125;"</span>.format(e))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Run into else only when everything goes well'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">'Always run into finally block.'</span>)</span><br><span class="line"></span><br><span class="line">div(<span class="number">2</span>, <span class="number">0</span>) <span class="comment"># Error: b should not be 0 !!</span></span><br><span class="line">div(<span class="number">2</span>, <span class="string">'bad type'</span>) <span class="comment"># Unexpected Error: unsupported operand type(s) for /: 'int' and 'str'</span></span><br><span class="line">div(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 0.5, 并打印 else 里的， finally 语句里的这三个最后都会执行</span></span><br></pre></td></tr></table></figure><h3 id="except-带多种异常类型"><a href="#except-带多种异常类型" class="headerlink" title="except 带多种异常类型"></a>except 带多种异常类型</h3><p>使用同一个 except 语句可以处理多个异常信息，只要发生多个异常中的一个，就执行代码。<br>语法： except(Exception1[, Exception2[,…ExceptionN]]])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(a / b)</span><br><span class="line">    <span class="keyword">except</span> (ZeroDivisionError, TypeError) <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure><h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>raise 关键字用于主动抛出一个异常，raise关键字后面可以指定你要抛出的异常实例，一般来说抛出的异常越详细越好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> NameError(<span class="string">"bad name!"</span>)</span><br></pre></td></tr></table></figure><h3 id="使用内置语法范式代替-try-except"><a href="#使用内置语法范式代替-try-except" class="headerlink" title="使用内置语法范式代替 try/except"></a>使用内置语法范式代替 try/except</h3><ol><li><p>for 语句处理了 StopIteration 异常，可以流畅地写出一个循环。</p></li><li><p>with 语句在打开文件后会自动调用 finally 中的关闭文件操作。 因此用 with open 来代替 try/except/finally</p></li><li><p>访问一个不确定的属性时，可以用 getattr() 方法，而不用再捕获异常 except AttributeError</p></li></ol><h2 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h2><p>python 的异常是一个类，所有的异常类型都继承自 BaseException 这个基类。 python 捕获所有异常时，应该用 Exception，Exception 继承自 BaseException。 可以自定义一个异常，继承自 Exception 类。</p><p>BaseException 除了包含所有的 Exception 外还包含了 SystemExit，KeyboardInterrupt 和 GeneratorExit 三个异常，但这三个属于更高级别的异常，合理的做法是交给 Python 解释器处理。</p><p>python3 中使用 except Exception as e 来获取异常。</p><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h3><ul><li>BaseException 所有异常的基类</li><li>OverflowError 数值运算超过最大限制</li><li>IOError 输入/输出操作失败</li><li>ImportError 导入模块/对象失败</li><li>RuntimeError 一般运行时错误</li><li>SyntaxError 语法错误</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000007736783" target="_blank" rel="noopener">总结：Python中的异常处理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 使用 try/except/finally 语句块来处理异常。 良好的异常处理可以让程序更加健壮，清晰的错误信息能够帮助快速修复问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://xieyiyu.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
